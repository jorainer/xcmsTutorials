[{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"document discuss mass spectrometry (MS) data handling exploration using MsExperiment Spectra Bioconductor packages perform preprocessing small liquid chromatography (LC)-MS data set xcms package. addition use functionality MetaboCoreUtils MsCoreUtils package general tasks frequently performed metabolomics data analysis. preprocessing LC-MS data comprises chromatographic peak detection, sample alignment peak correspondence. Particular emphasis given deriving defining data-set dependent values crucial parameters popular preprocessing methods.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"Preprocessing first step analysis untargeted LC-MS gas chromatography (GC)-MS data. aim preprocessing quantification signals ions measured sample, adjusting potential LC drifts samples matching quantified signal across samples within experiment. resulting two-dimensional matrix abundances called LC-MS features samples can processed, e.g. normalizing data remove differences due sample processing, batch effects injection order-dependent signal drifts. preprocessing, LC-MS features usually characterized mass--charge ration (m/z) retention time, annotated actual ions metabolites represent. Data normalization annotation covered document.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"prerequisites","dir":"Articles","previous_headings":"Introduction","what":"Prerequisites","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"analysis document requires R version >= 4.3.0 recent versions MsExperiment Spectra Bioconductor packages well developmental version xcms package. can installed using code . xcms-preprocessing.Rmd file code analysis can downloaded [github] (https://github.com/jorainer/metabolomics2018) ideally git clone https://github.com/jorainer/metabolomics2018 command line.","code":"#' Install the Bioconductor package manager install.packages(\"BiocManager\")  #' Install the required packages BiocManager::install(c(\"msdata\",                        \"Spectra\",                        \"MsExperiment\",                        \"MetaboCoreUtils\",                        \"MsCoreUtils\",                        \"png\")) BiocManager::install(\"sneumann/xcms\")"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"mass-spectrometry","dir":"Articles","previous_headings":"Introduction","what":"Mass spectrometry","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"Mass spectrometry allows measure abundances charged molecules (ions) sample. Abundances determined ion counts specific mass--charge ratio m/z. measured signal represented spectrum: intensities along m/z.  Many ions result, measured MS alone, similar m/z making difficult impossible discriminate . MS thus frequently coupled second technology separate prior quantification based properties mass (e.g. based polarity). Common choices gas chromatography (GC) liquid chromatography (LC). typical LC-MS setup samples gets injected system, molecules separated LC column MS instruments continuously (discrete time points) continues measure ions get generated molecules eluting different time points LC-column. Molecules get thus separated two different dimensions, retention time dimension (LC) mass--charge dimension (MS) making easier measure identify molecules complex samples.  GC/LC-MS based untargeted metabolomics experiments data analyzed along retention time dimension chromatographic peaks (supposed represent signal ions certain type molecule) quantified.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"definitions-and-common-naming-convention","dir":"Articles","previous_headings":"Introduction","what":"Definitions and common naming convention","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"Naming conventions terms used document : chromatographic peak: peak containing signal ion retention time dimension (different mass peak represents signal along m/z dimension within spectrum). chromatographic peak detection: process chromatographic peaks identified within file. alignment: process adjusts retention time differences (.e. possible signal drifts LC) measurements/files. correspondence: grouping chromatographic peaks (presumably ion) across files. feature (LC-MS features): entity representing signal type ion/molecule, characterized specific retention time m/z. xcms, features represent identified chromatographic peaks grouped across files/samples.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"workflow-exploring-and-analyzing-lc-ms-data-with-spectra-and-xcms","dir":"Articles","previous_headings":"","what":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"workflow describes basic data handling (/O) mass spectrometry data using MsExperiment Spectra package, LC-MS data preprocessing using xcms. first part workflow focused data import, access visualization followed description simple data centroiding approach finally xcms-based LC-MS data preprocessing comprises chromatographic peak detection, alignment correspondence. workflow cover data normalization procedures, compound identification differential abundance analysis.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-import-and-exploration","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms","what":"Data import and exploration","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"example data set workflow consists two files mzML format signals pooled human serum samples measured ultra high performance liquid chromatography (UHPLC) system (Agilent 1290) coupled Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument. Chromatographic separation based hydrophilic interaction liquid chromatography (HILIC) separating metabolites depending polarity. setup thus allows measure small polar compounds hence metabolites main metabolic pathways. input files contain signals measured MS instrument (called profile mode data). reduce file sizes, data set restricted m/z range 105 134 retention times 0 260 seconds. code block first load required libraries define location mzML files, part msdata R package. also define data.frame describing samples/experiment pass readMsExperiment function imports data. Similar -disk-mode described (Gatto, Gibb, Rainer 2020), m/z intensity values immediately loaded memory required enables also analyses large experiments. Note real experiment suggested define phenodata table e.g. tab delimited text file (xls sheet) contains raw data file names along relevant sample information file additional columns. data table imported R using e.g. read.table read_xlsx (readxl R package) file names passed readMsExperiment files = paste0(MZML_PATH, \"/\", pd$mzML_file) MZML_PATH variable specifying directory containing data (mzML) files, pd imported phenodata table column named \"mzML_file\" containing names individual raw files. Next set parallel processing. ensures required cores registered available beginning analysis. data access analysis functions xcms per-file basis use setup default. MS data experiment now represented MsExperiment object. Phenotype information can retrieved sampleData function object. MS data stored Spectra object within MsExperiment can accessed using spectra function. Spectra object represents full LC-MS data experiment. element object spectrum (one sample/file) information provided respective original data (mzML) file. Spectra organized linearly, .e. spectra files within Spectra object, one .","code":"library(xcms) library(MsExperiment) library(Spectra)  ## Define the file names. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)  ## Define a data.frame with additional information on the files. pd <- data.frame(file = basename(fls),                  injection_idx = c(1, 19),                  sample = c(\"POOL_1\", \"POOL_2\"),                  group = \"POOL\") data <- readMsExperiment(fls, sampleData = pd) data ## Object of class MsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). #' Set up parallel processing using 2 cores if (.Platform$OS.type == \"unix\") {     register(bpstart(MulticoreParam(2))) } else {     register(bpstart(SnowParam(2))) } #' Access phenotype information sampleData(data) ## DataFrame with 2 rows and 5 columns ##            file injection_idx      sample       group spectraOrigin ##     <character>     <numeric> <character> <character>   <character> ## 1 20171016_P...             1      POOL_1        POOL /__w/_temp... ## 2 20171016_P...            19      POOL_2        POOL /__w/_temp... spectra(data) ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"basic-data-access-and-visualization","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms","what":"Basic data access and visualization","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"MS data experiment stored Spectra object within MsExperiment MsExperiment contains experiment’s sample information manages linkage samples spectra. length MsExperiment defined number samples within object. detailed , spectra function can used access MS data experiment. example calculate retention time range full experiment. Retention times can extracted rtime function Spectra object within data. avoid nested function calls hence improve readability code, use R pipe operator |> allows concatenate consecutive calls readable fashion. Spectra object returned spectra, contains spectra files (samples) experiment. access MS data single file (sample) need subset MsExperiment object particular sample extracting spectra data spectra. subset data second sample using [ function, access spectra sample, extract retention times calculate range. can also access single spectrum second sample visualize data. thus extract spectrum number 123 second sample use plotSpectra function plot spectrum.  can see several relatively large signals (peaks) spectrum also number low intensity peaks. spectrum represents single scan LC-MS data run second sample. ’s retention time can extracted rtime, intensity m/z values can extracted intensity mz functions. Note , even Spectra data single spectrum, intensity mz functions return NumericList intensity m/z values. get general overview full data combine spectra measured one sample single spectrum reporting maximum intensity peaks highly similar m/z values across spectra sample using combineSpectra function Spectra package. Parameter f allows define spectra data combined single spectrum. Since want aggregate spectra one sample, use f = fromFile(data) (fromFile returns sample index individual spectrum data set). combineSpectra uses combinePeaks function aggregate signal defined groups spectra. provides large variety possibilities combine spectra, case simply want sum signal peaks similar m/z hence use parameters intensityFun = max ppm = 10. See also ?combinePeaks full set parameters aggregation options. Base peak spectrum two samples. contrast single spectrum , base peak spectrum (BPS) shows peaks indicating presence ions samples m/z range. addition BPS can also create base peak chromatogram (BPC) aggregating peak intensities scan (spectrum) per sample. BPC orthogonal BPS provides general information LC run experiment. use chromatogram function extract data additional parameter aggregationFun = \"max\" report maximal intensity spectrum (hence discrete retention time). Base peak chromatogram two samples. line represents one sample. BPC shows noisy signal beginning chromatography, also distinct (chromatographic) peak signal. addition, can see slight drifts retention time two samples. Apart getting general overview data also possible explore data detail. end next focus specific subset data expect signal compound present serum samples. thus filter spectra data using filterRt function extracting spectra measured 180 181 seconds. present data set 6 spectra measured within one second two samples. extracting data Spectra object however lost now direct (inherent) association spectra samples experiment. extract name original data file data imported (see example ) use determine originating sample, involve additional R code. Alternatively, use filterRt function also directly MsExperiment subset MsExperiment hence link samples spectra remain intact. Note however filter subset functions available MsExperiment objects large variety useful filters available Spectra. present purpose however important keep sample association intact thus proceed plot previously extracted spectra. MS1 spectra measured 180 181 seconds can immediately spot several mass peaks spectrum, largest one m/z 130 second largest 106, represent signal ion Serine. calculate exact (monoisotopic) mass serine chemical formula C3H7NO3 using calculateMass function MetaboCoreUtils package. native serine molecule however uncharged can thus measured mass spectrometry. order detectable, molecules need first ionized injected MS instrument. different ions can () generated molecule, one commonly created ions (adducts) positive polarity [M+H]+ ion (protonated ion). calculate m/z values specific ions/adducts molecules, can use mass2mz function, also MetaboCoreUtils package. calculate m/z [M+H]+ ion serine providing monoisotopic mass molecule specifying ion interested . Also types adducts supported. listed adductNames function (adductNames() positively charged adductNames(\"negative\") negatively charge ions). mass2mz function always returns matrix columns reporting m/z requested adducts molecules (rows). Since requested single ion reduce matrix single numeric. can now use information subset MS data signal recorded ions particular m/z. use chromatogram function provide m/z range interest mz parameter. Ion trace ion serine strong signal visible around retention time 180 seconds likely represents signal [M+H]+ ion serine. object returned chromatogram function arranges individual Chromatogram objects (one per sample) two-dimensional array, columns samples (files) rows data slices (.e. m/z - rt ranges). type data representation likely replaced future efficient flexible data structure similar Spectra. Data individual chromatograms can accessed using intensity rtime functions. last focus tentative signal serine extracting ion chromatogram restricting certain retention time range. also pass retention time m/z range parameters rt mz chromatogram function instead filter whole experiment retention time m/z calling chromatogram created data subset. Extracted ion chromatogram serine. area chromatographic peak supposed proportional amount corresponding ion respective sample identification quantification peaks one goals LC-MS data preprocessing.","code":"length(data) ## [1] 2 spectra(data) |> rtime() |> range() ## [1]   0.275 259.757 data[2] |> spectra() |> rtime() |> range() ## [1]   0.275 259.752 sp <- spectra(data[2])[123] plotSpectra(sp) rtime(sp) ## [1] 34.314 intensity(sp) ## NumericList of length 1 ## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0 mz(sp) ## NumericList of length 1 ## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539 bps <- combineSpectra(spectra(data), f = fromFile(data),                       intensityFun = max, ppm = 10)  plotSpectra(bps) bpc <- chromatogram(data, aggregationFun = \"max\") plot(bpc) sps <- spectra(data) |> filterRt(c(180, 181)) sps ## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ## 4         1   180.235       646 ## 5         1   180.514       647 ## 6         1   180.793       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Tue May 30 11:14:58 2023] basename(dataOrigin(sps)) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" ## [5] \"20171016_POOL_POS_3_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" #' subset the whole MsExperiment data_sub <- filterRt(data, rt = c(180, 181)) #' extract spectra from the subset for the first sample spectra(data_sub[1L]) ## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Tue May 30 11:14:58 2023] plotSpectra(sps) library(MetaboCoreUtils) mass_serine <- calculateMass(\"C3H7NO3\") mass_serine ##  C3H7NO3  ## 105.0426 serine_mz <- mass2mz(mass_serine, \"[M+H]+\") serine_mz ##           [M+H]+ ## C3H7NO3 106.0499 serine_mz <- serine_mz[1, 1] serine_chr <- chromatogram(data, mz = serine_mz + c(-0.05, 0.05)) plot(serine_chr) #' get intensity and retention times for the chromatogram of the first #' sample ints <- intensity(serine_chr[1, 1]) head(ints) ## [1]  NA 559 659 278 492  NA rts <- rtime(serine_chr[1, 1]) head(rts) ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 data |> filterRt(rt = c(175, 189)) |> filterMz(mz = serine_mz + c(-0.05, 0.05)) |> chromatogram() |> plot()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"centroiding-of-profile-ms-data","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms","what":"Centroiding of profile MS data","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"MS instruments allow export data profile centroid mode. Profile data contains signal discrete m/z values (retention times) instrument collected data (R. Smith et al. 2014). MS instruments continuously sample record signals mass peak single ion one spectrum thus consist multiple intensities discrete m/z values. Centroiding process reduce mass peaks single representative signal, centroid. results much smaller file sizes, without loosing much information. xcms, specifically centWave chromatographic peak detection algorithm, designed centroided data, thus, prior data analysis, profile data, example data used , centroided. inspect profile data [M+H]+ ion adduct Serine. subset data m/z retention time range containing signal Serine use plot function subset MsExperiment visualize full MS data. plot function ideally called subsets MsExperiment full MS data. plot visualizes intensities individual peaks (color coded) two-dimensional retention time m/z space. Profile data Serine. plot shows data points measured instrument. column data points lower panel represents signal measured one discrete time point, stored one spectrum. can see distribution signal serine retention time also m/z dimension. Next smooth data spectrum using Savitzky-Golay filter, usually improves data quality reducing noise. Subsequently perform centroiding data based simple peak-picking strategy reports maximum signal mass peak spectrum replace spectra data data (MsExperiment) object. Centroided data Serine. centroiding reduced data single data point ion spectrum. advanced centroiding options can also fine-tune m/z value reported centroid see pickPeaks help centroiding vignette MSnbase package. next export centroided MS data files mzML format re-read data set . use export function data export centroided Spectra object. Parameter backend allows specify MS data backend used export, also define data format (use backend = MsBackendMzR() export data mzML format. Parameter file defines, spectrum, name file data exported. next import centroided data newly generated mzML files.","code":"data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() #' Smooth and centroid the spectra data sps_cent <- spectra(data) |> smooth(method = \"SavitzkyGolay\", halfWindowSize = 6L) |> pickPeaks(halfWindowSize = 2L)  #' replace spectra spectra(data) <- sps_cent  #' Plot the centroided data for Serine data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() export(spectra(data), backend = MsBackendMzR(),        file = basename(dataOrigin(spectra(data)))) fls <- basename(fls)  #' Read the centroided data. data <- readMsExperiment(fls, sampleData = pd)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-of-lc-ms-data","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms","what":"Preprocessing of LC-MS data","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"Preprocessing (untargeted) LC-MS data aims detecting quantifying signal ions generated molecules present sample. consists 3 steps chromatographic peak detection, alignment (also called retention time correction) correspondence (also called peak grouping). resulting matrix feature abundances can used input downstream analyses including data normalization, identification features interest annotation features metabolites.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms > Preprocessing of LC-MS data","what":"Chromatographic peak detection","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"Chromatographic peak detection aims identify peaks along retention time axis represent signal individual compounds’ ions. peak detection can performed xcms package using findChromPeaks function. Several peak detection algorithms available can configured specific parameter object: MatchedFilterParam perform peak detection described original xcms article (C. . Smith et al. 2006), CentWaveParam perform continuous wavelet transformation (CWT)-based peak detection (Tautenhahn, Böttcher, Neumann 2008) MassifquantParam perform Kalman filter-based peak detection (Conley et al. 2014). Additional peak detection algorithms direct injection data also available, discussed . example use centWave algorithm performs peak detection two steps: first identifies regions interest m/z - retention time space subsequently detects peaks regions using continuous wavelet transform (see original publication details). algorithm can configured several parameters (see ?CentWaveParam), important peakwidth ppm. peakwidth defines minimal maximal expected width peak retention time dimension depends thus setup employed LC-MS system making parameter highly data set dependent. Appropriate values can estimated based extracted ion chromatograms e.g. internal standards known compounds data. thus extract chromatographic data serine perform peak detection data subset using findChromPeaks default parameters centWave. default settings centWave, findChromPeaks failed detect chromatographic peak data. default values shown . Particularly settings peakwidth fit data. default parameter expects chromatographic peaks 20 50 seconds wide. plot extracted ion chromatogram (XIC) serine can however see values large present data set (see ). Extracted ion chromatogram serine. fact, serine signal seems measured around 5 seconds. thus next adapt settings accommodate peaks ranging 2 10 seconds re-run peak detection. general, advised investigate peak widths several ions data set determine appropriate peakwidth setting. addition, select different peak boundary estimation algorithm setting integrate = 2. works particularly well non-gaussian peak shapes ensures also signal peak’s tail integrated (eventually re-run code default integrate = 1 compare two approaches). XIC Serine detected chromatographic peak data set-specific peakwidth able detect peak serine (highlighted grey plot ). can now use chromPeaks function extract information identified chromatographic peaks object. result returned matrix retention time m/z range peak (\"rtmin\", \"rtmax\", \"mzmin\" \"mzmax\") well integrated peak area (\"\"), maximal signal (\"maxo\") signal noise ratio (\"sn\"). Another important parameter centWave ppm used initial identification regions interest. contrast random noise, real signal ion expected yield stable m/z values consecutive scans (scattering m/z values around real m/z value ion supposed inversely related intensity - least TOF instruments). centWave, peaks m/z values differ less ppm consecutive spectra combined region interest (ROI) subjected CWT-based peak detection. illustrate , plot full MS data data subset containing signal serine.  can observe scattering data points m/z dimension (lower panel plot ), decreases increasing intensity signal. next calculate differences m/z values consecutive scans data subset. one representative file, selecting one highest total sum intensities selected region. calculate total intensity summing intensities spectra within region two files (first sum intensities returned intensity sums intensities within spectrum, second sum sums values result total sum). next extract spectra sample highest intensity evaluate number peaks ’ve got m/z - retention time range data subset. spectra one peak MS data subset. next select peak highest intensity. can make use powerful infrastructure Spectra package, allows apply user-provided function peak matrix spectrum. thus next define simple function takes peak matrix input, subsets one row (.e. peak) highest intensity returns single-row (peak) matrix . can now apply function data using addProcessing function. user provided function take peak matrix first argument return peak matrix can passed addProcessing function. Note also function ... parameter function definition (even additional parameters passed along). See also ?addProcessing information. apply function extracted spectra determine number peaks processing. indeed now single peak per spectrum. next extract m/z values peaks calculate difference m/z values consecutive scans (spectra). can also express differences ppm (parts per million) average m/z peaks. difference m/z values serine data thus 0 27 ppm. ideally evaluated several compounds set value allows capture full chromatographic peaks tested compounds. can next perform peak detection using settings ppm peakwidth parameters. findChromPeaks call adds results chromatographic peak detection data set (now represented XcmsExperiment object directly extends MsExperiment hence inherits functionality). results peak detection analysis can accessed chromPeaks function. optional parameters rt mz allow addition extract peak detection results specific m/z - retention time region: identified peak m/z rt value apex reported (columns \"mz\" \"rt\") well ranges (\"mzmin\", \"mzmax\", \"rtmin\", \"rtmax\"), integrated signal peak (.e. peak area \"\"), maximal signal peak (\"maxo\"), signal noise ratio (\"sn\") index sample peak detected (\"sample\"). Note peak detection, extracted ion chromatogram data also contain identified chromatographic peaks. extract EIC Serine display identified peaks compound. plotting extracted ion chromatogram also show identified chromatographic peak(s).  thus provides convenient way evaluate peak detection results sets m/z - retention time regions potential known compounds. Similarly, peak detection results visualized generic plot result object (chromatogrphic peaks highlighed red rectangle; see ).  Peak detection always work perfectly leading peak detection artifacts, overlapping peaks artificially split peaks. refineChromPeaks function allows refine peak detection results either removing peaks meeting predefined properties merging artificially split chromatographic peaks (see ?refineChromPeaks options). post-process peak detection results merging peaks (within sample) overlap 4 second window signal lower 75% smaller peak’s largest intensity. See MergeNeighboringPeaksParam help page detailed description settings approach. Merged peaks can identified TRUE \"merged\" chromatographic peak metadata column can extracted chromPeakData function (see ). example joined (merged) peak given . Result peak refinement. Left: peaks merging, right merging. signal rather wide noise centWave thus able integrate whole peak even defined partially overlapping chromatographic peaks (left image ). Peak refinement merged consecutive peaks signal never dropped 75% smallest chromatographic peak’s intensity. last replace data variable object containing also peak refinement results. quality assessment now calculate summary statistics identified peaks e.g. identify samples much less detected peaks. Also, can use plotChromPeaks function provide general information location identified chromatographic peaks m/z - rt space. Location identified chromatographic peaks m/z - rt space.","code":"#' Get the XIC for serine in all files serine_chr <- chromatogram(data, rt = c(164, 200),                            mz = serine_mz + c(-0.05, 0.05),                            aggregationFun = \"max\")  #' Get default centWave parameters cwp <- CentWaveParam()  #' \"dry-run\" peak detection on the XIC. res <- findChromPeaks(serine_chr, param = cwp) chromPeaks(res) ##      rt rtmin rtmax into intb maxo sn row column cwp ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 25 ##  - peakwidth: [1] 20 50 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 1 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE plot(serine_chr) cwp <- CentWaveParam(peakwidth = c(2, 10), integrate = 2)  serine_chr <- findChromPeaks(serine_chr, param = cwp)  #' Plot the data and higlight identified peak area plot(serine_chr) chromPeaks(serine_chr) ##           rt   rtmin   rtmax     into     intb     maxo  sn row column ## [1,] 181.356 178.566 189.447 74443.95 71734.01 37664.94 110   1      1 ## [2,] 181.072 178.561 187.210 70352.22 69008.98 38517.76 224   1      2 #' Restrict the data to signal from Serine srn <- data |> filterRt(rt = c(179, 186)) |> filterMz(mz = c(106.04, 106.07))  #' Plot the data plot(srn) #' split the experiment by sample srn_sample <- split(srn, seq_along(srn))  #' apply a function to each experiment that #' - extracts the spectra for that sample #' - gets their intensities #' - sums these intensities per spectrum #' - finally sums these intensity sums across spectra int_sums <- vapply(srn_sample,                    function(z) sum(sum(intensity(spectra(z)))),                    numeric(1)) int_sums ##        1        2  ## 264511.6 251648.7 srn_sps <- spectra(srn[which.max(int_sums)])  #' get the number of peaks for each spectrum lengths(srn_sps) ##  [1] 1 2 1 1 1 1 1 2 2 2 2 1 2 1 2 2 2 1 1 1 2 2 2 2 2 #' function to select the row with the highest intensity and return that max_int <- function(x, ...) {     x[which.max(x[, \"intensity\"]), , drop = FALSE] } srn_sps <- addProcessing(srn_sps, max_int) lengths(srn_sps) ##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 mzs <- unlist(mz(srn_sps)) abs(diff(mzs)) ##           mz           mz           mz           mz           mz           mz  ## 1.452460e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00 1.684509e-05  ##           mz           mz           mz           mz           mz           mz  ## 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00 7.624200e-07  ##           mz           mz           mz           mz           mz           mz  ## 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00 1.425717e-03  ##           mz           mz           mz           mz           mz           mz  ## 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00 1.493783e-03 abs(diff(mzs)) * 1e6 / mean(mzs) ##           mz           mz           mz           mz           mz           mz  ## 13.695973646 27.391665930  1.112565444 13.695804399  0.000000000  0.158840806  ##           mz           mz           mz           mz           mz           mz  ##  0.000000000  0.000000000  0.682098923  0.000000000  0.000000000  0.007189239  ##           mz           mz           mz           mz           mz           mz  ## 13.695795336 13.695795336 12.807200180  0.000000000  0.000000000 13.443799681  ##           mz           mz           mz           mz           mz           mz  ##  0.000000000 13.695795190 13.957010392  0.000000000  0.000000000 14.085629933 #' Perform peak detection cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30, integrate = 2) data <- findChromPeaks(data, param = cwp) data ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 653 in MS level(s): 1 #' Access the peak detection results from a specific m/z - rt area chromPeaks(data, mz = c(106, 107), rt = c(150, 190)) ##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb ## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   510.5323 ## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73916.8683 ## CP475 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.2785 ## CP516 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70106.7152 ##             maxo  sn sample ## CP133   426.6084  38      1 ## CP167 37664.9371 688      1 ## CP475   381.6084  53      2 ## CP516 38517.7622 826      2 eic_serine <- chromatogram(data, mz = c(106.04, 106.06),                            rt = c(179, 186)) chromPeaks(eic_serine) ##             mz    mzmin    mzmax      rt   rtmin   rtmax     into     intb ## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.78 73916.87 ## CP516 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.61 70106.72 ##           maxo  sn sample row column ## CP167 37664.94 688      1   1      1 ## CP516 38517.76 826      2   1      2 plot(eic_serine) srn <- data |> filterRt(rt = c(175, 188)) |> filterMz(mz = c(106.04, 106.06))  plot(srn) mpp <- MergeNeighboringPeaksParam(expandRt = 4) data_pp <- refineChromPeaks(data, param = mpp) chromPeakData(data_pp) ## DataFrame with 595 rows and 3 columns ##        ms_level is_filled    merged ##       <integer> <logical> <logical> ## CP001         1     FALSE     FALSE ## CP002         1     FALSE     FALSE ## CP003         1     FALSE     FALSE ## CP004         1     FALSE     FALSE ## CP005         1     FALSE     FALSE ## ...         ...       ...       ... ## CP679         1     FALSE      TRUE ## CP680         1     FALSE      TRUE ## CP681         1     FALSE      TRUE ## CP682         1     FALSE      TRUE ## CP683         1     FALSE      TRUE mzr <- c(122.9, 122.97) rtr <- c(100, 150)  chr_1 <- chromatogram(data[1], mz = mzr, rt = rtr) chr_2 <- chromatogram(data_pp[1], mz = mzr, rt = rtr) par(mfrow = c(1, 2)) plot(chr_1) plot(chr_2) data <- data_pp par(mfrow = c(1, 2)) plotChromPeaks(data, 1) plotChromPeaks(data, 2)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"alignment","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms > Preprocessing of LC-MS data","what":"Alignment","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"chromatography helps discriminate better analytes also affected variances can lead shifts retention times measurement runs. alignment step aims adjust retention time differences samples within experiment. plot base peak chromatograms files data set visualize differences. Note peakType = \"none\" disable plotting identified chromatographic peaks drawn default chromatograms extracted object containing peak detection results. BPC files. samples measured setup day slight drifts signal visible. Alignment can performed xcms using adjustRtime function supports peakGroups (C. . Smith et al. 2006) obiwarp (Prince Marcotte 2006) method. settings algorithms can defined PeakGroupsParam ObiwarpParam parameter objects, respectively (see ?adjustRtime available alignment methods settings). Note also xcms supports subset-based alignment allows align large data set retention time drift estimated subset samples (ideally QC pooled samples repeatedly measured whole measurement run(s)). See xcms vignette information. example use peakGroups method aligns samples based retention times hook peaks (housekeeping peaks), represent signal ions expected present samples. define need however group detected chromatographic peaks across samples using initial correspondence analysis. use peakDensity method correspondence. Details method explanations choices parameters provided next section. performed initial correspondence analysis, perform alignment using settings minFraction = 1 span = 0.6. minFraction defines proportion samples candidate hook peak detected/present. value 0.9 example require chromatographic peak specific ion (.e. m/z - retention time) present (detected) 90% samples consider hook peak alignment. data represents replicated measurements sample pool can therefore require hook peaks present file. parameter span defines degree smoothing loess function used allow different regions along retention time axis adjusted different factor. value 0 likely cause overfitting, 1 perform constant, linear shift. Values 0.4 0.6 seem reasonable experiments. Adjusted retention times stored, along raw retention times, within result object. function accessing retention times (rtime) default return adjusted retention times XcmsExperiment object, present. Note also retention times identified chromatographic peaks adjusted adjustRtime call. alignment suggested evaluate alignment results e.g. inspecting differences raw adjusted retention times. Alignment results. Shown difference raw adjusted retention times hook peaks used alignment (shown points). difference raw adjusted retention time reasonable. example mostly one second, OK since samples measured within short time period differences thus expected small. Also, hook peaks ideally present along full retention time range allow proper estimation drifts along full time measurement. Next plot base peak chromatograms alignment. Note chromatogram call always include detected chromatographic peaks requested rt range base peak chromatogram don’t need information. chromPeaks = \"none\" chromatogram call tell function include identified chromatographic peaks returned chromatographic data. BPC (top) (bottom) alignment. base peak chromatograms nicely aligned retention time adjustment. impact alignment also evaluated known compounds internal standards. thus plot XIC serine alignment. get raw retention times hence able extract ion chromatogram serine alignment drop alignment results can done dropAdjustedRtime function. function restore retention times spectra (chromatographic peaks) alignment. can thus extract next ion chromatogram serine raw data well alignment. XIC Serine (left) (right) alignment Serine peaks also nicely aligned adjustment.","code":"#' Extract base peak chromatograms bpc_raw <- chromatogram(data, aggregationFun = \"max\") plot(bpc_raw, peakType = \"none\") #' Define the settings for the initial peak grouping - details for #' choices in the next section. pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 1, binSize = 0.02) data <- groupChromPeaks(data, pdp)  #' Define settings for the alignment pgp <- PeakGroupsParam(minFraction = 1, span = 0.6) data <- adjustRtime(data, param = pgp) #' Plot the difference between raw and adjusted retention times plotAdjustedRtime(data) par(mfrow = c(2, 1)) #' Plot the raw base peak chromatogram plot(bpc_raw, peakType = \"none\") #' Plot the BPC after alignment plot(chromatogram(data, aggregationFun = \"max\", chromPeaks = \"none\")) data_raw <- dropAdjustedRtime(data) #' Use adjustedRtime parameter to access raw/adjusted retention times par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5)) chromatogram(data_raw, mz = c(106.04, 106.06), rt = c(179, 186)) |> plot() chromatogram(data, mz = c(106.04, 106.06), rt = c(179, 186)) |> plot()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"correspondence","dir":"Articles","previous_headings":"Workflow: exploring and analyzing LC-MS data with Spectra and xcms > Preprocessing of LC-MS data","what":"Correspondence","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"final step LC-MS preprocessing xcms correspondence analysis, chromatographic peaks types ions (compounds) grouped across samples form called LC-MS feature. xcms implements two methods purpose: peak density (C. . Smith et al. 2006) nearest (Katajamaa, Miettinen, Oresic 2006) can configured passing either PeakDensityParam NearestPeaksParam object groupChromPeaks function (see ?groupChromPeaks information). example use peak density method iterates m/z slices data groups chromatographic peaks features slice (within across samples) depending retention time distribution chromatographic peaks along retention time axis. Peaks representing signal ion expected similar retention time , found many samples, also reflected higher peak density respective retention time (since retention times compound expected similar different samples). illustrate extract m/z slice containing serine peak use plotChromPeakDensity function visualize distribution peaks along retention time axis simulate correspondence analysis based provided settings. BPC m/z slice defined features within slice based default settings. upper panel plot shows chromatographic data identified peaks. lower panel shows retention time identified peaks (x-axis) per sample (y-axis) black solid line representing distribution (density) along x-axis. Peak groups (features) indicated grey rectangles lower panel. peak density correspondence method groups chromatographic peaks density peak one feature. default settings able group serine peak sample one feature. parameters peak density correspondence analysis : binSize: m/z width bin/slice data peaks grouped. bw defines smoothness density function. maxFeatures: maximum number features defined one bin. minFraction: minimum proportion samples (one group!) peak present. minSamples: minimum number samples peak present. parameters minFraction minSamples depend experimental layout set accordingly. binSize set small enough value avoid peaks different ions, similar m/z retention time, grouped together. important parameter however bw , default value 30 able correctly group Serine peaks, always evaluated , complicated, signals . evaluate performance default parameters m/z slice contains signal multiple ions m/z, including isomers betaine valine ([M+H]+ m/z 118.08625). Correspondence analysis default settings m/z slice containing signal multiple ions. default settings chromatographic peaks present m/z slice grouped one feature. Signal different ions thus treated single entity. repeat analysis strongly reduced value bw. Correspondence analysis reduced bw setting m/z slice containing signal multiple ions. Using value 1.8 parameter bw, successfully grouped peaks different features. can now use settings correspondence analysis full data set. Next evaluate results correspondence analysis different m/z slice containing isomers leucine isoleucine ([M+H]+ m/z 132.10191). Setting simulate = FALSE plotChromPeakDensity show actual results correspondence analysis. Result correspondence slice containing isomers Leucine Isoleucine. Despite close, chromatographic peaks isomers successfully grouped separate features. Results correspondence analysis can accessed featureDefinition function. function returns data frame retention time m/z ranges apex positions peaks assigned feature respective indices chromPeaks matrix. Note EIC chr also contain correspondence results selected m/z range also accessed featureDefinitions(chr). Also, can calculate simple per-feature summary statistic featureSummary function. function reports feature total number percentage samples peak detected total numbers percentage samples one peak assigned feature. final result LC-MS data preprocessing matrix feature abundances, rows features, columns samples. matrix can extracted featureValues function result object (see alternative, preferred way extract preprocessing results quantify method). function takes two additional parameters value method: value defines column chromPeaks table reported matrix, method approach handle cases one peak sample assigned feature. set value = \"\" (default) extract total integrated peak area method = \"maxint\" report peak area peak largest intensity features multiple peaks sample. abundances reported features, might also missing values , like feature FT002 second sample . NAs occur chromatographic peak assigned feature, either peak detection failed, corresponding ion absent respective sample. One possibility deal missing values data imputation. fillChromPeaks function, xcms provides however alternative approach integrates signal measured m/z - retention time region feature original files samples NA reported hence filling-missing peak data. Different approaches gap-filling available (see ?fillChromPeals), method selected configured ChromPeakAreaParam preferred one: approach defines region signal integrated based m/z rt range identified chromatographic peaks feature. perform gap-filling ChromPeakAreaParam approach. fillChromPeaks thus rescue signal 23 features missing values. Note filled-peak information can also removed time dropFilledChromPeaks function. Also, setting filled = FALSE featureValues function return data detected peaks. Note also , addition featureValues method simply extracts feature matrix, preprocessing results can also converted SummarizedExperiment , besides containing feature quantification, stores also phenotype data (sample descriptions) feature definitions. use quantify method extract preprocessing results SummarizedExperiment. function takes parameter featureValues function additional arguments, thus, call extract values (detected gap-filled peaks) sum signals chromatographic peaks assigned feature sample. SummarizedExperiment main data object Bioconductor store quantified omics data hence ideal container LC-MS data preprocessing results. column annotations can accessed colData, feature definitions (row annotations) rowData: quantified feature abundances can accessed assay method providing second argument name assay matrix extract: SummarizedExperiment supports several assay matrices (long dimensions). can thus add example feature quantification excluding filled-signal additional assay matrix: now two assay matrices result object: Analogously add normalized data object processed values. advantage data within one object obvious: subsetting data ensures assays annotations subsetted correctly. One final thing worth mentioning xcms result objects keep, next preprocessing results, also history processing steps parameter objects used analysis. process history can accessed processHistory function. actual parameter object used configure one particular analysis step can accessed processParam: information also stored metadata slot SummarizedExperiment: Analysis now proceed e.g. normalizing data remove technical variances feature abundances, feature grouping (compounding) using MsFeatures package, differential abundance analysis ultimately also annotation identification LC-MS features (e.g. help MetaboAnnotation package (Rainer et al. 2022)).","code":"#' Get default parameters for the grouping pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group)  #' Extract a BPC for the m/z slice containing serine bpc_serine <- chromatogram(data, mz = c(106.04, 106.06),                            aggregationFun = \"max\")  #' Dry-run correspondence and show the results. plotChromPeakDensity(bpc_serine, param = pdp) #' Plot the chromatogram for an m/z slice containing Betaine and Valine mzr <- 118.08625 + c(-0.01, 0.01) chr <- chromatogram(data, mz = mzr, aggregationFun = \"max\")  #' Correspondence in that slice using default settings pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group) plotChromPeakDensity(chr, param = pdp) #' Reducing the bandwidth pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8) plotChromPeakDensity(chr, param = pdp) pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 0.4, binSize = 0.02)  #' Perform the correspondence analysis data <- groupChromPeaks(data, param = pdp) #' Plot the results for an m/z slice containing Leucine and Isoleucine mzr <- 132.10191 + c(-0.01, 0.01) chr <- chromatogram(data, mz = mzr, aggregationFun = \"max\") plotChromPeakDensity(chr, simulate = FALSE) #' Definition of the features featureDefinitions(data) |> head() ##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL ## FT001 105.0418 105.0417 105.0418 167.68597 167.48455 167.88740      2    2 ## FT002 105.0415 105.0415 105.0415 157.71871 157.71871 157.71871      1    1 ## FT003 105.0697 105.0691 105.0703  31.80794  31.68918  31.92670      2    2 ## FT004 105.1103 105.1100 105.1105  63.75047  63.35239  64.14855      2    2 ## FT005 105.4734 105.4732 105.4736 201.57593 201.36133 201.79053      2    2 ## FT006 105.7166 105.7160 105.7172 181.21578 181.08901 181.34256      2    2 ##        peakidx ms_level ## FT001 112, 396        1 ## FT002      111        1 ## FT003  19, 317        1 ## FT004  48, 348        1 ## FT005 260, 580        1 ## FT006 135, 444        1 #' Per-feature summary. featureSummary(data) |> head() ##       count perc multi_count multi_perc        rsd ## FT001     2  100           0          0 0.23642129 ## FT002     1   50           0          0         NA ## FT003     2  100           0          0 0.24525296 ## FT004     2  100           0          0 0.04687951 ## FT005     2  100           0          0 0.22330558 ## FT006     2  100           0          0 0.05904323 #' feature intensity matrix fmat <- featureValues(data, value = \"into\", method = \"maxint\") head(fmat) ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                               NA ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545 #' Number of missing values sum(is.na(fmat)) ## [1] 135 data <- fillChromPeaks(data, param = ChromPeakAreaParam())  #' How many missing values after sum(is.na(featureValues(data))) ## [1] 28 fmat_fld <- featureValues(data, value = \"into\", method = \"maxint\") head(fmat_fld) ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                        3183.9546 ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545 library(SummarizedExperiment) res <- quantify(data, method = \"sum\", value = \"into\") colData(res) ## DataFrame with 2 rows and 5 columns ##                                           file injection_idx      sample ##                                    <character>     <numeric> <character> ## 20171016_POOL_POS_1_105-134.mzML 20171016_P...             1      POOL_1 ## 20171016_POOL_POS_3_105-134.mzML 20171016_P...            19      POOL_2 ##                                        group spectraOrigin ##                                  <character>   <character> ## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT... ## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT... rowData(res) ## DataFrame with 361 rows and 9 columns ##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks ##       <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> ## FT001   105.042   105.042   105.042  167.6860  167.4845  167.8874         2 ## FT002   105.042   105.042   105.042  157.7187  157.7187  157.7187         1 ## FT003   105.070   105.069   105.070   31.8079   31.6892   31.9267         2 ## FT004   105.110   105.110   105.111   63.7505   63.3524   64.1486         2 ## FT005   105.473   105.473   105.474  201.5759  201.3613  201.7905         2 ## ...         ...       ...       ...       ...       ...       ...       ... ## FT357   133.928   133.928   133.928  198.5823  198.5823  198.5823         1 ## FT358   133.960   133.960   133.961   30.8309   30.8063   30.8554         2 ## FT359   133.956   133.956   133.956  199.0661  198.9950  199.1372         2 ## FT360   133.973   133.973   133.973  206.8712  206.3899  207.3524         2 ## FT361   133.973   133.973   133.973  200.2484  200.2484  200.2484         1 ##            POOL  ms_level ##       <numeric> <integer> ## FT001         2         1 ## FT002         1         1 ## FT003         2         1 ## FT004         2         1 ## FT005         2         1 ## ...         ...       ... ## FT357         1         1 ## FT358         2         1 ## FT359         2         1 ## FT360         2         1 ## FT361         1         1 head(assay(res, \"raw\")) ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                        3183.9546 ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545 assays(res)$raw_detected <- featureValues(data, method = \"sum\",                                           value = \"into\", filled = FALSE) assayNames(res) ## [1] \"raw\"          \"raw_detected\" #' Overview of the performed processings processHistory(data) ## [[1]] ## Object of class \"XProcessHistory\" ##  type: Peak detection  ##  date: Tue May 30 11:15:12 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: CentWaveParam  ##  MS level(s) 1  ##  ## [[2]] ## Object of class \"XProcessHistory\" ##  type: Peak refinement  ##  date: Tue May 30 11:15:14 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: MergeNeighboringPeaksParam  ##  MS level(s) 1  ##  ## [[3]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue May 30 11:15:19 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[4]] ## Object of class \"XProcessHistory\" ##  type: Retention time correction  ##  date: Tue May 30 11:15:19 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakGroupsParam  ##  MS level(s) 1  ##  ## [[5]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue May 30 11:15:26 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[6]] ## Object of class \"XProcessHistory\" ##  type: Missing peak filling  ##  date: Tue May 30 11:15:28 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: ChromPeakAreaParam  ##  MS level(s) 1 #' Access the parameter class for a processing step processParam(processHistory(data)[[1]]) ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 30 ##  - peakwidth: [1]  2 10 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 2 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE metadata(res) ## [[1]] ## Object of class \"XProcessHistory\" ##  type: Peak detection  ##  date: Tue May 30 11:15:12 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: CentWaveParam  ##  MS level(s) 1  ##  ## [[2]] ## Object of class \"XProcessHistory\" ##  type: Peak refinement  ##  date: Tue May 30 11:15:14 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: MergeNeighboringPeaksParam  ##  MS level(s) 1  ##  ## [[3]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue May 30 11:15:19 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[4]] ## Object of class \"XProcessHistory\" ##  type: Retention time correction  ##  date: Tue May 30 11:15:19 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakGroupsParam  ##  MS level(s) 1  ##  ## [[5]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue May 30 11:15:26 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[6]] ## Object of class \"XProcessHistory\" ##  type: Missing peak filling  ##  date: Tue May 30 11:15:28 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: ChromPeakAreaParam  ##  MS level(s) 1"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"bonus-material---peak-detection-fun","dir":"Articles","previous_headings":"","what":"Bonus material - peak detection fun","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"section apply lessons learned previous sections, particular adapt peak detection setting rather noisy chromatographic data. load example data text file. data two columns, one retention times one intensities. can now create Chromatogram object plot data.  two peaks present data, signal latter particularly noisy. goal now perform peak detection identify two peaks. first try default settings centWave clearly shows tune parameters (note setting sn = 0 required present data set enough background data points algorithm estimate noise level properly). parameter now adapt data? choices? Go ahead try different settings setting combination see can succeed detecting two peaks. Eventually might even try different peak detection algorithm (e.g. MatchedFilterParam).  default parameters centWave clearly failed identify two large peaks, defining smaller fragments potential peaks. Especially second peak peculiar tri-forked shape seems cause troubles. even hydrophilic liquid interaction chromatography (HILIC), known potentially result noisy odd-shaped peaks, rather unusual peak shape. fact, signal analyzing chromatographic origin:  example data represents panorama picture featuring mountains Dolomites, Paternkofel (left peak, colored red) famous Drei Zinnen (right tri-forked peak colored green).","code":"data <- read.table(     system.file(\"txt\", \"chromatogram.txt\", package = \"xcmsTutorials\"),     sep = \"\\t\", header = TRUE) head(data) ##    rt intensity ## 1 100         0 ## 2 110         0 ## 3 120         1 ## 4 130         2 ## 5 140         4 ## 6 150         6 chr <- Chromatogram(rtime = data$rt, intensity = data$intensity) par(mar = c(2, 2, 0, 0)) plot(chr) xchr <- findChromPeaks(chr, param = CentWaveParam(sn = 0)) par(mar = c(2, 2, 0, 0)) plot(xchr)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Exploring and Analyzing LC-MS data with *Spectra* and *xcms*","text":"","code":"sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] RColorBrewer_1.1-3          png_0.1-8                   ##  [3] SummarizedExperiment_1.30.1 GenomicRanges_1.52.0        ##  [5] GenomeInfoDb_1.36.0         IRanges_2.34.0              ##  [7] MatrixGenerics_1.12.0       matrixStats_0.63.0          ##  [9] MetaboCoreUtils_1.8.0       Spectra_1.11.2              ## [11] MsExperiment_1.2.0          xcms_3.99.3                 ## [13] MSnbase_2.25.2              ProtGenerics_1.32.0         ## [15] S4Vectors_0.38.1            mzR_2.35.1                  ## [17] Rcpp_1.0.10                 Biobase_2.60.0              ## [19] BiocGenerics_0.46.0         BiocParallel_1.34.2         ## [21] rmarkdown_2.21              knitr_1.43                  ## [23] BiocStyle_2.28.0            ##  ## loaded via a namespace (and not attached): ##  [1] bitops_1.0-7                rlang_1.1.1                 ##  [3] magrittr_2.0.3              clue_0.3-64                 ##  [5] MassSpecWavelet_1.66.0      compiler_4.3.0              ##  [7] systemfonts_1.0.4           vctrs_0.6.2                 ##  [9] stringr_1.5.0               pkgconfig_2.0.3             ## [11] crayon_1.5.2                fastmap_1.1.1               ## [13] XVector_0.40.0              utf8_1.2.3                  ## [15] preprocessCore_1.62.1       ragg_1.2.5                  ## [17] purrr_1.0.1                 MultiAssayExperiment_1.26.0 ## [19] xfun_0.39                   zlibbioc_1.46.0             ## [21] cachem_1.0.8                jsonlite_1.8.4              ## [23] progress_1.2.2              highr_0.10                  ## [25] DelayedArray_0.26.3         prettyunits_1.1.1           ## [27] parallel_4.3.0              cluster_2.1.4               ## [29] R6_2.5.1                    bslib_0.4.2                 ## [31] stringi_1.7.12              limma_3.56.1                ## [33] jquerylib_0.1.4             bookdown_0.34               ## [35] iterators_1.0.14            igraph_1.4.3                ## [37] Matrix_1.5-4.1              splines_4.3.0               ## [39] tidyselect_1.2.0            yaml_2.3.7                  ## [41] doParallel_1.0.17           codetools_0.2-19            ## [43] affy_1.78.0                 lattice_0.21-8              ## [45] tibble_3.2.1                plyr_1.8.8                  ## [47] evaluate_0.21               desc_1.4.2                  ## [49] survival_3.5-5              pillar_1.9.0                ## [51] affyio_1.70.0               BiocManager_1.30.20         ## [53] foreach_1.5.2               MALDIquant_1.22.1           ## [55] ncdf4_1.21                  generics_0.1.3              ## [57] rprojroot_2.0.3             RCurl_1.98-1.12             ## [59] hms_1.1.3                   ggplot2_3.4.2               ## [61] munsell_0.5.0               scales_1.2.1                ## [63] glue_1.6.2                  lazyeval_0.2.2              ## [65] MsFeatures_1.8.0            tools_4.3.0                 ## [67] mzID_1.38.0                 robustbase_0.95-1           ## [69] QFeatures_1.10.0            vsn_3.68.0                  ## [71] RANN_2.6.1                  fs_1.6.2                    ## [73] XML_3.99-0.14               grid_4.3.0                  ## [75] impute_1.74.1               MsCoreUtils_1.12.0          ## [77] colorspace_2.1-0            GenomeInfoDbData_1.2.10     ## [79] cli_3.6.1                   textshaping_0.3.6           ## [81] fansi_1.0.4                 S4Arrays_1.0.4              ## [83] dplyr_1.1.2                 AnnotationFilter_1.24.0     ## [85] pcaMethods_1.92.0           gtable_0.3.3                ## [87] DEoptimR_1.0-13             sass_0.4.6                  ## [89] digest_0.6.31               memoise_2.0.1               ## [91] htmltools_0.5.5             pkgdown_2.0.7.9000          ## [93] multtest_2.56.0             lifecycle_1.0.3             ## [95] MASS_7.3-60"},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Rainer. Author, maintainer.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J (2023). xcmsTutorials: Exploring Analyzing LC-MS data Spectra xcms. R package version 0.1.0, https://jorainer.github.io/xcmsTutorials/.","code":"@Manual{,   title = {xcmsTutorials: Exploring and Analyzing LC-MS data with Spectra and xcms},   author = {Johannes Rainer},   year = {2023},   note = {R package version 0.1.0},   url = {https://jorainer.github.io/xcmsTutorials/}, }"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"exploring-and-analyzing-lc-ms-data-with-spectra-and-xcms","dir":"","previous_headings":"","what":"Exploring and Analyzing LC-MS data with Spectra and xcms","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workshop provides overview recent developments Bioconductor work mass spectrometry (MsExperiment, Spectra) specifically LC-MS data (xcms) walks preprocessing small data set emphasizing selection data-dependent settings individual pre-processing steps. present workshop represents updated version workshop given Metabolomics Society conference 2018 Seattle (http://metabolomics2018.org). Covered topics : - Data import representation. - Accessing, subsetting visualizing data. - Centroiding profile MS data. - Chromatographic peak detection. - Empirically determine appropriate settings analyzed data set. - Evaluation identified peaks. - Alignment (retention time correction). - Correspondence (grouping chromatographic peaks across samples). full R code examples along comprehensive descriptions provided xcms-preprocessing.Rmd file. file can opened e.g. RStudio allows execution individual R commands (see section additionally required R packages). R command rmarkdown::render(\"xcms-preprocessing.Rmd\") generate html file xcms-preprocessing.html.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"analysis document requires R version >= 4.3.0 recent versions MsExperiment, Spectra particular xcms (version >= 3.99.0 needed) packages. Alternatively, individual packages used tutorial can installed using code . source code document along test data can downloaded github repository https://github.com/jorainer/xcmsTutorials command (alternatively downloading zip archive directly github page).","code":"install.packages(\"BiocManager\") BiocManager::install(\"jorainer/xcmsTutorials\",     dependencies = TRUE, ask = FALSE, update = TRUE) #' Install the Bioconductor package manager install.packages(\"BiocManager\")  #' Install the required packages BiocManager::install(c(\"msdata\",                        \"Spectra\",                        \"MsExperiment\",                        \"MetaboCoreUtils\",                        \"MsCoreUtils\",                        \"png\")) BiocManager::install(\"sneumann/xcms\") git clone https://github.com/jorainer/xcmsTutorials"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"additional-documentation-resources-and-tutorials","dir":"","previous_headings":"","what":"Additional documentation resources and tutorials","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Tutorial additional examples explanations MS2-based annotations: https://jorainer.github.io/SpectraTutorials/ Repository MsCoreUtils package: https://rformassspectrometry.github.io/MsCoreUtils/ Repository MetaboCoreUtils package: https://rformassspectrometry.github.io/MetaboCoreUtils/ Repository Spectra package: https://rformassspectrometry.github.io/Spectra/ Repository MetaboAnnotation package: https://rformassspectrometry.github.io/MetaboAnnotation/ Repository CompoundDb package: https://rformassspectrometry.github.io/CompoundDb/","code":""},{"path":[]}]
