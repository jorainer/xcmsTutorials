[{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"document discuss liquid chromatography (LC) mass spectrometry (MS) data handling exploration using MsExperiment r Biocpkg(\"Spectra\") Bioconductor packages perform preprocessing small LC-MS data set using xcms package (Louail et al. 2025). Functionality MetaboCoreUtils MsCoreUtils packages used general tasks frequently performed metabolomics data analysis. Ultimately, functionality packages can combined build custom, data set-specific (reproducible) analysis workflows. present workshop, first focus data import, access visualization followed description simple data centroiding approach finally present xcms-based LC-MS data preprocessing comprises chromatographic peak detection, alignment correspondence. Data normalization procedures, compound identification differential abundance analysis covered . Particular emphasis given deriving defining data set-dependent values critical xcms preprocessing parameters.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Preprocessing first step analysis untargeted LC-MS gas chromatography (GC)-MS data. aim preprocessing quantification signals ions measured sample, adjusting potential retention time drifts samples followed matching quantified signal across samples within experiment. resulting two-dimensional matrix abundances called LC-MS features samples can processed, e.g. normalizing data remove differences due sample processing, batch effects injection order-dependent signal drifts. LC-MS features usually characterized mass--charge ratio (m/z) retention time hence need annotated actual ions metabolites represent. Data normalization annotation covered tutorial links related tutorials workshops provided end document.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"mass-spectrometry","dir":"Articles","previous_headings":"Introduction","what":"Mass spectrometry","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Mass spectrometry allows measure abundances charged molecules (ions) sample. Abundances determined ion counts specific mass--charge ratio m/z. measured signal represented spectrum: intensities along m/z.  Many ions result, measured MS alone, similar m/z. Thus, making difficult impossible discriminate . MS therefore frequently coupled second technology separate ions prior quantification based properties mass (e.g. based polarity). Common choices gas chromatography (GC) liquid chromatography (LC). typical LC-MS setup sample gets injected system, molecules sample separated LC column, get ionized measured (discrete time points) MS instrument (see Figure simple visualization). Molecules get thus separated two different dimensions, retention time dimension (LC) mass--charge dimension (MS) making easier measure identify molecules complex samples.  GC/LC-MS based untargeted metabolomics experiments, data analyzed along retention time dimension chromatographic peaks (supposed represent signal ions certain type molecule) quantified.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"goals-of-this-workshop","dir":"Articles","previous_headings":"Introduction","what":"Goals of this workshop","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Learn R/xcms packages RforMassSpectrometry initiative can used inspect, evaluate analyze LC-MS data. Learn basis build reproducible analysis workflows, tailored customized individual data sets.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"definitions-and-common-naming-convention","dir":"Articles","previous_headings":"Introduction","what":"Definitions and common naming convention","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Naming conventions terms used document : chromatographic peak: peak containing signal ion retention time dimension (different mass peak represents signal along m/z dimension within spectrum). chromatographic peak detection: process chromatographic peaks identified within sample (file). alignment: process adjusts retention time differences (.e. possible signal drifts LC) measurements/samples. correspondence: grouping chromatographic peaks (presumably ion) across samples/files LC-MS features. feature (LC-MS features): entity representing signal type ion/molecule, characterized specific retention time m/z. xcms, features represent identified chromatographic peaks grouped across samples/files.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-import-and-exploration","dir":"Articles","previous_headings":"","what":"Data import and exploration","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"example data set workflow consists two files mzML format signals pooled human serum samples measured ultra high performance liquid chromatography (UHPLC) system (Agilent 1290) coupled Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument. Chromatographic separation based hydrophilic interaction liquid chromatography (HILIC) separating metabolites depending polarity. input files contain signals measured MS instrument (called profile mode data). reduce file sizes, data set restricted m/z range 105 134 retention times 0 260 seconds. QC pool samples taken larger experiment injected measurement run different time points (injected position 1 19 measurement run). code block first load required libraries define location mzML files, distributed msdata R package. also define data.frame names mzML files, arbitrary sample name, index respective sample measured within LC-MS run sample group samples. generally suggested provide experiment-relevant phenotypic technical information data frame. Also, data frame defined xls sheet imported read_xlsx function readxl R package. data frame passed, along file names, readMsExperiment() call import data. MS data experiment now represented MsExperiment object.","code":"#' Load required libraries library(xcms) library(MsExperiment) library(Spectra)  #' Define the file names. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)  #' Define a data.frame with additional information on these files. pd <- data.frame(file = basename(fls),                  sample = c(\"POOL_1\", \"POOL_2\"),                  injection_index = c(1, 19),                  group = \"POOL\")  #' Import the data of the experiment mse <- readMsExperiment(fls, sampleData = pd) mse ## Object of class MsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s)."},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"basic-data-access","dir":"Articles","previous_headings":"Data import and exploration","what":"Basic data access","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"MsExperiment object manages linkage samples spectra. length() MsExperiment defined number samples (files) within object. Subset MsExperiment restrict () data within object selected sample(s). restrict data second sample use: subset full data, including sample information spectra data second file. Phenotype information can retrieved sampleData() function MsExperiment object. MS data stored Spectra object within MsExperiment can accessed using spectra() function. version 4 , xcms supports modern flexible infrastructure MS data analysis provided Spectra package. still possible use xcms together MSnbase package, users advised switch newer infrastructure provides flexibility higher performance. Also, additional packages MsBackendRawFileReader, new infrastructure allow import MS data also files mzML, mzXML CDF files. next examples briefly explain Spectra object illustrate use objects using simple examples. information Spectra objects can found package’s documentation SpectraTutorials. Spectra object contains full MS data experiment. ’s length thus equal total number spectra within experiment. determine number example data set. avoid nested function calls hence improve readability code, use R pipe operator |> allows concatenate consecutive calls readable fashion. Spectra object agnostic sample information, simply contains spectra experiment, first spectra first file, followed spectra second. mapping spectra samples defined MsExperiment object. access spectra specific sample either subset MsExperiment particular sample (done example ) use spectraSampleIndex() function returns spectrum index file within MsExperiment belongs. use spectraSampleIndex() determine total number spectra per sample. basic data summaries can helpful first initial quality assessment identify potentially problematic data files e.g. unexpected low number spectra. Besides peak data (m/z intensity values) also additional spectra variables (metadata) available Spectra object. can listed using spectraVariables() function call example MS data . Thus, spectra general information MS level (\"msLevel\") retention time (\"rtime\") available. spectra variables dedicated accessor functions available (msLevel, rtime). addition possible access variable using $ name variable (similar accessing columns data.frame). example extract msLevel spectra variable use table() function result get overview number spectra different MS levels available object. present data set contains thus 1,862 spectra, MS level 1. also check number peaks per spectrum different data files. number peaks per spectrum can extracted lengths() function. extract values, split file calculate quartiles peak counts using quantile() function. Thus, present data set, number spectra also average number peaks per spectra comparable. Individual MS spectra can accessed subsetting Spectra object returned spectra(). example subset data second sample, extract spectra sample subset spectrum number 123. m/z intensity values can extracted Spectra using mz() intensity() functions (always) return list numeric vectors respective values: alternative, peaksData() function used extract m/z intensity values (two-column numeric matrix) single function call. total ion signal spectrum calculated simply summing intensities peaks spectrum. perform operation spectrum extracted . operation can also applied full data set. example calculate total ion signal spectrum first file determine distribution using quantile() function. repeat operation second file. total ion signals two data files (expected) similar. Spectra object thus possibility inspect explore (raw) MS data experiment use functionality create quality assessment functions. Alternatively, also MsQuality package (Naake et al. 2023) used calculate core MS quality metrics full experiment (MsExperiment) individual data files (Spectra).","code":"#' Number of samples length(mse) ## [1] 2 #' Subset the data mse_2 <- mse[2] mse_2 ## Object of class MsExperiment  ##  Spectra: MS1 (931)  ##  Experiment data: 1 sample(s) ##  Sample data links: ##   - spectra: 1 sample(s) to 931 element(s). #' Extract sample information sampleData(mse_2) ## DataFrame with 1 row and 5 columns ##                                           file      sample injection_index ##                                    <character> <character>       <numeric> ## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19 ##                                        group spectraOrigin ##                                  <character>   <character> ## 20171016_POOL_POS_3_105-134.mzML        POOL /usr/local... #' Access the MS data spectra(mse) ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 34 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML #' Get the total number of spectra spectra(mse) |>     length() ## [1] 1862 #' Get the number of spectra per file. spectraSampleIndex(mse) |>     table() ##  ##   1   2  ## 931 931 #' List available spectra variables spectra(mse) |>     spectraVariables() ##  [1] \"msLevel\"                  \"rtime\"                    ##  [3] \"acquisitionNum\"           \"scanIndex\"                ##  [5] \"dataStorage\"              \"dataOrigin\"               ##  [7] \"centroided\"               \"smoothed\"                 ##  [9] \"polarity\"                 \"precScanNum\"              ## [11] \"precursorMz\"              \"precursorIntensity\"       ## [13] \"precursorCharge\"          \"collisionEnergy\"          ## [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  ## [17] \"isolationWindowUpperMz\"   \"peaksCount\"               ## [19] \"totIonCurrent\"            \"basePeakMZ\"               ## [21] \"basePeakIntensity\"        \"electronBeamEnergy\"       ## [23] \"ionisationEnergy\"         \"lowMZ\"                    ## [25] \"highMZ\"                   \"mergedScan\"               ## [27] \"mergedResultScanNum\"      \"mergedResultStartScanNum\" ## [29] \"mergedResultEndScanNum\"   \"injectionTime\"            ## [31] \"filterString\"             \"spectrumId\"               ## [33] \"ionMobilityDriftTime\"     \"scanWindowLowerLimit\"     ## [35] \"scanWindowUpperLimit\" #' List number of spectra per MS level spectra(mse) |>     msLevel() |>     table() ##  ##    1  ## 1862 #' Get the distribution of peak counts per file spectra(mse) |>     lengths() |>     split(fromFile(mse)) |>     lapply(quantile) ## $`1` ##     0%    25%    50%    75%   100%  ##  456.0 1122.5 1536.0 2089.0 3995.0  ##  ## $`2` ##     0%    25%    50%    75%   100%  ##  481.0 1101.5 1557.0 2153.5 4088.0 #' Extract one spectrum from the second file sp <- spectra(mse[2])[123] sp ## MSn data (Spectra) with 1 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1    34.314       123 ##  ... 34 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML #' Extract m/z values mz(sp) ## NumericList of length 1 ## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539 #' Extract intensity values intensity(sp) ## NumericList of length 1 ## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0 #' Calculate total ion signal for the extracted spectrum intensity(sp) |>     sum() ## [1] 604912 #' Calculate the distribution of total ion signal of the first file mse[1] |>     spectra() |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   69074.0  445575.5  697201.0  897149.5 1562795.0 #' Repeat for the second file mse[2] |>     spectra() |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   70414.0  404923.5  674512.0  878191.0 1679901.0"},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"general-data-overview","dir":"Articles","previous_headings":"Data import and exploration > Data visualization","what":"General data overview","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Visualization crucial quality assessment MS data. LC-MS data visualizing base peak chromatogram (BPC) total ion chromatogram (TIC) example allow evaluate performance liquid chromatography various samples experiment. create plot extract BPC data. BPC extracts maximum peak signal spectrum data file allows thus plot information (y-axis) retention time spectrum. also extract values similarly total ion intensity previous section, use chromatogram() function allows extraction chromatographic data MS data (e.g. MsExperiment object). parameter aggregationFun = \"max\" define report maximum signal per spectrum (setting aggregationFun = \"sum\" contrast sum intensities spectrum hence return TIC).  plot shows BPC two data files (line representing one sample) provides information retention times signal measured (thus retention times compounds eluted LC column). can clearly spot regions along retention time signal/compounds eluted. Also, BPC two data files look similar, expected since represent sample. addition visual inspection , especially larger data sets, important also quantitatively compare data derive quality metrics data set. base peak signals, however, retention times slightly different samples preventing thus direct comparison evaluation data. easy solution bin data along retention time axis equal sized bins aggregate measured intensities within bin (per sample). bin data bin size 1 second reporting maximal signal per bin. binning, two chromatograms retention times (number intensities) can thus bind intensity vectors columns new numeric matrix using cbind(): now example calculate correlation intensities two samples, can used measure similarity LC-MS runs. also create correlation matrix pairwise correlation coefficients samples samples. particularly helpful data sets two samples. correlation matrix also easily visualized heatmap - additional possibility cluster samples similar BPC. present, two-sample data set, informative, larger data sets can help evaluate differences batches spot outlier samples (rather outlier LC-MS measurement runs). Heatmap similarity BPC two data files also exemplifies power R-based analysis workflow allows us combine LC-MS specific analysis methods provided e.g. xcms package build-R functions (statistical) data analysis methods provided R package. BPC collapsed 3-dimensional LC-MS data (m/z retention time intensity) 2 dimensions (retention time intensity). orthogonal visualization base peak spectrum (BPS) collapses data retention time dimension. visualization provide information abundant masses (rather mass--charge values) data set (regardless retention time measured). contrast BPC however straight forward create visualization: mass peaks, even representing signal ion, never identical consecutive spectra, slightly differ based measurement error/resolution instrument. plot spectra 2 consecutive scans. Spectra two consecutive scan first file two spectra now merged reporting m/z (rather peaks similar m/z consecutive spectra) maximal signal observed. Spectra, combineSpectra() function allows aggregate/combine sets spectra single spectrum. default, function combine sets spectra (can defined parameter f) creating union peaks present spectra set. mass peaks similar m/z value (depending parameter ppm) peaks’ intensities aggregated using function defined parameter intensityFun result single value per (aggregated) peak. setting combine spectra one file (using f = fromFile(mse)) single spectrum containing mass peaks present spectra file. Mass peaks difference m/z smaller ppm (parts-per-million m/z value) combined one peak maximal intensity grouped peaks reported. Note suggested use small value ppm combine MS1 spectra combineSpectra(). bps thus Spectra two spectra representing BPS two data files. plot . Base peak spectrum two samples. BPS thus show common ions present two samples. Apparently seems quite overlap ion content two files. Also , can calculate similarities spectra. , either bin spectra calculate correlation matrix intensities: Alternatively, can also directly calculate similarity base peak spectra using compareSpectra() function one available peak similarity measures. use normalized dot product calculate similarity two spectra matching peaks using m/z tolerance 10 ppm. measures thus allow us get general information data set evaluate similarities samples experiment.","code":"#' Extract and plot a BPC bpc <- chromatogram(mse, aggregationFun = \"max\") plot(bpc) #' Bin the BPC bpc_bin <- bin(bpc, binSize = 1) #' Create an intensity matrix bpc_mat <- do.call(cbind, lapply(bpc_bin, intensity)) #' Assess similarity between the numerical vectors using a simple #' Pearson correlation. cor(bpc_mat[, 1], bpc_mat[, 2]) ## [1] 0.9605883 #' Create a pairwise correlation matrix cor(bpc_mat) ##           [,1]      [,2] ## [1,] 1.0000000 0.9605883 ## [2,] 0.9605883 1.0000000 #' Create a heatmap of the correlation matrix library(pheatmap) cor(bpc_mat) |>     pheatmap() #' Plot two consecutive spectra plotSpectra(spectra(mse)[123:124], xlim = c(105, 130)) #' Combine all spectra of one file into a single spectrum bps <- spectra(mse) |>     combineSpectra(f = fromFile(mse), ppm = 5, intensityFun = max) bps ## MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1     0.280         1 ## 2         1     0.275         1 ##  ... 34 more variables/columns. ## Processing: ##  Switch backend from MsBackendMzR to MsBackendMemory [Fri Dec 12 08:40:51 2025] ##  Switch backend from MsBackendMzR to MsBackendMemory [Fri Dec 12 08:40:53 2025] ##  Merge 2 Spectra into one [Fri Dec 12 08:40:53 2025] #' Plot the BPS plotSpectra(bps) #' Bin the spectra and calculate similarity between their intensities bps_bin <- bin(bps, binSize = 0.01)  do.call(cbind, intensity(bps_bin)) |>     cor() ##           [,1]      [,2] ## [1,] 1.0000000 0.9898653 ## [2,] 0.9898653 1.0000000 #' Calculate normalized dot product similarity between the spectra compareSpectra(bps, ppm = 10, FUN = MsCoreUtils::ndotproduct) ##           1         2 ## 1 1.0000000 0.9803889 ## 2 0.9803889 1.0000000"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"detailed-data-inspection","dir":"Articles","previous_headings":"Data import and exploration > Data visualization","what":"Detailed data inspection","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Apart general data overview also possible (also suggested) explore data detail. end next focus specific subset data expect signal compound present serum samples (ions molecule serine). particular LC-MS setup used present samples, ions metabolite expected elute 180 seconds (retention time determined measuring pure standard compound LC-MS setup). thus filter spectra data using filterRt() function extracting spectra measured 180 181 seconds. present data set 6 spectra measured within one second samples. extracting data Spectra object however lost now direct (inherent) association spectra samples experiment. extract name original data file data imported (see example ) use determine originating sample, involve additional R code. Alternatively, use filterSpectra() function MsExperiment object passing filter function (case filterRt()) function. filters Spectra object within MsExperiment retaining associations (links) samples subset spectra. commonly used filter functions, filterRt() filterMsLevel(), also implemented MsExperiment, filterSpectra() function allows apply many filter functions available Spectra objects data. present purpose however important keep sample association intact thus proceed plot previously extracted spectra. MS1 spectra measured 180 181 seconds can immediately spot several mass peaks spectrum, largest one m/z 130 second largest 106, represent signal ion Serine. calculate exact (monoisotopic) mass serine chemical formula C3H7NO3 using calculateMass() function MetaboCoreUtils package. native serine molecule however uncharged can thus measured mass spectrometry. order detectable, molecules need ionized injected MS instrument. different ions can () generated molecule, one commonly generated ions positive polarity [M+H]+ ion (protonated ion). calculate m/z values specific ions/adducts molecules, can use mass2mz() function, also MetaboCoreUtils package. calculate m/z [M+H]+ ion serine providing monoisotopic mass molecule specifying adduct interested . Also types adducts supported. listed adductNames function (adductNames() positively charged adductNames(\"negative\") negatively charge ions). mass2mz() function always returns matrix columns reporting m/z requested adduct(s) molecule(s) available rows. Since requested single ion reduce matrix single numeric value. can now use information subset MS data signal recorded ions particular m/z. use chromatogram() function provide m/z range interest mz parameter function. Note alternatively also first filter data set m/z using filterMzRange() function extract chromatogram. Ion trace ion serine strong signal visible around retention time 180 seconds likely represents signal [M+H]+ ion serine. Note , retention time molecule specific LC-MS setup known beforehand, extracting chromatograms m/z interest full retention time range can help determining likely retention time. object returned chromatogram() function arranges individual MChromatogram objects (representing chromatographic data consisting pairs retention time intensity values one sample) two-dimensional array, columns samples (files) rows data slices (.e., m/z - rt ranges). Note type data representation, defined MSnbase package, likely replaced future efficient flexible data structure similar Spectra. Data individual chromatograms can accessed using intensity() rtime() functions (similar mz() intensity() functions Spectra object). Note NA reported m/z range chromatographic data extracted intensity measured given retention time (.e. spectrum). last focus tentative signal serine extracting ion chromatogram restricting retention time range containing signal. also pass retention time m/z range parameters rt mz chromatogram() function instead filter whole experiment retention time m/z calling chromatogram() created data subset. example code thus create extracted ion chromatogram (EIC, sometimes also referred XIC) [M+H]+ ion serine. Extracted ion chromatogram serine. area chromatographic peak supposed proportional amount corresponding ion respective sample identification quantification peaks one goals LC-MS data preprocessing. inspected signal measured ions serine, workflow () also repeated potentially present ions (internal standards) evaluate LC-MS data experiment.","code":"#' Extract all spectra measured between 180 and 181 seconds sps <- spectra(mse) |>     filterRt(c(180, 181)) sps ## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ## 4         1   180.235       646 ## 5         1   180.514       647 ## 6         1   180.793       648 ##  ... 34 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s)  [Fri Dec 12 08:40:54 2025] #' List the original data file for each spectrum basename(dataOrigin(sps)) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" ## [5] \"20171016_POOL_POS_3_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" #' Subset the whole MsExperiment mse_sub <- filterSpectra(mse, filter = filterRt, rt = c(180, 181)) #' Extract spectra from the subset for the first sample spectra(mse_sub[1]) ## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ##  ... 34 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s)  [Fri Dec 12 08:40:55 2025] #' Plot the spectra plotSpectra(sps) #' Calculate the (monoisotopic) mass of serine library(MetaboCoreUtils) mass_serine <- calculateMass(\"C3H7NO3\") mass_serine ##  C3H7NO3  ## 105.0426 #' Calculate the m/z for the [M+H]+ ion of serine serine_mz <- mass2mz(mass_serine, \"[M+H]+\") serine_mz ##           [M+H]+ ## C3H7NO3 106.0499 serine_mz <- serine_mz[1, 1] #' Extract a full RT chromatogram for ions with an m/z similar than serine serine_chr <- chromatogram(mse, mz = serine_mz + c(-0.005, 0.005)) plot(serine_chr) #' Get intensity values for the chromatogram of the first sample intensity(serine_chr[1, 1]) |>     head() ## [1]  NA  NA 132  NA  NA  NA #' Get the respective retention times of the first sample rtime(serine_chr[1, 1]) |>     head() ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 #' Create an EIC for serine mse |>     filterRt(rt = c(175, 189)) |>     filterMzRange(mz = serine_mz + c(-0.005, 0.005)) |>     chromatogram() |>     plot()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"centroiding-of-profile-ms-data","dir":"Articles","previous_headings":"","what":"Centroiding of profile MS data","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"MS instruments allow export data profile centroid mode. Profile data contains signal discrete m/z values (retention times) instrument collected data (Smith et al. 2014). MS instruments continuously sample record signals, therefore mass peak single ion one spectrum consist multiple intensities discrete m/z values. process reduce distribution signals single representative mass peak (centroid) called centroiding. process results much smaller file sizes, little information loss. xcms, specifically centWave chromatographic peak detection algorithm, designed centroided data, thus, prior data analysis, profile data, example data used , centroided. inspect profile data one spectra extracted focus mass peak serine. Profile-mode mass peak [M+H]+ ion serine. theoretical m/z ion indicated dotted red line. Instead single peak, several mass peaks recorded MS instrument m/z close theoretical m/z [M+H]+ ion serine (indicated red dotted line). can also visualize information differently: plot() function MsExperiment generates two-dimensional visualization three-dimensional LC-MS data: peaks drawn respective location two-dimensional m/z vs retention time plane intensity color coded. subset data m/z - retention time region containing signal serine visualize full MS data measured region data files. Profile data Serine. lower panel plot shows mass peaks measured instrument: point represents one mass peak intensity color coded (blue representing low, yellow high intensity). column data points represents data spectrum. upper panel plot shows chromatographic visualization data lower panel, .e., retention time (spectrum) sum intensities within m/z range shown. Note , possible create plot full MS data experiment, type visualization works best small m/z - retention time regions. Next, smooth data spectrum using Savitzky-Golay filter, usually improves data quality reducing noise. Subsequently perform centroiding data based simple peak-picking strategy reports maximum signal mass peak spectrum. Finally, replace spectra data (MsExperiment) object centroided spectra visualize result repeating visualization . Centroided data Serine. impact centroiding clearly visible: signal ion spectrum reduced single data point. advanced centroiding options, can also fine-tune m/z value reported centroid, see documentation pickPeaks() function centroiding vignette MSnbase package. now simply proceed data analysis, save centroided MS data mzML files also illustrate Spectra package can used export MS data. use export() function data export centroided Spectra object. Parameter backend allows specify MS data backend used export, also define data format (use backend = MsBackendMzR() export data mzML format). Parameter file defines, spectrum, name file data exported. can import centroided data newly generated mzML files proceed analysis. Thus, lines R code performed MS data centroiding R gives us possibly , better, control process enable also (parallel) batch processing.","code":"#' Visualize the profile-mode mass peak for [M+H]+ of serine sps[1] |>     filterMzRange(c(106.02, 106.07)) |>     plotSpectra(lwd = 2) abline(v = serine_mz, col = \"#ff000080\", lty = 3) #' Visualize the full MS data for a small m/z - rt area mse |>     filterRt(rt = c(175, 189)) |>     filterMzRange(mz = c(106.02, 106.07)) |>     plot() #' Smooth and centroid the spectra data sps_cent <- spectra(mse) |>     smooth(method = \"SavitzkyGolay\", halfWindowSize = 6L) |>     pickPeaks(halfWindowSize = 2L)  #' Replace spectra in the original data object spectra(mse) <- sps_cent  #' Plot the centroided data for Serine mse |>     filterRt(rt = c(175, 189)) |>     filterMzRange(mz = c(106.02, 106.07)) |>     plot() #' Export the centroided data to new mzML files. export(spectra(mse), backend = MsBackendMzR(),        file = basename(dataOrigin(spectra(mse)))) #' Re-import the centroided data. fls <- basename(fls)  #' Read the centroided data. mse <- readMsExperiment(fls, sampleData = pd)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-of-lc-ms-data","dir":"Articles","previous_headings":"","what":"Preprocessing of LC-MS data","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Preprocessing (untargeted) LC-MS data aims detecting quantifying signal ions generated molecules present sample. consists following 3 steps: chromatographic peak detection, retention time alignment correspondence (also called peak grouping). resulting matrix feature abundances can used input downstream analyses including data normalization, identification features interest annotation features metabolites. following sections perform preprocessing test data set, adapting settings preprocessing algorithms data.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Chromatographic peak detection","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Chromatographic peak detection aims identify peaks along retention time axis represent signal individual compounds’ ions. involves identifying quantifying signals shown sketch . peak detection can performed xcms package using findChromPeaks() function. Several peak detection algorithms available can selected configured respective parameter objects: MatchedFilterParam perform peak detection described original xcms article (Smith et al. 2006), CentWaveParam perform continuous wavelet transformation (CWT)-based peak detection (Tautenhahn et al. 2008) MassifquantParam perform Kalman filter-based peak detection (Conley et al. 2014). Additional peak detection algorithms direct injection data also available xcms, discussed . example use centWave algorithm performs peak detection two steps: first identifies regions interest m/z - retention time space subsequently detects peaks regions using continuous wavelet transform (see original publication (Tautenhahn et al. 2008) details). algorithm can configured several parameters (see ?CentWaveParam), important peakwidth ppm. peakwidth defines minimal maximal expected width peak retention time dimension depends thus setup employed LC-MS system making parameter highly data set dependent. ppm hand depends precision MS instrument. section describe settings parameters can empirically determined data set. Generally, strongly discouraged blindly use default parameters peak detection algorithms. illustrate extract EIC serine run centWave-based peak detection data using centWave’s default settings. peak matrix returned chromPeaks() empty, thus, default settings centWave failed identify chromatographic peak EIC serine. default values parameters shown : Particularly setting peakwidth fit data. default parameter expects chromatographic peaks 20 50 seconds wide. plot extracted ion chromatogram (EIC) serine can however see values way large UHPLC-based data set (see ). Extracted ion chromatogram serine. serine, chromatographic peak 5 seconds wide. thus adapt peakwidth present data set repeat peak detection using settings. general, lower upper peak width set include expected chromatographic peak widths. good rule thumb set half twice average expected peak width. present data set thus set peakwidth = c(2, 10). addition, setting integrate = 2, select different peak boundary estimation algorithm. works particularly well non-gaussian peak shapes ensures also signal peak’s tail integrated (eventually re-run code default integrate = 1 compare two approaches). EIC Serine detected chromatographic peak Acceptable values parameter peakwidth can thus derived visual inspection EICs ions known present sample (e.g. internal standards). Ideally, done several compounds/ions. Tip: ensure EIC contains also enough signal left right actual chromatographic peak allow centWave properly estimate background noise. Alternatively, addition, reduce value snthresh parameter peak detection performed EICs. data set-specific peakwidth able detect peak serine (highlighted grey plot ). can now use chromPeaks() function extract information identified chromatographic peaks object. result returned matrix row representing one identified chromatographic peak. retention time ranges peaks provided columns \"rtmin\" \"rtmax\", integrated peak area (.e., abundance ion) column \"\", maximal signal peak column \"maxo\" signal noise ratio column\"sn\". adapted settings thus able identify chromatographic peak serine ion two samples. second important parameter centWave ppm used initial definition regions interest (ROI) actual peak detection performed. define ROI, algorithm evaluates mass peak spectrum whether mass peak similar m/z (reasonably high intensity) also found subsequent spectrum. , mass peaks difference m/z smaller ppm consecutive scans considered. illustrate , plot full MS data data subset containing signal serine.  can observe scattering data points around m/z 105.05 lower panel plot. scattering also decreases increasing signal intensity (many MS instruments precision signal increases intensity). quantify observed differences m/z values signal serine restrict data bona fide region signal serine ion. first subset data first file restrict m/z range values 106.045 106.055. restricted MS data spectra single mass peak per spectrum (presumably representing signal serine ion). next extract m/z values peaks consecutive scans calculate absolute difference . can also express differences ppm (parts per million) average m/z peaks. difference m/z values serine data thus 0 27 ppm. maximum value used centWave’s ppm parameter. Ideally, evaluated several ions set value allows capture full chromatographic peaks tested ions. Also, value parameter generally much higher instrument precision (present instrument 5 ppm). value thus set value allows/accepts variance. can next perform peak detection full data set using settings ppm peakwidth parameters. results form chromatographic peak detection added findChromPeaks() mse variable now XcmsExperiment object , extending MsExperiment class inherits functionality properties, addition contains also xcms preprocessing results. can extract results peak detection step () chromPeaks() function. optional parameters rt mz allow extract peak detection results specified m/z - retention time region. example extract chromatographic peaks m/z range 106 108 retention time 150 190. , row matrix contains one identified chromatographic peak columns \"mz\", \"mzmin\", \"mzmax\", \"rt\", \"rtmin\" \"rtmax\" defining ’s position (size) m/z - rt plane \"\" \"maxo\" (integrated maximum) intensity. Column \"sample\" indicates samples (data files) peak identified. chromatographic peak table contains pairs peaks similar retention times difference m/z values one. Together observed differences intensities, indicate one peaks represents carbon 13 isotope one monoisotopic compound. frequently observed untargeted metabolomics. general overview peak detection results can also helpful determine (eventually) plot number identified chromatographic peaks per sample. count number peaks per sample. number peaks identified, expected since files contain measurements sample (QC pool). additional visual quality assessment, can also plot location identified chromatographic peaks m/z - retention time space data file using plotChromPeaks() function. Location identified chromatographic peaks m/z - rt space. , similar pattern expected present two data files. chromatographic peak detection generally good idea visually inspect individual chromatographic peaks evaluate performance peak detection step. done plotting EICs known compounds/ions data randomly selecting chromatographic peaks. m/z - retention time regions random peaks defined using example code . example however manually define m/z - retention time regions (similarly done known compounds). extract EICs regions chromatogram() function subsequently plot . Identified chromatographic peaks within plotted regions default highlighted semitransparent grey color.  peak detection worked nicely signals upper row, failed define chromatographic peaks containing full signal lower row. cases, signal split separate chromatographic peaks within sample. common problem centWave noisy broad signals. either try adapt centWave settings repeat chromatographic peak detection use refineChromPeaks() function allows post-process peak detection results fix problems (see also documentation refineChromPeaks() function possible refinement options). fuse wrongly split peaks second row, use MergeNeighboringPeaksParam algorithm merges chromatographic peaks overlapping m/z retention time dimension signal higher certain value. specify expandRt = 4 expand retention time width peak 4 seconds side set minProp = 0.75. chromatographic peaks distance tail--head retention time dimension less 2 * expandRt intensity higher 75% lower (apex) intensity two peaks thus merged. apply settings EICs evaluate result post-processing.  peak post-processing able merge signal neighboring peaks lower panel, keeping peaks different isomers present top right plot separate. next apply peak refinement full data set. number peaks per sample peak refinement shown . Also, refineChromPeaks() adds information peak refinement object’s chromPeakData() data frame provides additional metadata information chromatographic peak: number merged peaks thus:","code":"#' Get the EIC for serine in all files serine_chr <- chromatogram(mse, rt = c(164, 200),                            mz = serine_mz + c(-0.005, 0.005),                            aggregationFun = \"max\")  #' Get default centWave parameters cwp <- CentWaveParam()  #' \"dry-run\" peak detection on the EIC. res <- findChromPeaks(serine_chr, param = cwp) chromPeaks(res) ##      mz mzmin mzmax rt rtmin rtmax into intb maxo sn row column #' Default centWave parameters cwp ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 25 ##  - peakwidth: [1] 20 50 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 1 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE ##  - verboseBetaColumns: [1] FALSE #' Plot the EIC plot(serine_chr) #' Adapt centWave parameters cwp <- CentWaveParam(peakwidth = c(2, 10), integrate = 2)  #' Run peak detection on the EIC serine_chr <- findChromPeaks(serine_chr, param = cwp)  #' Plot the data and higlight identified peak area plot(serine_chr) #' Extract identified chromatographic peaks from the EIC chromPeaks(serine_chr) ##             mz    mzmin    mzmax      rt   rtmin  rtmax     into     intb ## mzmin 106.0499 106.0449 106.0549 181.072 178.282 187.21 70373.61 70042.87 ##           maxo  sn row column ## mzmin 38517.76 609   1      2 #' Restrict to data containing signal from serine srn <- mse |>     filterRt(rt = c(179, 186)) |>     filterMzRange(mz = c(106.04, 106.07))  #' Plot the data plot(srn) #' Reduce the data set to signal of the [M+H]+ ion of serine srn_1 <- srn[1] |>     filterMzRange(c(106.045, 106.055)) |>     spectra() lengths(srn_1) ##  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #' Calculate the difference in m/z values between scans mz_diff <- srn_1 |>     mz() |>     unlist() |>     diff() |>     abs() mz_diff ##                                     mz           mz           mz           mz  ## 2.904861e-03 4.357321e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.684509e-05 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 7.624200e-07 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.425717e-03 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00  ##           mz  ## 1.493783e-03 #' Differences in m/z values expressed as ppm mz_diff * 1e6 / mean(unlist(mz(srn_1))) ##                                     mz           mz           mz           mz  ## 27.391410160 41.087396603 27.391691523  1.112566483 13.695817196  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.158840954  0.000000000  0.000000000  0.682099561  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.007189246 13.695808133 13.695808133 12.807212147  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ## 13.443812242  0.000000000 13.695807986 13.957023433  0.000000000  0.000000000  ##           mz  ## 14.085643094 #' Perform peak detection on the full data set cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30, integrate = 2) mse <- findChromPeaks(mse, param = cwp) mse ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 644 in MS level(s): 1 #' Access the peak detection results from a specific m/z - rt area chromPeaks(mse, mz = c(106, 108), rt = c(150, 190)) ##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb ## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   509.4463 ## CP146 107.0653 107.0652 107.0653 173.543 171.032 179.682 11318.2801 11309.9091 ## CP157 107.0532 107.0522 107.0537 181.356 179.682 183.309  2905.1158  2901.7678 ## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73905.2115 ## CP469 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.7921 ## CP477 107.0656 107.0655 107.0657 172.980 169.632 178.003 11372.6845 11166.3372 ## CP492 107.0538 107.0510 107.0540 181.072 178.840 183.304  3155.0100  3149.2053 ## CP512 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70109.3562 ##             maxo   sn sample ## CP133   426.6084   35      1 ## CP146  4936.6783 4936      1 ## CP157  1628.9510  186      1 ## CP167 37664.9371  685      1 ## CP469   381.6084   54      2 ## CP477  4569.1399   79      2 ## CP492  2297.7972  230      2 ## CP512 38517.7622  830      2 #' Count peaks per file chromPeaks(mse)[, \"sample\"] |>     table() ##  ##   1   2  ## 323 321 #' Plot the location of peaks in the m/z - rt plane par(mfrow = c(1, 2)) plotChromPeaks(mse, 1) plotChromPeaks(mse, 2) #' Select 4 random peaks npeaks <- nrow(chromPeaks(mse)) idx <- sample(seq_len(npeaks), 4)  #' Extract m/z-rt regions for 4 random peaks mz_rt <- chromPeaks(mse)[idx, c(\"rtmin\", \"rtmax\", \"mzmin\", \"mzmax\")]  #' Expand the rt range by 10 seconds on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 10 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 10 #' Expand the m/z range by 0.005 on both sides mz_rt[, \"mzmin\"] <- mz_rt[, \"mzmin\"] - 0.005 mz_rt[, \"mzmax\"] <- mz_rt[, \"mzmax\"] + 0.005  #' Display the randomly selected regions mz_rt ##         rtmin   rtmax    mzmin    mzmax ## CP110 141.781 167.919 118.0812 118.0915 ## CP158 170.798 193.309 108.0477 108.0606 ## CP064  64.217  88.960 117.0796 117.0912 ## CP483 167.444 191.072 129.6296 129.6445 #' Define m/z - retention time regions for EICs mz_rt <- rbind(c(106.045, 106.055, 165, 195),                c(132.096, 132.107, 135, 160),                c(125.981, 125.991, 195, 215),                c(105.468, 105.478, 190, 215))  #' Extract the EICs eics <- chromatogram(mse, mz = mz_rt[, 1:2], rt = mz_rt[, 3:4], ) #' Plot the EICs plot(eics) #' Define the setting for the peak refinement mpp <- MergeNeighboringPeaksParam(expandRt = 4, minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = mpp)  #' Plot the result plot(eics) #' Perform peak refinement on the full data set mse <- refineChromPeaks(mse, param = mpp) chromPeaks(mse)[, \"sample\"] |>     table() ##  ##   1   2  ## 297 292 chromPeakData(mse) ## DataFrame with 589 rows and 3 columns ##        ms_level is_filled    merged ##       <integer> <logical> <logical> ## CP001         1     FALSE     FALSE ## CP002         1     FALSE     FALSE ## CP003         1     FALSE     FALSE ## CP004         1     FALSE     FALSE ## CP005         1     FALSE     FALSE ## ...         ...       ...       ... ## CP669         1     FALSE      TRUE ## CP670         1     FALSE      TRUE ## CP671         1     FALSE      TRUE ## CP672         1     FALSE      TRUE ## CP673         1     FALSE      TRUE sum(chromPeakData(mse)$merged) ## [1] 29"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"retention-time-alignment","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Retention time alignment","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"chromatography helps better discriminate analytes also affected variances lead shifts retention times measurement runs. differences can usually already seen base peak chromatogram total ion chromatogram. thus extract plot BPC data set. chromatogram() call, set optional parameter chromPeaks = \"none\" avoid additional extraction identified chromatographic peaks. BPC files. samples measured setup measurement run, still small drifts signal visible. also already visible EIC serine, plot .  serine signal, seems retention time shift 1 second two samples. alignment step aims minimize retention time differences samples within experiment (see illustration). xcms, alignment can performed adjustRtime() function one available alignment algorithms, can selected, configured, respective parameter objects: PeakGroupsParam: peakGroups (Louail et al. 2025) method aligns samples based retention times set called anchor peaks (housekeeping peaks) different samples experiment. peaks supposed represent signal ions expected present samples experiment method aligns samples minimizing -sample retention time differences observed peaks. ObiwarpParam: obiwarp (Prince Marcotte 2006) performs retention time adjustment based full m/z - retention time data. See documentation ObiwarpParam xcms vignette information. , default, retention time shifts estimated full data set, also possible estimate subset samples, repeatedly measured QC samples (e.g. sample pools) adjust full experiment based . See alignment section xcms vignette information subset-based alignment. Note subset-based alignment requires samples organized order measured. Also, recently, functionality added xcms perform alignment pre-selected signals (e.g. retention times internal standards) align data set external reference. example use peakGroups method , mentioned , aligns samples based retention times anchor peaks. define , need first run initial correspondence analysis group chromatographic peaks across samples. use peakDensity method correspondence (details method explanations choices parameters provided next section). brief, parameter sampleGroups defines sample group experiment individual samples belong , parameter minFraction specifies proportion samples (one sample groups defined sampleGroups) chromatographic peak needs detected group LC-MS feature. Chromatographic peaks grouped features difference m/z retention times defined thresholds least minFraction * 100 percent samples least one sample group chromatographic peak detected. example use sample group definition sampleData mse variable set minFraction = 1 requiring thus chromatographic peak identified (100%) available samples define feature. Generally, correspondence performed heterogeneous samples, minFraction values 0.6 0.8 used instead. Since aim initial correspondence define (presumably well separated) groups chromatographic peaks across samples, settings need fully optimized. step now grouped chromatographic peaks across samples defined called LC-MS features (simply features). can thus now run alignment using peakGroups algorithm aligns data minimizing differences retention times anchor peaks (.e. selected features chromatographic peaks detected samples). main parameter define anchor peaks minFraction. Similar definition , minFraction refers proportion samples chromatographic peak needs present, , don’t consider different sample groups, whole data set. setting minFraction = 1 base alignment features peaks identified 100% samples data set. alignments based repeatedly measured samples (e.g. also subset-based alignment sample pools) values >= 0.9 can used. Otherwise, values 0.7 0.9 might advisable ensure reasonable set features selected. evaluate anchor peaks selected based defined settings, can also use adjustRtimePeakGroups() method: Ideally, possible, anchor peaks span retention time range allow alignment full LC runs. evaluate distribution retention times anchor peaks first sample. Anchor peaks cover thus retention time range. identified features used anchor peaks (based minFraction parameter) algorithm minimizes observed -sample retention time differences . Parameter span defines degree smoothing loess function used allow different regions along retention time axis adjusted different factor. value close 0 likely cause overfitting, value 1 cause retention times sample shifted constant value. Values 0.4 0.6 seem reasonable experiments. alignment suggested evaluate results using plotAdjustedRtime() function. function plots differences adjusted raw retention times sample y-axis along adjusted retention times x-axis (line hence representing retention time adjustment one sample/file). Points indicate position individual hook peaks along retention time axis, dotted line connecting peaks belonging feature (algorithm minimized difference retention times). Alignment results: differences raw adjusted retention times sample. rule thumb, differences raw adjusted retention times plot reasonable. Also, possible, anchor peaks (indicated black points plot ) present along wide span retention time range, avoid need extrapolation (usually results strong adjustment). example, largest adjustments 1 2 seconds, reasonable given two samples measured measurement run. Also, features used alignment (.e. anchor peaks) spread across full retention time range. evaluate impact alignment next also plot BPC alignment. similar way , set chromPeaks = \"none\" chromatogram() call tell function include identified chromatographic peaks returned chromatographic data. BPC (top) (bottom) alignment. base peak chromatograms nicely aligned retention time adjustment. addition general assessment, alignment result also evaluated selected compounds (internal standards). thus plot EIC [M+H]+ ion serine alignment. EIC Serine (left) (right) alignment serine peaks also nicely aligned retention time adjustment. , advisable evaluate impact alignment several EICs, ideally also spread along retention time range. Note adjustRtime(), addition retention times individual (MS1) spectra files, adjusted also retention times identified chromatographic peaks, well retention times possibly present MS2 spectra. adjusted retention times stored new spectra variable \"rtime_adjusted\" result object’s Spectra. rtime() function result object default return (adjusted) values.","code":"#' Extract base peak chromatograms bpc_raw <- chromatogram(mse, aggregationFun = \"max\", chromPeaks = \"none\") plot(bpc_raw, peakType = \"none\") #' Plot EIC of serine plot(serine_chr, xlim = c(175, 190)) grid() #' Define the settings for the initial peak grouping - details for #' choices in the next section. pdp <- PeakDensityParam(sampleGroups = sampleData(mse)$group, bw = 1.8,                         minFraction = 1, binSize = 0.01, ppm = 10) mse <- groupChromPeaks(mse, pdp) #' Get the anchor peaks that would be selected pgm <- adjustRtimePeakGroups(mse, PeakGroupsParam(minFraction = 1)) head(pgm) ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT136                           22.601                           24.270 ## FT163                           25.391                           25.665 ## FT030                           25.670                           25.665 ## FT212                           26.507                           26.502 ## FT056                           26.786                           27.060 ## FT162                           28.739                           28.734 #' Evaluate distribution of anchor peaks' rt in the first sample quantile(pgm[, 1]) ##      0%     25%     50%     75%    100%  ##  22.601 155.408 180.240 194.190 259.478 #' Define settings for the alignment pgp <- PeakGroupsParam(minFraction = 1, span = 0.6) mse <- adjustRtime(mse, param = pgp) #' Plot the difference between raw and adjusted retention times plotAdjustedRtime(mse) grid() par(mfrow = c(2, 1))  #' Plot the raw base peak chromatogram plot(bpc_raw) grid()  #' Plot the BPC after alignment chromatogram(mse, aggregationFun = \"max\", chromPeaks = \"none\") |>     plot() grid() par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))  #' EIC before alignment plot(serine_chr) grid() #' EIC after alignment serine_chr_adj <- chromatogram(mse, rt = c(164, 200),                                mz = serine_mz + c(-0.01, 0.01),                                aggregationFun = \"max\") plot(serine_chr_adj) grid()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"correspondence","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Correspondence","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"final step LC-MS preprocessing xcms correspondence analysis, chromatographic peaks types ions (compounds) grouped across samples form called LC-MS features. xcms, correspondence performed using groupChromPeaks() function. correspondence algorithm can selected configured respective parameter objects: NearestPeaksParam: performs peak grouping based proximity chromatographic peaks different samples m/z - retention time space, similar original correspondence method mzMine (Katajamaa et al. 2006). PeakDensityParam: performs simple fast correspondence analysis based density chromatographic peaks (different samples) along retention time axis within slices small m/z ranges (Louail et al. 2025). methods group chromatographic peaks different samples similar m/z retention times features. example use peak density method. algorithm iterates small slices along m/z dimension groups, within slice, chromatographic peaks similar retention times. grouping depends distribution (density) chromatographic peaks samples along retention time axis. Peaks similar retention time result higher peak density certain retention time thus grouped together. grouping depends smoothness density curve can configured parameter bw. illustration showing chromatographic peaks within small m/z range grouped peakDensity method shown sketch . Settings algorithm can best tested optimized using plotChromPeakDensity() function extracted chromatograms. extract chromatogram m/z slice containing signal [M+H]+ ion serine evaluate result peakDensity correspondence analysis using function. use default settings (bw = 30) use sample group assignment defined sampleData().  upper panel plot shows chromatographic data selected m/z slice identified peaks highlighted grey. lower panel plots retention time identified chromatographic peaks x-axis index sample peak identified. chromatographic peak thus represented point plot (x-axis value retention time y-axis value sample identified). example one chromatographic peak identified sample retention time 180 seconds two peaks thus shown. black solid line represents density estimation (.e. distribution retention times) identified chromatographic peaks along retention time axis. smoothness curve (created base R density() function) configured parameter bw. peakDensity algorithm assigns chromatographic peaks within peak density estimation curve feature. Chromatographic peaks assigned feature indicated grey rectangle lower panel plot. present example, retention times two chromatographic peaks similar, rectangle narrow looks thus like vertical line. Based result, default settings (bw = 30) seemed correctly define features. however advisable evaluate settings multiple slices, ideally signal one compound present. slices identified e.g. plot created plotChromPeaks() function (see example chromatographic peak detection section). example extract chromatogram m/z slice containing signal known isomers betaine valine ([M+H]+ m/z 118.08625). Correspondence analysis default settings m/z slice containing signal multiple ions. slice contains signal several ions resulting multiple chromatographic peaks along retention time axis. default settings, particular bw = 30, peaks however assigned feature (indicated grey rectangle). Signal different ions thus treated single entity. repeat analysis strongly reduced value parameter bw. Correspondence analysis reduced bw setting m/z slice containing signal multiple ions. Setting bw = 1.8 strongly reduced smoothness density curve resulting higher number density peaks hence nice grouping (aligned) chromatographic peaks separate features. Note height peaks density curve relevant grouping. defined bw appropriate data set, proceed perform correspondence analysis full data set. parameters peakDensity binSize minFraction. minFraction parameter (already discussed ) defines proportion samples within least one sample group chromatographic peaks need identified order define feature. binSize defines m/z widths slices along m/z dimension algorithm iterate . parameter thus translates maximal acceptable difference m/z values peaks considered representing signal ion. value depends resolution (noise) instrument, set small value, also large (avoid peaks different ions, slightly different m/z similar retention times, grouped feature). Note default constant m/z width used, might however reflect m/z-dependent measurement error instruments (TOF instruments). address , parameter ppm recently added allows generate m/z-dependent bin sizes: width m/z slices increases ppm bin’s m/z along m/z axis. correspondence analysis set maximal acceptable difference chrom peaks’ m/z values binSize = 0.01 ppm = 10, hence grouping chromatographic peaks similar retention time difference m/z values smaller 0.01 + 10 ppm m/z values. setting minFraction = 0.4 addition require feature chromatographic peak detected >= 40% samples least one sample group. present data set restricted quite narrow m/z range, thus, parameter ppm strong impact. real data sets, parameter results m/z-dependent m/z width detected features. binSize = 0.01 ppm = 10 data set m/z range 0 1000, width m/z bins linearly increase, along m/z axis, initial size 0.01 value 0.02 (static size 0.01 plus 10 ppm maximal m/z 1000 results maximal bin size 0.02). See also github issue example discussion. 300 features identified example data set. , suggested evaluate results selected compounds/ions. therefore extract chromatogram m/z range containing signals betaine valine. correspondence analysis also feature definitions extracted chromatogram() call can show results actual correspondence analysis (based also settings used) setting simulate = FALSE plotChromPeakDensity() call. Result correspondence m/z slice containing isomers valine betaine. evaluate results also different slice containing signal ions isomers leucine isoleucine ([M+H]+ m/z 132.10191). Result correspondence m/z slice containing isomers leucine isoleucine. Despite close, chromatographic peaks two isomers successfully grouped separate features. Even partially overlapping signal third ion eluting time hence partially overlapping peak retention time 152 seconds grouped , separate, feature. discretion data analysts define fine coarse feature grouping . Especially larger experiments, samples also larger variation retention time might always possible completely separate closely eluting ions sometimes might acceptable group single feature (keeping mind feature however potentially represent signal multiple different ions/compounds). Similar peak detection alignment results, also results correspondence analysis added XcmsExperiment object. can extracted featureDefinitions() function, extracts definition LC-MS features featureValues() function extracts numerical matrix feature abundances (samples). extract definition features display first 6 rows. row defines one feature provides information ’s m/z (column \"mzmed\") retention time (column \"rtmed\"). -min -max columns list minimum maximum rt m/z value chromatographic peaks assigned feature. Additional columns list number chromatographic peaks assigned feature MS level. Column \"peakidx\" provides indices chromatographic peaks chromPeaks() matrix assigned feature - generally users need extract information. feature abundance matrix, final result xcms preprocessing, can extracted featureValues() function. default, parameter method = \"maxint\", returns feature integrated peak signal chromatographic peak highest signal per sample. Note effect features one chromatographic peak per sample (.e., multiple chromatographic peaks sample grouped feature closeness retention time m/z value). Setting method = \"sum\" contrast sum abundances chromatographic peaks. Note method = \"sum\" suggested , like example, neighboring overlapping peaks per sample merged avoid overestimation feature abundance. extract feature abundances show first 6 rows. now use feature matrix downstream analysis. feature matrix might however, can also seen second row (feature FT002), contain missing values. represent features chromatographic peak identified one () sample(s). number imputation methods exist deal missing values, might advisable instead rescue signal. xcms provides gap filling explained next section.","code":"#' Extract a chromatogram for a m/z range containing serine chr_1 <- chromatogram(mse, mz = serine_mz + c(-0.005, 0.005))  #' Default parameters for peak density; bw = 30 pdp <- PeakDensityParam(sampleGroups = sampleData(mse)$group, bw = 30)  #' Test these settings on the extracted slice plotChromPeakDensity(chr_1, param = pdp) #' Plot the chromatogram for an m/z slice containing betaine and valine mzr <- 118.08625 + c(-0.005, 0.005) chr_2 <- chromatogram(mse, mz = mzr, aggregationFun = \"max\")  #' Correspondence in that slice using default settings plotChromPeakDensity(chr_2, param = pdp) #' Reducing the bandwidth pdp <- PeakDensityParam(sampleGroups = sampleData(mse)$group, bw = 1.8) plotChromPeakDensity(chr_2, param = pdp) #' Set in addition parameter ppm to a value of 10 pdp <- PeakDensityParam(sampleGroups = sampleData(mse)$group, bw = 1.8,                         minFraction = 0.4, binSize = 0.01, ppm = 10)  #' Perform the correspondence analysis on the full data mse <- groupChromPeaks(mse, param = pdp) mse ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 589 in MS level(s): 1  ##   - adjusted retention times ##   - correspondence results: 357 features in MS level(s): 1 #' Extract chromatogram including signal for betaine and valine chr_2 <- chromatogram(mse, mz = 118.08625 + c(-0.005, 0.005),                       aggregationFun = \"max\") #' Setting simulate = FALSE to show the actual correspondence results plotChromPeakDensity(chr_2, simulate = FALSE) #' Extract chromatogram with signal for isomers leucine and isoleucine chr_3 <- chromatogram(mse, mz = 132.10191 + c(-0.005, 0.005),                       aggregationFun = \"max\") plotChromPeakDensity(chr_3, simulate = FALSE) #' Definition of the features featureDefinitions(mse) |>     head() ##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL ## FT001 105.0418 105.0417 105.0418 167.68958 167.50191 167.87725      2    2 ## FT002 105.0415 105.0415 105.0415 157.72336 157.72336 157.72336      1    1 ## FT003 105.0697 105.0691 105.0703  31.80810  31.67412  31.94208      2    2 ## FT004 105.1103 105.1100 105.1105  63.75036  63.45657  64.04414      2    2 ## FT005 105.4734 105.4732 105.4736 201.57632 201.37059 201.78204      2    2 ## FT006 105.7166 105.7160 105.7172 181.21537 181.08482 181.34592      2    2 ##        peakidx ms_level ## FT001 115, 393        1 ## FT002      114        1 ## FT003  21, 317        1 ## FT004  49, 348        1 ## FT005 261, 573        1 ## FT006 138, 440        1 #' Get abundances for the first 6 features featureValues(mse, method = \"sum\") |>     head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                               NA ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"gap-filling","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Gap filling","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Missing values feature matrices xcms-based preprocessing represent cases , particular sample, chromatographic peak identified m/z - retention time region feature. either represent truly missing value (ion/compound present sample) failure peak detection algorithm identify peak (either measured signal noisy, low, combination ). illustrate define m/z - retention time regions containing signal features missing values, extract EICs plot (using different color sample). Note: regions identified first visually inspecting EICs features least one missing value. Examples features peak identified one sample. Indeed, feature, chromatographic peak detection failed identify peak one two samples (detected chromatographic peaks indicated grey background color plot ). features upper panel, signal likely low, bottom left feature signal likely noisy, bottom right sparse (.e. data points properly detect peak). cases, however, signal (presumably) ion measured samples. Thus, reporting missing value correct . aim gap filling now rescue signal features integrating intensities measured within feature’s m/z - retention time area sample(s) chromatographic peak detected. xcms can done fillChromPeaks() function ChromPeakAreaParam parameter configure gap filling. perform gap filling showing also number missing values running fillChromPeaks(). fillChromPeaks() thus rescue signal 26 features. Also 4 example features signal filled-. visualize gap-filled chromatographic peaks . Features filled-signal. contrast, identify plot EICs features signal filled-(.e. still missing values one two samples). Features missing values even gap-filling. features indeed signal measured one two samples. alternative way confirm gap-filling able correctly rescue signals plot, features least one missing value, average detected average filled-signal. Ideally, done QC samples repeatedly measured samples difference feature abundances samples expected. code extracts first detected feature values (setting filled = FALSE featureValues() call), detected filled-signal. latter, detected signal subsequently replaced NA create data matrix filled-values. Finally, calculating row averages matrices (excluding missing values), values plotted . Detected (x-axis) filled (y-axis) signal. black solid line represents identity line. expected, detected signal generally higher filled-signal. biggest part (particular higher intensities), filled-detected feature values similar suggesting gap filling step indeed rescued signal. also calculate statistics values. fit linear regression line data summarize result. value 1.007, slope line thus close slope identity line two sets values also highly correlated (R squared 0.81).","code":"#' Define m/z - rt regions for selected examples with missing peaks mz_rt <- rbind(c(109.661, 109.664, 192, 200),                c(109.993, 109.998, 200, 215),                c(125.586, 125.591, 195, 215),                c(130.959, 130.961, 197, 201))  #' Extract their EICs and plot them chrs <- chromatogram(mse, mz = mz_rt[, 1:2], rt = mz_rt[, 3:4]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Number of missing values sum(is.na(featureValues(mse))) ## [1] 133 #' Perform gap filling mse <- fillChromPeaks(mse, param = ChromPeakAreaParam())  #' Number of missing values after gap filling sum(is.na(featureValues(mse))) ## [1] 25 #' Extract their EICs and plot them chrs <- chromatogram(mse, mz = mz_rt[, 1:2], rt = mz_rt[, 3:4]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Identify rows (features) with at least one missing value across samples any_na <- featureValues(mse) |>     rowSums() |>     is.na() #' Get the feature IDs for these fts <- rownames(featureValues(mse))[any_na]  #' Extract the m/z - rt regions for these features mz_rt <- featureArea(mse, features = fts)  #' Expand the retention time by 1 second on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 1 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 1  chrs_na <- chromatogram(mse, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                         rt = mz_rt[, c(\"rtmin\", \"rtmax\")])  plot(chrs_na, col = c(\"red\", \"blue\"), lwd = 2) #' Get only detected signal vals_detect <- featureValues(mse, filled = FALSE)  #' Get detected and filled-in signal vals_filled <- featureValues(mse)  #' Replace detected signal with NA vals_filled[!is.na(vals_detect)] <- NA  #' Identify features with at least one filled peak has_filled <- is.na(rowSums(vals_detect))  #' Calculate row averages avg_detect <- rowMeans(vals_detect, na.rm = TRUE) avg_filled <- rowMeans(vals_filled, na.rm = TRUE)  #' Restrict to features with at least one filled peak avg_detect <- avg_detect[has_filled] avg_filled <- avg_filled[has_filled]  #' plot the values against each other (in log2 scale) plot(log2(avg_detect), log2(avg_filled),      xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      pch = 21, bg = \"#00000080\") grid() abline(0, 1) #' fit a linear regression line to the data l <- lm(log2(avg_filled) ~ log2(avg_detect)) summary(l) ##  ## Call: ## lm(formula = log2(avg_filled) ~ log2(avg_detect)) ##  ## Residuals: ##     Min      1Q  Median      3Q     Max  ## -4.4598 -0.3337  0.2518  0.7176  1.6402  ##  ## Coefficients: ##                  Estimate Std. Error t value Pr(>|t|)     ## (Intercept)      -1.34738    0.48180  -2.797  0.00613 **  ## log2(avg_detect)  1.01347    0.04751  21.333  < 2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 1.114 on 106 degrees of freedom ##   (25 observations deleted due to missingness) ## Multiple R-squared:  0.8111, Adjusted R-squared:  0.8093  ## F-statistic: 455.1 on 1 and 106 DF,  p-value: < 2.2e-16"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-result","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Preprocessing result","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"xcms preprocessing results stored within XcmsExperiment object. includes identified chromatographic peaks, alignment results well correspondence results. addition, guarantee reproducibility, result object keeps track performed processing steps contains also individual parameter objects used various preprocessing steps. can extracted processHistory() function: individual parameter object can extracted follows: Thus, used preprocessing algorithms along settings reported along preprocessing results. described , values individual features can extracted result object featureValues() function definition features (used initial annotation features based m/z /retention times) using featureDefinitions() function. addition, XcmsExperiment result object, internal Spectra object, keeps link full MS data used analysis. downstream analyses, don’t need access MS data anymore, preprocessing results represented equally well using SummarizedExperiment object, Bioconductor’s standard container large-scale omics data. xcms provides quantify() function convenience function extract results XcmsExperiment result object return SummarizedExperiment. function takes parameters featureValues(), also internally used extract feature value matrix. sample annotations can now accessed colData() function feature definitions (.e. annotation individual rows/features) rowData() function: feature values stored assay within object. access simply use assay() function. SummarizedExperiment objects allow also multiple assay-matrices. example, addition full feature value matrix, also add second assay signals detected chromatographic peaks (.e. without gap-filled data). SummarizedExperiment can subset rows /columns. subset operations correctly subset row- column data well present assay matrices keeping structure data sub set intact.","code":"#' Process history processHistory(mse) ## [[1]] ## Object of class \"XProcessHistory\" ##  type: Peak detection  ##  date: Fri Dec 12 08:41:06 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: CentWaveParam  ##  MS level(s) 1  ##  ## [[2]] ## Object of class \"XProcessHistory\" ##  type: Peak refinement  ##  date: Fri Dec 12 08:41:08 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: MergeNeighboringPeaksParam  ##  MS level(s) 1  ##  ## [[3]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Fri Dec 12 08:41:10 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[4]] ## Object of class \"XProcessHistory\" ##  type: Retention time correction  ##  date: Fri Dec 12 08:41:10 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakGroupsParam  ##  MS level(s) 1  ##  ## [[5]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Fri Dec 12 08:41:14 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[6]] ## Object of class \"XProcessHistory\" ##  type: Missing peak filling  ##  date: Fri Dec 12 08:41:16 2025  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: ChromPeakAreaParam  ##  MS level(s) 1 #' Peak detection parameters processHistory(mse)[[1]]@param ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 30 ##  - peakwidth: [1]  2 10 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 2 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE ##  - verboseBetaColumns: [1] FALSE #' Extract results as a SummarizedExperiment library(SummarizedExperiment) res <- quantify(mse, method = \"sum\") #' Get sample annotations colData(res) ## DataFrame with 2 rows and 5 columns ##                                           file      sample injection_index ##                                    <character> <character>       <numeric> ## 20171016_POOL_POS_1_105-134.mzML 20171016_P...      POOL_1               1 ## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19 ##                                        group spectraOrigin ##                                  <character>   <character> ## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT... ## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT... #' Get feature annotations rowData(res) ## DataFrame with 357 rows and 9 columns ##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks ##       <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> ## FT001   105.042   105.042   105.042  167.6896  167.5019  167.8773         2 ## FT002   105.042   105.042   105.042  157.7234  157.7234  157.7234         1 ## FT003   105.070   105.069   105.070   31.8081   31.6741   31.9421         2 ## FT004   105.110   105.110   105.111   63.7504   63.4566   64.0441         2 ## FT005   105.473   105.473   105.474  201.5763  201.3706  201.7820         2 ## ...         ...       ...       ...       ...       ...       ...       ... ## FT353   133.929   133.929   133.929  193.3516   193.322  193.3808         2 ## FT354   133.956   133.956   133.956  199.0666   198.990  199.1432         2 ## FT355   133.960   133.960   133.961   30.8309    30.821   30.8409         2 ## FT356   133.973   133.973   133.973  206.8718   206.405  207.3387         2 ## FT357   133.973   133.973   133.973  200.2561   200.256  200.2561         1 ##            POOL  ms_level ##       <numeric> <integer> ## FT001         2         1 ## FT002         1         1 ## FT003         2         1 ## FT004         2         1 ## FT005         2         1 ## ...         ...       ... ## FT353         2         1 ## FT354         2         1 ## FT355         2         1 ## FT356         2         1 ## FT357         1         1 #' Get feature values assay(res) |>     head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                        3191.7385 ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545 #' Assign a new assay to the SummarizedExperiment result object assay(res, \"raw_detected\") <- featureValues(mse, method = \"sum\",                                             filled = FALSE) #' Subset to the first 10 features res[1:10, ] ## class: SummarizedExperiment  ## dim: 10 2  ## metadata(6): '' '' ... '' '' ## assays(2): raw raw_detected ## rownames(10): FT001 FT002 ... FT009 FT010 ## rowData names(9): mzmed mzmin ... POOL ms_level ## colnames(2): 20171016_POOL_POS_1_105-134.mzML ##   20171016_POOL_POS_3_105-134.mzML ## colData names(5): file sample injection_index group spectraOrigin"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"what-next","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"What next?","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"preprocessing, data normalized scaled remove technical variances data. simple e.g. median scaling done lines R code also advanced (always needed) normalization algorithms available e.g. Bioconductor’s preprocessCore package. Differential abundance analysis performed using limma package packages methods available R. mentioned , many chromatographic peaks (subsequently also features) untargeted metabolomics data sets represent isotopes also different ions/adducts compound. CAMERA package aimed identify group features data set. similar feature grouping (compounding) can also done preprocessing results newer versions xcms using MsFeatures package. package enables grouping features variety different methods. See also feature grouping vignette xcms details. Finally, MetaboAnnotation package provides functions assist annotation features LC-MS well LC-MS/MS experiments. allow either perform initial annotation based m/z values combination m/z retention time values. addition, also annotations based fragment spectra (available) supported (without considering addition features’ retention times. information provided MetaboAnnotation vignette MetaboAnnotation tutorial. information general MS data analysis R spectra similarity calculations can found RforMassSpectrometry book various workshops/tutorials SpectraTutorials.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"final-words","dir":"Articles","previous_headings":"","what":"Final words","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"xcms single, monolithic software, part package ecosystem. Use infrastructure provided RforMassSpectrometry package ecosystem inspect, explore summarize data. Create visualization/summarization functions needed. Combine functionalities different packages. Create customized (reproducible) analysis workflows. Don’t use default settings xcms preprocessing algorithms.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-analyses-performed-on-chromatographic-or-spectra-data-of-preprocessing-results","dir":"Articles","previous_headings":"Appendix","what":"Additional analyses performed on chromatographic or spectra data of preprocessing results","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"used basic functionality xcms perform preprocessing LC-MS experiment, functionality visualization options available infrastructure provided xcms, Spectra, MsCoreUtils, MetaboCoreUtils related Bioconductor packages. example easily possible extract specific information selected chromatographic peaks LC-MS features xcms result object perform additional visualizations analyses . example first identify chromatographic peaks match m/z serine. chromPeakChromatograms() function can used extract EIC specific chromatographic peak sample. can also extract full MS1 scan (spectrum) apex position chromatographic peak using chromPeakSpectra() function parameters msLevel = 1 method = \"closest_rt\". LC-MS/MS data, function also allow extract MS2 spectra data set precursor m/z (retention time) within chromatographic peak’s m/z retention time width using parameters msLevel = 2 method = \"\". plot EIC MS1 scan selected chromatographic peak. EIC [M+H]+ ion serine one sample full scan MS1 spectrum EIC’s apex position. Similar information can also extracted LC-MS features using featureChromatograms() featureSpectra() functions functions return chromatograms spectra samples experiment (just single sample). Also, importantly, chromPeakChromatogram() extracts EIC specific selected sample, .e. using exact m/z retention time ranges chromatographic peak sample, featureChrommatograms() instead integrate signal m/z retention time area feature, .e. use single area integrate signal area sample. m/z - retention time area might however larger respective ranges single chromatographic peak one sample. m/z - retention time area features can also extracted (evaluated) using featureArea() function: Additional analyses now performed full scan MS1 spectrum containing mass peak [M+H]+ ion serine. One possibility identify potential isotope peaks monoisotopic mass peak serine. isotopologues function MetaboCoreUtils allows example identify group potential isotope peaks MS1 spectrum data without assumptions chemical formula compound interest. function thus identified two peaks , based m/z values differences intensity, represent isotopologues. highlight mass peaks full MS1 spectrum. Full scan spectrum apex position signal [M+H]+ ion serine. Isotopologues indicated red. example specifically looking potential isotopes single, selected, mass peak (setting seedMz m/z value peak), also use isotopologues() without specifying seedMz identify potential isotope groups spectrum. can also highlight spectrum plot. MS1 spectrum potential isotope groups highlighted different colors. Note isotopologue identification limited data MS1 spectrum. also identify features representing signal potential isotopes. create matrix features’ m/z values maximum intensity feature one samples apply isotopologues() function . thus identified potential isotopologues, , ignored retention times features simple approach, list contain also many false positives. features isotope group example different retention times can thus represent signal isotopes compound. Others however real isotopes:","code":"#' Extract chromatographic peaks matching the m/z of the [M+H]+ of serine serine_pks <- chromPeaks(mse, mz = serine_mz, ppm = 20) serine_pks ##             mz    mzmin    mzmax       rt    rtmin    rtmax     into     intb ## CP167 106.0506 106.0505 106.0506 181.0848 178.5814 187.4950 74181.78 73905.21 ## CP512 106.0496 106.0494 106.0508 181.3459 178.5474 187.4925 70373.61 70109.36 ##           maxo  sn sample ## CP167 37664.94 685      1 ## CP512 38517.76 830      2 #' Extract EIC for the signal in the second sample serine_eic_2 <- chromPeakChromatograms(mse, peaks = rownames(serine_pks)[2]) # Extract the full MS1 scan for the chrom peak at apex position serine_ms1_2 <- chromPeakSpectra(mse, msLevel = 1, method = \"closest_rt\",                                  peaks = rownames(serine_pks)[2]) par(mfrow = c(1, 2))  #' Plot the EIC plot(serine_eic_2) #' Indicate the retention time of the full scan MS1 spectrum abline(v = rtime(serine_ms1_2), lty = 2) #' Plot the full scan MS1 spectrum plotSpectra(serine_ms1_2) #' Indicate the theoretical m/z of the points(serine_mz, y = -300, pch = 2, col = \"red\") #' Extract the m/z - retention time area for features featureArea(mse) |>     head() ##          mzmin    mzmax     rtmin     rtmax ## FT001 105.0389 105.0448 162.48680 173.03646 ## FT002 105.0403 105.0434 154.65033 161.36642 ## FT003 105.0680 105.0727  30.56318  34.46556 ## FT004 105.1098 105.1114  61.19807  72.20464 ## FT005 105.4717 105.4747 198.86525 211.48482 ## FT006 105.7141 105.7183 179.69288 182.74128 #' Extract the mass peak data from the MS1 spectrum containing #' the signal from an ion of serine pd <- peaksData(serine_ms1_2)[[1]] head(pd) ##            mz intensity ## [1,] 105.0338  97.01923 ## [2,] 105.7157 574.78322 ## [3,] 105.7288 137.45455 ## [4,] 105.8477 208.91608 ## [5,] 105.9348 239.67133 ## [6,] 105.9537 196.95804 #' Identify mass peaks that could represent isotopes of the mass peak #' of the [M+H]+ ion of serine iso_idx <- isotopologues(pd, seedMz = serine_mz) iso_idx ## [[1]] ## [1]  8 14 #' Set the color for each mass peak to a transparent black color cols <- rep(\"#00000040\", lengths(serine_ms1_2)[1]) #' Use a red color for the identified isotopologues cols[iso_idx[[1]]] <- \"#ff0000ff\" #' Plot the data plotSpectra(serine_ms1_2, col = cols, lwd = 2) #' Identify all potential isotope peaks in the MS1 spectrum iso_idx <- isotopologues(pd) iso_idx ## [[1]] ## [1]  3 17 ##  ## [[2]] ## [1]  8 14 ##  ## [[3]] ## [1] 34 40 43 ##  ## [[4]] ## [1] 42 50 ##  ## [[5]] ## [1] 66 74 ##  ## [[6]] ## [1] 78 85 88 ##  ## [[7]] ## [1] 100 104 ##  ## [[8]] ## [1] 109 121 #' Define a color for all mass peaks and set it to transparent black cols <- rep(\"#00000040\", lengths(serine_ms1_2)[1]) #' Use a different color for each isotope group iso_cols <- rainbow(length(iso_idx)) for (i in seq_along(iso_idx))     cols[iso_idx[[i]]] <- iso_cols[i] plotSpectra(serine_ms1_2, col = cols, lwd = 2) #' Define a matrix with the m/z and intensity values for each feature. #' As intensity we use the highest measured intensity in the first #' sample pd <- cbind(     mz = featureDefinitions(mse)$mzmed,     intensity = featureValues(mse, value = \"maxo\")[, 1] ) #' Ensure the matrix to be sorted by m/z value pd <- pd[order(pd[, \"mz\"]), ]  #' Identify potential isotope groups iso_idx <- isotopologues(pd)  head(iso_idx) ## [[1]] ##       FT015  ##     9    15  ##  ## [[2]] ##       FT012  ##    10    12  ##  ## [[3]] ##       FT023 FT046  ##    13    23    46  ##  ## [[4]] ##       FT035  ##    24    35  ##  ## [[5]] ##       FT040 FT060 FT069  ##    29    40    60    69  ##  ## [[6]] ##       FT061 FT087  ##    31    61    87 #' Show a false positive finding featureDefinitions(mse)[iso_idx[[3]], ] ##          mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks POOL ## FT013 107.0654 107.0653 107.0656 173.2621 173.2108 173.3134      2    2 ## FT023 109.0634 109.0632 109.0636 161.6905 161.6466 161.7343      2    2 ## FT046 111.0601 111.0601 111.0601 181.0848 181.0848 181.0848      1    1 ##        peakidx ms_level ## FT013 132, 429        1 ## FT023  76, 374        1 ## FT046      140        1 featureDefinitions(mse)[iso_idx[[2]], ] ##          mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks POOL ## FT010 106.0501 106.0496 106.0506 181.2154 181.0848 181.3459      2    2 ## FT012 107.0535 107.0532 107.0538 181.2154 181.0848 181.3459      2    2 ##        peakidx ms_level ## FT010 153, 461        1 ## FT012 143, 444        1"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-visualizations","dir":"Articles","previous_headings":"Appendix","what":"Additional visualizations","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Visualization key understand signal measured MS instrument also evaluate performance (quality) preprocessing. However, LC-MS data particularly difficult visualize 3-dimensional nature. Focusing specific m/z - retention time ranges (EICs) can help, provides information small subsets whole data. section present alternative approach visualize whole chromatographic peak space LC-MS experiment. subset data first sample visualize identified chromatographic peaks m/z - retention time plane using plotChromPeaks() function used already . Position identified chromatographic peaks first sample. plot provides information region peaks identified retention time widths peaks, allow investigate peak shapes intensities. information provided (single ion) extracted ion chromatogram. thus extract ion chromatograms every identified chromatographic peak first sample. parameter expandRt = 4 increase chromatographic peak region data extracted 4 seconds either side. now simply proceed plot 356 EICs separately, instead use plotChromatogramsOverlay() function allows plot multiple EICs plot hence providing overview full set identified chromatographic peaks. setting parameter stacked value different 0 possible stack chromatograms along y-axis hence providing simple 3-dimensional impression data. easier visualization addition increase transparency colors individual lines (parameter col), identified chromatographic peaks (parameter peakCol peakBg foreground background color, respectively). identified chromatographic peaks one sample shown pseudo 3-dimensional plot. plot thus provides general overview detected signal (chromatographic peaks) data file. can immediately spot high intensity peaks, regions higher number ions also signal potential contaminants. Instead full data range can also zoom region extract EICs closer inspection data. define area m/z value 113 119 retention time 125 145 seconds. Selected region EICs extracted plotted. m/z ranges chromatographic peaks region defined, can next extract ion chromatograms data slices defined m/z ranges selected (fixed) retention time range. can now plot EICs region using plotChromatogramsOverlay() function. Next plotting data, function also silently returns y-positions individual EICs plot. assign variable y use information draw m/z EICs along y-axis. EICs selected m/z - retention time region. EICs seem represent signals isotopes (e.g. EIC 114.07 115.07). fact, can use isotopologues() function MetaboCoreUtils check whether pairs m/z intensity values match signal expected isotopes. Pairs chromatographic peaks identified potential isotopologues.","code":"#' Plot identified chromatographic peaks in the first sample mse_1 <- mse[1] plotChromPeaks(mse_1) #' Extract EICs for each identified chromatographic peak chrs_all <- chromPeakChromatograms(mse_1, expandRt = 4) #' Create a stacked EIC plot plotChromatogramsOverlay(chrs_all, stacked = 1, bty = \"n\",                          col = \"#00000020\", peakCol = \"#00000020\",                          peakBg = \"#00000020\") #' Plot location of all peaks and highlight region of interest plotChromPeaks(mse_1) rect(125, 113, 145, 119, lty = 3, border = \"#ff000080\", lwd = 2) #' Extract chrom peaks from that region pks <- chromPeaks(mse_1, mz = c(113, 119), rt = c(125, 145))  #' Extract EICs for the m/z slices of the chromatographic peaks #' and the full retention time window of the area chrs_sub <- chromatogram(mse_1, mz = pks[, c(\"mzmin\", \"mzmax\")],                          rt = cbind(rep(125, nrow(pks)),                                     rep(145, nrow(pks)))) #' Plot the EICs of the selected area y <- plotChromatogramsOverlay(chrs_sub, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\")  #' Draw horizonal lines abline(h = y[[1]], col = \"#00000020\", lty = 3) #' Add m/z values of the EICs to the plot mzs <- format(rowMeans(mz(chrs_sub)), digits = 5) text(x = rep(126, length(mzs)), y = y[[1]],      labels = paste0(\"m/z = \", mzs), pos = 1) #' Order the extracted chromatographic peaks by m/z pks <- pks[order(pks[, \"mz\"]), ]  #' Test which signals could come from isotopes isotopologues(pks[, c(\"mz\", \"into\")]) ## [[1]] ##       CP053  ##     2     3  ##  ## [[2]] ##       CP054  ##     4     5"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"bonus-material---peak-detection-fun","dir":"Articles","previous_headings":"Appendix","what":"Bonus material - peak detection fun","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"section apply lessons learned previous sections, particular adapt peak detection setting rather noisy chromatographic data. load example data text file. data two columns, one retention times one intensities. can now create Chromatogram object plot data.  two peaks present data, signal latter particularly noisy. goal now perform peak detection identify two peaks. first try default settings centWave clearly shows tune parameters (note setting sn = 0 required present data set enough background data points algorithm estimate noise level properly). parameter now adapt data? choices? Go ahead try different settings setting combination see can succeed detecting two peaks. Eventually might even try different peak detection algorithm (e.g. MatchedFilterParam).  default parameters centWave clearly failed identify two large peaks, defining smaller fragments potential peaks. Especially second peak peculiar tri-forked shape seems cause troubles. even hydrophilic liquid interaction chromatography (HILIC), known potentially result noisy odd-shaped peaks, rather unusual peak shape. fact, signal analyzing chromatographic origin:  example data represents panorama picture featuring mountains Dolomites, Paternkofel (left peak, colored red) famous Drei Zinnen (right tri-forked peak colored green).","code":"cdata <- read.table(     system.file(\"txt\", \"chromatogram.txt\", package = \"xcmsTutorials\"),     sep = \"\\t\", header = TRUE) head(cdata) ##    rt intensity ## 1 100         0 ## 2 110         0 ## 3 120         1 ## 4 130         2 ## 5 140         4 ## 6 150         6 library(MSnbase) chr <- Chromatogram(rtime = cdata$rt, intensity = cdata$intensity) par(mar = c(2, 2, 0, 0)) plot(chr) xchr <- findChromPeaks(chr, param = CentWaveParam(sn = 0)) par(mar = c(2, 2, 0, 0)) plot(xchr)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"","code":"sessionInfo() ## R version 4.5.2 (2025-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Etc/UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] RColorBrewer_1.1-3          png_0.1-8                   ##  [3] MSnbase_2.36.0              mzR_2.44.0                  ##  [5] Rcpp_1.1.0                  SummarizedExperiment_1.40.0 ##  [7] Biobase_2.70.0              GenomicRanges_1.62.1        ##  [9] Seqinfo_1.0.0               IRanges_2.44.0              ## [11] MatrixGenerics_1.22.0       matrixStats_1.5.0           ## [13] MetaboCoreUtils_1.18.1      pheatmap_1.0.13             ## [15] Spectra_1.20.0              S4Vectors_0.48.0            ## [17] BiocGenerics_0.56.0         generics_0.1.4              ## [19] MsExperiment_1.12.0         ProtGenerics_1.42.0         ## [21] xcms_4.8.0                  BiocParallel_1.44.0         ## [23] rmarkdown_2.30              knitr_1.50                  ## [25] BiocStyle_2.38.0            ##  ## loaded via a namespace (and not attached): ##  [1] DBI_1.2.3                   rlang_1.1.6                 ##  [3] magrittr_2.0.4              clue_0.3-66                 ##  [5] MassSpecWavelet_1.76.0      compiler_4.5.2              ##  [7] systemfonts_1.3.1           vctrs_0.6.5                 ##  [9] reshape2_1.4.5              stringr_1.6.0               ## [11] crayon_1.5.3                pkgconfig_2.0.3             ## [13] fastmap_1.2.0               XVector_0.50.0              ## [15] preprocessCore_1.72.0       ragg_1.5.0                  ## [17] purrr_1.2.0                 xfun_0.54                   ## [19] MultiAssayExperiment_1.36.1 cachem_1.1.0                ## [21] jsonlite_2.0.0              progress_1.2.3              ## [23] DelayedArray_0.36.0         prettyunits_1.2.0           ## [25] parallel_4.5.2              cluster_2.1.8.1             ## [27] R6_2.6.1                    bslib_0.9.0                 ## [29] stringi_1.8.7               limma_3.66.0                ## [31] jquerylib_0.1.4             iterators_1.0.14            ## [33] bookdown_0.46               BiocBaseUtils_1.12.0        ## [35] Matrix_1.7-4                igraph_2.2.1                ## [37] tidyselect_1.2.1            abind_1.4-8                 ## [39] yaml_2.3.12                 doParallel_1.0.17           ## [41] codetools_0.2-20            affy_1.88.0                 ## [43] lattice_0.22-7              tibble_3.3.0                ## [45] plyr_1.8.9                  S7_0.2.1                    ## [47] evaluate_1.0.5              desc_1.4.3                  ## [49] pillar_1.11.1               affyio_1.80.0               ## [51] BiocManager_1.30.27         foreach_1.5.2               ## [53] MALDIquant_1.22.3           ncdf4_1.24                  ## [55] hms_1.1.4                   ggplot2_4.0.1               ## [57] scales_1.4.0                glue_1.8.0                  ## [59] MsFeatures_1.18.0           lazyeval_0.2.2              ## [61] tools_4.5.2                 mzID_1.48.0                 ## [63] data.table_1.17.8           QFeatures_1.20.0            ## [65] vsn_3.78.0                  fs_1.6.6                    ## [67] XML_3.99-0.20               grid_4.5.2                  ## [69] impute_1.84.0               tidyr_1.3.1                 ## [71] MsCoreUtils_1.22.1          PSMatch_1.14.0              ## [73] cli_3.6.5                   textshaping_1.0.4           ## [75] S4Arrays_1.10.1             dplyr_1.1.4                 ## [77] AnnotationFilter_1.34.0     pcaMethods_2.2.0            ## [79] gtable_0.3.6                sass_0.4.10                 ## [81] digest_0.6.39               SparseArray_1.10.6          ## [83] htmlwidgets_1.6.4           farver_2.1.2                ## [85] htmltools_0.5.9             pkgdown_2.2.0               ## [87] lifecycle_1.0.4             statmod_1.5.1               ## [89] MASS_7.3-65"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Exploring and Analyzing LC-MS Data with Spectra and xcms","text":"Thank Philippine Louail fixing typos suggesting improvements.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Rainer. Author, maintainer. Philippine Louail. Contributor.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Johannes Rainer, & Philippine Louail. (2024). xcmsTutorials version 1.1.0: Exploring analyzing LC-MS data Spectra xcms. Zenodo. https://doi.org/10.5281/zenodo.11185521","code":"@Manual{,   title = {xcmsTutorials: Exploring and analyzing LC-MS data with Spectra and xcms},   author = {Johannes Rainer and Philippine Louail},   publisher = {Zenodo},   year = {2024},   month = {may},   version = {v1.1.0},   doi = {10.5281/zenodo.11185521},   url = {https://doi.org/10.5281/zenodo.11185521}, }"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"exploring-and-analyzing-lc-ms-data-with-spectra-and-xcms","dir":"","previous_headings":"","what":"Exploring and Analyzing LC-MS data with Spectra and xcms","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workshop provides overview recent developments Bioconductor work mass spectrometry data (MsExperiment, Spectra) specifically LC-MS data (xcms) walks preprocessing small data set emphasizing selection data-dependent settings individual preprocessing steps. Covered topics : Data import representation. Accessing, subsetting visualizing data. Centroiding profile mode MS data. Chromatographic peak detection. Empirically determine appropriate settings analyzed data set. Evaluation identified peaks. Alignment (retention time correction). Correspondence (grouping chromatographic peaks across samples). full R code examples along comprehensive descriptions provided xcms-preprocessing.Rmd file. file can opened e.g. RStudio allows execution individual R commands (see section additionally required R packages). R command rmarkdown::render(\"xcms-preprocessing.Rmd\") generate html file xcms-preprocessing.html.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workflow (future versions) deposited Zenodo. cite version tutorial: Johannes Rainer Philippine Louail. xcmsTutorials version 1.1.0: Exploring analyzing LC-MS data Spectra xcms. Zenodo, May 13, 2024. https://doi.org/10.5281/zenodo.11185521 . Louail P, Brunius C, Garcia-Aloy M, Kumler W, Storz N, Stanstrup J, Treutler H, Vangeenderhuysen P, Witting M, Neumann S, Rainer J. xcms Peak Form: Now Anchoring Complete Metabolomics Data Preprocessing Analysis Software Ecosystem. Anal Chem. 2025 Dec 8. doi: 10.1021/acs.analchem.5c04338. Epub ahead print. PMID: 41359826.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workshop files along R runtime environment including required packages RStudio (Posit) editor bundled docker container. installation, docker container can run computer code examples workshop can evaluated within environment (without need install additional packages files). version workshop uses packages Bioconductor release 3.22 (October 2025) hence bases Bioconductor’s docker container release (RELEASE_3_22). required steps installation : don’t already , install docker. Find installation information . Get docker image tutorial e.g. command line docker pull jorainer/xcms_tutorials:RELEASE_3_22. Start docker container, either Docker Desktop, command line Enter http://localhost:8787 web browser log username rstudio password bioc. RStudio server version: open R-markdown (.Rmd) files vignettes folder evaluate R code blocks document. manual installation, R version >= 4.5.0 required well recent versions packages MsExperiment, Spectra particular xcms. can installed using code :","code":"docker run \\       -e PASSWORD=bioc \\       -p 8787:8787 \\       jorainer/xcms_tutorials:RELEASE_3_22 install.packages(\"BiocManager\") BiocManager::install(\"jorainer/xcmsTutorials\",     dependencies = TRUE, ask = FALSE, update = TRUE)"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"contribution","dir":"","previous_headings":"","what":"Contribution","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"contributions, see RforMassSpectrometry contributions guideline.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"See RforMassSpectrometry Code Conduct.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"additional-documentation-resources-and-tutorials","dir":"","previous_headings":"","what":"Additional documentation resources and tutorials","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Tutorial additional examples explanations MS2-based annotations: https://jorainer.github.io/SpectraTutorials/ Repository MsCoreUtils package: https://rformassspectrometry.github.io/MsCoreUtils/ Repository MetaboCoreUtils package: https://rformassspectrometry.github.io/MetaboCoreUtils/ Repository Spectra package: https://rformassspectrometry.github.io/Spectra/ Repository MetaboAnnotation package: https://rformassspectrometry.github.io/MetaboAnnotation/ Repository CompoundDb package: https://rformassspectrometry.github.io/CompoundDb/","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Thank Philippine Louail fixing typos suggesting improvements.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.2.0","title":"xcmsTutorials 1.2","text":"Update Bioconductor release 3.22 add xcms reference.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.2","title":"xcmsTutorials 1.1","text":"Add citation information README package.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"xcmsTutorials 1.1","text":"Use spectraSampleIndex() instead old fromFile() function get sample assignments individual spectra. Add () functions descriptive text discriminate functions classes parameter names.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.0","title":"xcmsTutorials 1.1","text":"Release tutorial Zenodo: https://doi.org/10.5281/zenodo.11185521 Use Bioconductor 3.19 release docker image packages. Add examples simple quality assessment BPC BPS data. Introduce parameter ppm PeakDensityParam correspondence analysis method. Add additional section extraction chromatographic spectra data identified chromatographic peaks perform isotopologue search .","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-0","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.4","title":"xcmsTutorials 1.0","text":"Use Bioconductor 3.18 release docker image.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-0-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.3","title":"xcmsTutorials 1.0","text":"Add reference MsQuality paper.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-0-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.2","title":"xcmsTutorials 1.0","text":"Add msdata depends ensure ’s going installed.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-0-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.1","title":"xcmsTutorials 1.0","text":"Small fixes bullet points README corrections/reformulations workshop Rmd.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-1-0-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.0","title":"xcmsTutorials 1.0","text":"Restructure clarify basic data access section.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.3","title":"xcmsTutorials 0.99","text":"Finalize additional visualization paragraph.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.2","title":"xcmsTutorials 0.99","text":"Add additional visualization options. Require xcms version >= 3.99.4.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99-2","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.1","title":"xcmsTutorials 0.99","text":"Add requirements xcms Spectra packages well R version.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-2","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.2.0","title":"xcmsTutorials 0.2","text":"Rewrite parts tutorial based feedback corrections provided Philippine Louail.","code":""},{"path":[]}]
