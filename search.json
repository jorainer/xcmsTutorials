[{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"document discuss liquid chromatography (LC) mass spectrometry (MS) data handling exploration using MsExperiment r Biocpkg(\"Spectra\") Bioconductor packages perform preprocessing small LC-MS data set using xcms package. Functionality MetaboCoreUtils MsCoreUtils packages used general tasks frequently performed metabolomics data analysis. Ultimately, functionality packages can combined build custom, data set-specific (reproducible) analysis workflows. present workshop, first focus data import, access visualization followed description simple data centroiding approach finally present xcms-based LC-MS data preprocessing comprises chromatographic peak detection, alignment correspondence. Data normalization procedures, compound identification differential abundance analysis covered . Particular emphasis given deriving defining data set-dependent values critical xcms preprocessing parameters.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Preprocessing first step analysis untargeted LC-MS gas chromatography (GC)-MS data. aim preprocessing quantification signals ions measured sample, adjusting potential retention time drifts samples followed matching quantified signal across samples within experiment. resulting two-dimensional matrix abundances called LC-MS features samples can processed, e.g. normalizing data remove differences due sample processing, batch effects injection order-dependent signal drifts. LC-MS features usually characterized mass--charge ration (m/z) retention time hence need annotated actual ions metabolites represent. Data normalization annotation covered links related tutorials workshops provided end document.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"mass-spectrometry","dir":"Articles","previous_headings":"Introduction","what":"Mass spectrometry","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Mass spectrometry allows measure abundances charged molecules (ions) sample. Abundances determined ion counts specific mass--charge ratio m/z. measured signal represented spectrum: intensities along m/z.  Many ions result, measured MS alone, similar m/z. Thus, making difficult impossible discriminate . MS therefore frequently coupled second technology separate prior quantification based properties mass (e.g. based polarity). Common choices gas chromatography (GC) liquid chromatography (LC). typical LC-MS setup sample gets injected system, molecules sample separated LC column, get ionized measured (discrete time points) MS instrument (see Figure simple visualization). Molecules get thus separated two different dimensions, retention time dimension (LC) mass--charge dimension (MS) making easier measure identify molecules complex samples.  GC/LC-MS based untargeted metabolomics experiments, data analyzed along retention time dimension chromatographic peaks (supposed represent signal ions certain type molecule) quantified.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"definitions-and-common-naming-convention","dir":"Articles","previous_headings":"Introduction","what":"Definitions and common naming convention","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Naming conventions terms used document : chromatographic peak: peak containing signal ion retention time dimension (different mass peak represents signal along m/z dimension within spectrum). chromatographic peak detection: process chromatographic peaks identified within sample (file). alignment: process adjusts retention time differences (.e. possible signal drifts LC) measurements/files. correspondence: grouping chromatographic peaks (presumably ion) across samples/files. feature (LC-MS features): entity representing signal type ion/molecule, characterized specific retention time m/z. xcms, features represent identified chromatographic peaks grouped across samples/files.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-import-and-exploration","dir":"Articles","previous_headings":"","what":"Data import and exploration","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"example data set workflow consists two files mzML format signals pooled human serum samples measured ultra high performance liquid chromatography (UHPLC) system (Agilent 1290) coupled Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument. Chromatographic separation based hydrophilic interaction liquid chromatography (HILIC) separating metabolites depending polarity. input files contain signals measured MS instrument (called profile mode data). reduce file sizes, data set restricted m/z range 105 134 retention times 0 260 seconds. QC pool samples taken larger experiment injected measurement run different time points (injected position 1 19 measurement run). code block first load required libraries define location mzML files, distributed msdata R package. also define data.frame names mzML files, arbitrary sample name, index respective sample measured within LC-MS run sample group samples. generally suggested provide experiment-relevant phenotypic technical information data frame. Also, data frame defined xls sheet imported read_xlsx function readxl R package. data frame passed, along file names, readMsExperiment call import data. MS data experiment now represented MsExperiment object.","code":"library(xcms) library(MsExperiment) library(Spectra)  #' Define the file names. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)  #' Define a data.frame with additional information on these files. pd <- data.frame(file = basename(fls),                  sample = c(\"POOL_1\", \"POOL_2\"),                  injection_index = c(1, 19),                  group = \"POOL\") #' Import the data of the experiment data <- readMsExperiment(fls, sampleData = pd) data ## Object of class MsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s)."},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"basic-data-access","dir":"Articles","previous_headings":"Data import and exploration","what":"Basic data access","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"MsExperiment object manages linkage samples spectra. length MsExperiment defined number samples (files) within object. Subset MsExperiment restrict () data within object selected sample(s). restrict data second sample use: thus subsetted full data, including sample information spectra data second file. Phenotype information can retrieved sampleData function MsExperiment object. MS data stored Spectra object within MsExperiment can accessed using spectra function. new version xcms uses thus modern flexible infrastructure MS data analysis provided Spectra package. still possible supported use xcms together r Biocpkg(\"MSnbase\") package, users advised switch new infrastructure provides flexibility higher performance. Spectra object represents full LC-MS data experiment. element object spectrum (one sample/file) information provided respective original data (mzML) file. Note , additional packages MsBackendRawFileReader, also possible import MS data files mzML, mzXML CDF files. next examples briefly explain Spectra object illustrate use objects using simple examples. information Spectra objects can found package’s documentation SpectraTutorials. Besides peak data (m/z intensity values) also additional spectra variables (metadata) available Spectra object. can listed using spectraVariables function call example MS data . avoid nested function calls hence improve readability code, use R pipe operator |> allows concatenate consecutive calls readable fashion. Thus, spectra general information MS level (\"msLevel\") retention time (\"rtime\") available. spectra variables dedicated accessor functions available (msLevel, rtime) addition possible access variable using $ name variable (like accessing columns data.frame). example extract msLevel spectra variable use table function result get overview number spectra different MS levels available object. present data set contains thus 1,862 spectra, MS level 1. Spectra objects, MS spectra organized linear fashion, .e. single long list spectra. Spectra thus contains spectra data files, first spectra first file second, order provided original data files (hence generally ordered retention time). access spectra specific sample either subset MsExperiment particular sample use fromFile function returns spectrum index file within MsExperiment belongs. subset object first data file, extract retention times spectra file , using head function, display first 6 . basic data summaries can helpful first initial quality assessment potentially identify problematic data files e.g. unexpected low number spectra sparse spectra (.e. spectra mass peaks). example list number spectra per file present data set using fromFile , described , returns spectrum data set index sample/file belongs . also check number peaks per spectrum different data files. number peaks per spectrum can extracted lengths function. extract values, split file calculate quartiles peak counts using quantile function. Thus, present data set, number spectra also average number peaks per spectra comparable. Individual MS spectra can accessed subsetting Spectra object returned spectra. example subset data second sample, extract spectra sample subset spectrum number 123. m/z intensity values can extracted Spectra using mz intensity functions (always) return list numeric vectors respective values: Alternatively, peaksData function used extract m/z intensity values spectrum (two column) numeric matrix. total ion signal spectrum calculated simply summing intensities peaks spectrum. perform operation spectrum extracted . operation can also applied full data set. example calculate total ion signal spectrum first file determine distribution using quantiles function. repeat operation second file. total ion signals two data files (expected) similar. Spectra object thus possibility inspect explore (raw) MS data experiment use functionality create quality assessment functions. Alternatively, also MsQuality package calculate core MS quality metrics full experiment (MsExperiment) individual data files (Spectra). TODO: ADD REFERENCE MSQUALITY PAPER.","code":"length(data) ## [1] 2 #' Subset the data data_2 <- data[2] data_2 ## Object of class MsExperiment  ##  Spectra: MS1 (931)  ##  Experiment data: 1 sample(s) ##  Sample data links: ##   - spectra: 1 sample(s) to 931 element(s). #' Extract sample information sampleData(data_2) ## DataFrame with 1 row and 5 columns ##            file      sample injection_index       group spectraOrigin ##     <character> <character>       <numeric> <character>   <character> ## 1 20171016_P...      POOL_2              19        POOL /usr/local... #' Access the MS data spectra(data) ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML #' List available spectra variables spectra(data) |>     spectraVariables() ##  [1] \"msLevel\"                  \"rtime\"                    ##  [3] \"acquisitionNum\"           \"scanIndex\"                ##  [5] \"dataStorage\"              \"dataOrigin\"               ##  [7] \"centroided\"               \"smoothed\"                 ##  [9] \"polarity\"                 \"precScanNum\"              ## [11] \"precursorMz\"              \"precursorIntensity\"       ## [13] \"precursorCharge\"          \"collisionEnergy\"          ## [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  ## [17] \"isolationWindowUpperMz\"   \"peaksCount\"               ## [19] \"totIonCurrent\"            \"basePeakMZ\"               ## [21] \"basePeakIntensity\"        \"ionisationEnergy\"         ## [23] \"lowMZ\"                    \"highMZ\"                   ## [25] \"mergedScan\"               \"mergedResultScanNum\"      ## [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   ## [29] \"injectionTime\"            \"filterString\"             ## [31] \"spectrumId\"               \"ionMobilityDriftTime\"     ## [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\" #' List number of spectra per MS level spectra(data) |>     msLevel() |>     table() ##  ##    1  ## 1862 #' Display the first 6 retention times of spectra from the first sample data[1] |>     spectra() |>     rtime() |>     head() ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 #' Count the number of spectra per file data |>     fromFile() |>     table() ##  ##   1   2  ## 931 931 #' Get the distribution of peak counts per file spectra(data) |>     lengths() |>     split(fromFile(data)) |>     lapply(quantile) ## $`1` ##     0%    25%    50%    75%   100%  ##  456.0 1122.5 1536.0 2089.0 3995.0  ##  ## $`2` ##     0%    25%    50%    75%   100%  ##  481.0 1101.5 1557.0 2153.5 4088.0 #' Extract one spectrum from the second file sp <- spectra(data[2])[123] sp ## MSn data (Spectra) with 1 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1    34.314       123 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML #' Extract m/z values mz(sp) ## NumericList of length 1 ## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539 #' Extract intensity values intensity(sp) ## NumericList of length 1 ## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0 #' Extract the full peaks data peaksData(sp)[[1]] |> head() ##            mz intensity ## [1,] 105.9535         0 ## [2,] 105.9550       282 ## [3,] 105.9565         0 ## [4,] 105.9579       141 ## [5,] 105.9594         0 ## [6,] 106.0596         0 #' Calculate total ion signal for the extracted spectrum intensity(sp) |>     sum() ## [1] 604912 #' Calculate the distribution of total ion signal of the first file spectra(data[1]) |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   69074.0  445575.5  697201.0  897149.5 1562795.0 #' Repeat for the second file spectra(data[2]) |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   70414.0  404923.5  674512.0  878191.0 1679901.0"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-visualization","dir":"Articles","previous_headings":"Data import and exploration","what":"Data visualization","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Visualization crucial quality assessment MS data. LC-MS data visualizing base peak chromatogram (BPC) total ion chromatogram (TIC) example allow evaluate performance liquid chromatography various samples experiment. create plot extract BPC data. BPC extracts maximum peak signal spectrum data file allows thus plot information (y-axis) retention time spectrum. also extract values similarly total ion intensity previous section, use chromatogram function allows extraction chromatographic data MS data. parameter aggregationFun = \"max\" define report maximum signal per spectrum (setting aggregationFun = \"sum\" contrast sum intensities spectrum hence create TIC).  plot shows BPC two data files (line representing one sample) provides information retention times signal measured (thus retention times compounds eluted LC column). can clearly spot regions along retention time compounds eluted. Also, BPC two data files look similar, expected since represent sample pool. BPC collapsed 3-dimensional LC-MS data (m/z retention time intensity) 2 dimensions (retention time intensity). orthogonal visualization base peak spectrum (BPS) collapses data retention time dimension. visualization provide information abundant masses (rather mass--charge values) data set (regardless retention time measured). contrast BPC however straight forward create visualization: mass peaks, even representing signal ion, never identical consecutive spectra, slightly differ based measurement error/resolution instrument. plot spectra 2 consecutive scans. Spectra two consecutive scan first file two spectra now merged reporting m/z (rather peaks similar m/z consecutive spectra) maximal signal observed. Spectra, combineSpectra function allows aggregate/combine sets spectra single spectrum. default, function combine sets spectra (can defined parameter f) creating union peaks present spectra set. mass peaks similar m/z value (depending parameter ppm) peaks’ intensities aggregated using function defined parameter intensityFun one peak reported. setting combine spectra one file (using f = fromFile(data)) single spectrum containing mass peaks present spectra file. Mass peaks difference m/z smaller ppm (parts-per-million m/z value) combined one peak maximal intensity grouped peaks reported. Note set ppm rather small value present data profile mode. bps thus Spectra two spectra representing BPS two data files. plot . Base peak spectrum two samples. BPS thus show common ions present two samples. Apparently quite overlap ion content two files. Apart general data overview also possible (also suggested) explore data detail. end next focus specific subset data expect signal compound present serum samples (ions molecule serine). particular LC-MS setup used present samples, ions metabolite expected elute 180 seconds (retention time determined measuring pure standard compound LC-MS setup). thus filter spectra data using filterRt function extracting spectra measured 180 181 seconds. present data set 6 spectra measured within one second samples. extracting data Spectra object however lost now direct (inherent) association spectra samples experiment. extract name original data file data imported (see example ) use determine originating sample, involve additional R code. Alternatively, use filterRt function also directly MsExperiment subset whole MsExperiment keeping hence link samples spectra. Note however filter subset functions present available MsExperiment objects available Spectra objects. present purpose however important keep sample association intact thus proceed plot previously extracted spectra. MS1 spectra measured 180 181 seconds can immediately spot several mass peaks spectrum, largest one m/z 130 seconds second largest 106, represent signal ion Serine. calculate exact (monoisotopic) mass serine chemical formula C3H7NO3 using calculateMass function MetaboCoreUtils package. native serine molecule however uncharged can thus measured mass spectrometry. order detectable, molecules need ionized injected MS instrument. different ions can () generated molecule, one commonly generated ions positive polarity [M+H]+ ion (protonated ion). calculate m/z values specific ions/adducts molecules, can use mass2mz function, also MetaboCoreUtils package. calculate m/z [M+H]+ ion serine providing monoisotopic mass molecule specifying adduct interested . Also types adducts supported. listed adductNames function (adductNames() positively charged adductNames(\"negative\") negatively charge ions). mass2mz function always returns matrix columns reporting m/z requested adduct(s) molecule(s) available rows. Since requested single ion reduce matrix single numeric value. can now use information subset MS data signal recorded ions particular m/z. use chromatogram function provide m/z range interest mz parameter function. Note also possible first filter data set m/z using filterMzRange function extract chromatogram. Ion trace ion serine strong signal visible around retention time 180 seconds likely represents signal [M+H]+ ion serine. Note , retention time molecule specific LC-MS setup known beforehand, extracting chromatograms m/z interest full retention time range can help determining likely retention time. object returned chromatogram function arranges individual MChromatogram objects (representing chromatographic data consisting pairs retention time intensity values one sample) two-dimensional array, columns samples (files) rows data slices (.e., m/z - rt ranges). Note type data representation, defined MSnbase package, likely replaced future efficient flexible data structure similar Spectra. Data individual chromatograms can accessed using intensity rtime functions (similar mz intensity functions Spectra object). Note NA reported m/z range chromatographic data extracted intensity measured given retention time. last focus tentative signal serine extracting ion chromatogram restricting retention time range containing signal. also pass retention time m/z range parameters rt mz chromatogram function instead filter whole experiment retention time m/z calling chromatogram created data subset. example code thus create extracted ion chromatogram (EIC, sometimes also referred XIC) [M+H]+ ion serine. Extracted ion chromatogram serine. area chromatographic peak supposed proportional amount corresponding ion respective sample identification quantification peaks one goals LC-MS data preprocessing. inspected signal measured ions serine, workflow () also repeated potentially present ions (internal standards) evaluate LC-MS data experiment.","code":"#' Extract and plot a BPC bpc <- chromatogram(data, aggregationFun = \"max\") plot(bpc) plotSpectra(spectra(data)[123:124], xlim = c(105, 130)) #' Combine all spectra of one file into a single spectrum bps <- spectra(data) |>     combineSpectra(f = fromFile(data), intensityFun = max, ppm = 5) bps ## MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1     0.280         1 ## 2         1     0.275         1 ##  ... 33 more variables/columns. ## Processing: ##  Switch backend from MsBackendMzR to MsBackendMemory [Tue Sep 26 13:29:55 2023] ##  Merge 2 Spectra into one [Tue Sep 26 13:29:59 2023] #' Plot the BPS plotSpectra(bps) sps <- spectra(data) |>     filterRt(c(180, 181)) sps ## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ## 4         1   180.235       646 ## 5         1   180.514       647 ## 6         1   180.793       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Tue Sep 26 13:30:00 2023] basename(dataOrigin(sps)) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" ## [5] \"20171016_POOL_POS_3_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" #' subset the whole MsExperiment data_sub <- filterRt(data, rt = c(180, 181)) #' extract spectra from the subset for the first sample spectra(data_sub[1]) ## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Tue Sep 26 13:30:00 2023] plotSpectra(sps) library(MetaboCoreUtils) mass_serine <- calculateMass(\"C3H7NO3\") mass_serine ##  C3H7NO3  ## 105.0426 serine_mz <- mass2mz(mass_serine, \"[M+H]+\") serine_mz ##           [M+H]+ ## C3H7NO3 106.0499 serine_mz <- serine_mz[1, 1] #' Extract an full RT chromatogram for ions with an m/z similar than serine serine_chr <- chromatogram(data, mz = serine_mz + c(-0.05, 0.05)) plot(serine_chr) #' get intensity valuesfor the chromatogram of the first sample intensity(serine_chr[1, 1]) |>     head() ## [1]  NA 559 659 278 492  NA #' get the respective retention times of the first sample rtime(serine_chr[1, 1]) |>     head() ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 #' Create an EIC for serine data |> filterRt(rt = c(175, 189)) |> filterMz(mz = serine_mz + c(-0.05, 0.05)) |> chromatogram() |> plot()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"centroiding-of-profile-ms-data","dir":"Articles","previous_headings":"","what":"Centroiding of profile MS data","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"MS instruments allow export data profile centroid mode. Profile data contains signal discrete m/z values (retention times) instrument collected data (R. Smith et al. 2014). MS instruments continuously sample record signals, therefore mass peak single ion one spectrum consist multiple intensities discrete m/z values. process reduce distribution signals single representative mass peak (centroid) called centroiding. process results much smaller file sizes, little information loss. xcms, specifically centWave chromatographic peak detection algorithm, designed centroided data, thus, prior data analysis, profile data, example data used , centroided. inspect profile data one spectra extracted focus mass peak serine. Profile-mode mass peak [M+H]+ ion serine. theoretical m/z ion indicated dotted red line. Instead single peak, several mass peaks recorded MS instrument m/z close theoretical m/z [M+H]+ ion serine (indicated red dotted line). can also visualize information differently: plot function MsExperiment generates two-dimensional visualization three-dimensional LC-MS data: peaks drawn respective location two-dimensional m/z vs retention time plane intensity color coded. subset data m/z - retention time region containing signal serine visualize full MS data measured region data files. Profile data Serine. lower panel plot shows mass peaks measured instrument: point represents one mass peak intensity color coded (blue representing low, yellow high intensity). column data points represents data spectrum. upper panel plot shows chromatographic visualization data lower panel, .e., retention time (spectrum) sum intensities shown. Note , possible create plot full MS data experiment, type visualization works best small m/z - retention time regions. Next, smooth data spectrum using Savitzky-Golay filter, usually improves data quality reducing noise. Subsequently perform centroiding data based simple peak-picking strategy reports maximum signal mass peak spectrum. Finally, replace spectra data (MsExperiment) object centroided spectra visualize result repeating visualization . Centroided data Serine. impact centroiding clearly visible: signal ion spectrum reduced single data point. advanced centroiding options, can also fine-tune m/z value reported centroid, see documentation pickPeaks function centroiding vignette MSnbase package. now simply proceed data analysis, save centroided MS data mzML files also illustrate Spectra package can used export MS data. use export function data export centroided Spectra object. Parameter backend allows specify MS data backend used export, also define data format (use backend = MsBackendMzR() export data mzML format). Parameter file defines, spectrum, name file data exported. can import centroided data newly generated mzML files proceed analysis. , similar, code allow create scripts batch-perform R-based centroiding.","code":"#' Visualize the profile-mode mass peak for [M+H]+ of serine sps[1] |>     filterMzRange(c(106.02, 106.07)) |>     plotSpectra() abline(v = serine_mz, col = \"#ff000080\", lty = 3) data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() #' Smooth and centroid the spectra data sps_cent <- spectra(data) |> smooth(method = \"SavitzkyGolay\", halfWindowSize = 6L) |> pickPeaks(halfWindowSize = 2L)  #' replace spectra spectra(data) <- sps_cent  #' Plot the centroided data for Serine data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() #' Export the centroided data to new mzML files. export(spectra(data), backend = MsBackendMzR(),        file = basename(dataOrigin(spectra(data)))) #' Re-import the centroided data. fls <- basename(fls)  #' Read the centroided data. data <- readMsExperiment(fls, sampleData = pd)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-of-lc-ms-data","dir":"Articles","previous_headings":"","what":"Preprocessing of LC-MS data","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Preprocessing (untargeted) LC-MS data aims detecting quantifying signal ions generated molecules present sample. consists following 3 steps: chromatographic peak detection, alignment (also called retention time correction) correspondence (also called peak grouping). resulting matrix feature abundances can used input downstream analyses including data normalization, identification features interest annotation features metabolites.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Chromatographic peak detection","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Chromatographic peak detection aims identify peaks along retention time axis represent signal individual compounds’ ions. involves identifying quantifying signals shown sketch . peak detection can performed xcms package using findChromPeaks function. Several peak detection algorithms available can selected configured specific parameter objects: MatchedFilterParam perform peak detection described original xcms article (C. . Smith et al. 2006), CentWaveParam perform continuous wavelet transformation (CWT)-based peak detection (Tautenhahn, Böttcher, Neumann 2008) MassifquantParam perform Kalman filter-based peak detection (Conley et al. 2014). Additional peak detection algorithms direct injection data also available xcms, discussed . example use centWave algorithm performs peak detection two steps: first identifies regions interest m/z - retention time space subsequently detects peaks regions using continuous wavelet transform (see original publication (Tautenhahn, Böttcher, Neumann 2008) details). algorithm can configured several parameters (see ?CentWaveParam), important peakwidth ppm. peakwidth defines minimal maximal expected width peak retention time dimension depends thus setup employed LC-MS system making parameter highly data set dependent. ppm hand depends precision MS instrument. section describe settings parameters can empirically determined data set. Generally, strongly discouraged blindly use default parameters peak detection algorithms. illustrate extract EIC serine run centWave-based peak detection data using centWave’s default settings. peak matrix returned chromPeaks empty, thus, default settings centWave failed identify chromatographic peak EIC serine. default values shown . Particularly settings peakwidth fit data. default parameter expects chromatographic peaks 20 50 seconds wide. plot extracted ion chromatogram (EIC) serine can however see values large present data set (see ). Extracted ion chromatogram serine. serine, chromatographic peak 5 seconds wide. thus adapt peakwidth present data set repeat peak detection using settings. general, lower upper peak width set include chromatographic peak widths. present data set set values 2 10 seconds, .e., half two times expected peak width. addition, setting integrate = 2, select different peak boundary estimation algorithm. works particularly well non-gaussian peak shapes ensures also signal peak’s tail integrated (eventually re-run code default integrate = 1 compare two approaches). EIC Serine detected chromatographic peak Acceptable values parameter peakwidth can thus derived visual inspection EICs ions known present sample (e.g. internal standards). Ideally, done several compounds/ions. Tip: ensure EIC contains also enough signal left right actual chromatographic peak allow centWave properly estimate background noise. Alternatively, reduce value snthresh parameter. data set-specific peakwidth able detect peak serine (highlighted grey plot ). can now use chromPeaks function extract information identified chromatographic peaks object. result returned matrix row representing one identified chromatographic peak. retention time ranges peaks provided columns \"rtmin\" \"rtmax\", integrated peak area (.e., abundance ion) column \"\", maximal signal peak column \"maxo\" signal noise ratio column\"sn\". adapted settings thus able identify chromatographic peak serine ion two samples. second important parameter centWave ppm used initial definition regions interest (ROI) actual peak detection performed. define ROI, algorithm evaluates mass peak spectrum whether mass peak similar m/z (reasonably high intensity) also found subsequent spectrum. , mass peaks difference m/z smaller ppm consecutive scans considered. illustrate , plot full MS data data subset containing signal serine.  can observe scattering data points around m/z 105.05 lower panel plot. scattering also decreases increasing signal intensity (many MS instruments precision signal increases intensity). investigate observed differences m/z values signal serine first subset data first file restrict m/z range values 106.045 106.055. restricted MS data spectra single mass peak per spectrum (presumably representing signal serine ion). next extract m/z values peaks consecutive scans calculate absolute difference . can also express differences ppm (parts per million) average m/z peaks. difference m/z values serine data thus 0 27 ppm. maximum value used centWave’s ppm parameter. Ideally, evaluated several ions set value allows capture full chromatographic peaks tested ions. can next perform peak detection full data set using settings ppm peakwidth parameters. results form chromatographic peak detection added findChromPeaks data variable now XcmsExperiment object , extending MsExperiment class inherits functionality properties, addition contains also xcms preprocessing results. can extract results peak detection step () chromPeaks function. optional parameters rt mz allow extract peak detection results specified m/z - retention time region. example extract chromatographic peaks m/z range 106 108 retention time 150 190. , row matrix contains one identified chromatographic peak columns \"mz\", \"mzmin\", \"mzmax\", \"rt\", \"rtmin\" \"rtmax\" defining ’s position (size) m/z - rt plane \"\" \"maxo\" (integrated maximum) intensity. Column \"sample\" indicates samples (data files) peak identified. chromatographic peak table contains pairs peaks similar retention times difference m/z values one. Together observed differences intensities, indicate one peaks represents carbon 13 isotope one monoisotopic main peak. frequently observed untargeted metabolomics. general overview peak detection results can also helpful determine (eventually) plot number identified chromatographic peaks per sample. count number peaks per sample. number peaks identified, expected since files contain measurements sample (QC pool). additional visual quality assessment, can also plot location identified chromatographic peaks m/z - retention time space data file using plotChromPeaks function. Location identified chromatographic peaks m/z - rt space. , similar pattern expected present two data files. chromatographic peak detection generally good idea visually inspect individual chromatographic peaks evaluate performance peak detection step. done plotting EICs known compounds/ions data randomly selected chromatographic peaks. illustrate define matrix m/z retention time ranges set (pre)selected peaks. matrix also created either randomly selecting peaks defining manually. example expand retention time m/z ranges peaks, extract EICs chromatogram function finally plot . Identified chromatographic peaks within plotted regions default highlighted semitransparent grey color.  peak detection worked nicely signals upper row, failed define chromatographic peaks containing full signal lower row. cases, signal split separate chromatographic peaks within sample. common problem centWave noisy broad signals. either try adapt centWave settings repeat chromatographic peak detection use refineChromPeaks function allows post-process peak detection results fix problems observed (see also documentation refineChromPeaks function possible refinement options). fuse wrongly split peaks second row, use MergeNeighboringPeaksParam algorithm configure merge chromatographic peaks similar m/z less 8 seconds apart retention time axis (parameter expandRt = 4; distance tail head peaks evaluated merging thus less 2 * expandRt) signal (intensity) two peaks higher 75% smaller apex intensity two peaks (parameter minProp = 0.75). apply settings EICs evaluate result post-processing.  peak post-processing able fuse signal neighboring peaks lower panel, keeping peaks different isomers present top right plot separate. next apply peak refinement full data set.","code":"#' Get the EIC for serine in all files serine_chr <- chromatogram(data, rt = c(164, 200),                            mz = serine_mz + c(-0.05, 0.05),                            aggregationFun = \"max\")  #' Get default centWave parameters cwp <- CentWaveParam()  #' \"dry-run\" peak detection on the EIC. res <- findChromPeaks(serine_chr, param = cwp) chromPeaks(res) ##      rt rtmin rtmax into intb maxo sn row column cwp ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 25 ##  - peakwidth: [1] 20 50 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 1 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE plot(serine_chr) cwp <- CentWaveParam(peakwidth = c(2, 10), integrate = 2)  serine_chr <- findChromPeaks(serine_chr, param = cwp)  #' Plot the data and higlight identified peak area plot(serine_chr) chromPeaks(serine_chr) ##           rt   rtmin   rtmax     into     intb     maxo  sn row column ## [1,] 181.356 178.566 189.447 74443.95 71734.01 37664.94 110   1      1 ## [2,] 181.072 178.561 187.210 70352.22 69008.98 38517.76 224   1      2 #' Restrict the data to signal from Serine srn <- data |> filterRt(rt = c(179, 186)) |> filterMz(mz = c(106.04, 106.07))  #' Plot the data plot(srn) #' Reduce the data set to signal of the [M+H]+ ion of serine srn_1 <- srn[1] |>     filterMzRange(c(106.045, 106.055)) |>     spectra() lengths(srn_1) ##  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #' Calculate the difference in m/z values between scans mz_diff <- srn_1 |>     mz() |>     unlist() |>     diff() |>     abs() mz_diff ##                                     mz           mz           mz           mz  ## 2.904861e-03 4.357321e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.684509e-05 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 7.624200e-07 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.425717e-03 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00  ##           mz  ## 1.493783e-03 mz_diff * 1e6 / mean(unlist(mz(srn_1))) ##                                     mz           mz           mz           mz  ## 27.391410160 41.087396603 27.391691523  1.112566483 13.695817196  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.158840954  0.000000000  0.000000000  0.682099561  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.007189246 13.695808133 13.695808133 12.807212147  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ## 13.443812242  0.000000000 13.695807986 13.957023433  0.000000000  0.000000000  ##           mz  ## 14.085643094 #' Perform peak detection cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30, integrate = 2) data <- findChromPeaks(data, param = cwp) data ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 653 in MS level(s): 1 #' Access the peak detection results from a specific m/z - rt area chromPeaks(data, mz = c(106, 108), rt = c(150, 190)) ##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb ## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   510.5323 ## CP146 107.0653 107.0652 107.0653 173.543 171.032 179.682 11318.2801 11308.5538 ## CP156 107.0532 107.0522 107.0537 181.356 179.682 183.309  2905.1158  2899.2205 ## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73916.8683 ## CP475 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.2785 ## CP482 107.0656 107.0655 107.0657 172.980 169.632 178.003 11372.6845 11166.3372 ## CP497 107.0538 107.0510 107.0540 181.072 178.840 183.304  3155.0100  3149.2053 ## CP516 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70106.7152 ##             maxo  sn sample ## CP133   426.6084  38      1 ## CP146  4936.6783 833      1 ## CP156  1628.9510 129      1 ## CP167 37664.9371 688      1 ## CP475   381.6084  53      2 ## CP482  4569.1399  79      2 ## CP497  2297.7972 230      2 ## CP516 38517.7622 826      2 #' Count peaks per file chromPeaks(data)[, \"sample\"] |>     table() ##  ##   1   2  ## 326 327 #' Plot the location of peaks in the m/z - rt plane par(mfrow = c(1, 2)) plotChromPeaks(data, 1) plotChromPeaks(data, 2) #' Extract m/z-rt regions for selected peaks mz_rt <- chromPeaks(data)[c(\"CP172\", \"CP100\", \"CP325\", \"CP618\"),                           c(\"rtmin\", \"rtmax\", \"mzmin\", \"mzmax\")] #' Expand the rt range by 10 seconds on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 10 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 10 #' Expand the m/z range by 0.005 on both sides mz_rt[, \"mzmin\"] <- mz_rt[, \"mzmin\"] - 0.005 mz_rt[, \"mzmax\"] <- mz_rt[, \"mzmax\"] + 0.005  #' Extract the EICs eics <- chromatogram(data, rt = mz_rt[, c(\"rtmin\", \"rtmax\")],                      mz = mz_rt[, c(\"mzmin\", \"mzmax\")]) #' Plot the EICs plot(eics) #' Define the setting for the peak refinement mpp <- MergeNeighboringPeaksParam(expandRt = 4, minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = mpp)  #' Plot the result plot(eics) #' Perform peak refinement data <- refineChromPeaks(data, param = mpp)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"alignment","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Alignment","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"chromatography helps better discriminate analytes also affected variances lead shifts retention times measurement runs. differences can usually already seen base peak chromatogram total ion chromatogram. thus extract plot BPC data set. chromatogram call, set optional parameter chromPeaks = \"none\" avoid additional extraction identified chromatographic peaks. BPC files. samples measured setup measurement run, slight drifts signal visible. also already visible EIC serine, plot .  serine signal, seems retention time shift 1 second two samples. alignment step aims minimize retention time differences samples within experiment (see illustration). xcms, alignment can performed adjustRtime function one available alignment algorithms, can selected, configured, respective parameter objects: PeakGroupsParam: peakGroups (C. . Smith et al. 2006) method aligns samples based retention times set called hook peaks (housekeeping peaks) different samples experiment. peaks supposed represent signal ions expected present samples experiment method aligns samples minimizing -sample retention time differences observed peaks. ObiwarpParam: obiwarp (Prince Marcotte 2006) performs retention time adjustment based full m/z - retention time data. See documentation ObiwarpParam xcms vignette information. , default, retention time shifts estimated full data set, also possible estimate subset samples, repeatedly measured QC samples (e.g. sample pools) adjust full experiment based . See alignment section xcms vignette information subset-based alignment. Note subset-based alignment requires samples loaded order measured. example use peakGroups method , mentioned , aligns samples based retention times hook peaks (housekeeping peaks). define , need first run initial correspondence analysis group chromatographic peaks across samples. use peakDensity method correspondence. Details method explanations choices parameters provided next section. brief, parameter sampleGroups defines sample group experiment individual samples belong , parameter minFraction specifies proportion samples (one sample group) chromatographic peak needs identified (particular m/z - retention time region) group LC-MS feature. example use sample group definition sampleData data variable set minFraction = 1 requiring thus chromatographic peak identified 100% available samples define feature. Generally, correspondence performed heterogeneous samples minFraction values 0.6 0.8 used instead. Since aim initial correspondence define (presumably well separated) groups chromatographic peaks across samples, settings need fully optimized. step now grouped chromatographic peaks across samples defined called LC-MS features (simply features). can thus now run alignment using peakGroups algorithm. main parameter define hook peaks () minFraction. Similar definition , minFraction refers proportion samples chromatographic peak needs present. setting minFraction = 1 base alignment features peaks identified 100% samples data set. alignments based repeatedly measured samples (e.g. also subset-based alignment sample pools) values >= 0.9 can used. Otherwise, values 0.7 0.9 might advisable ensure reasonable set features selected. identified features used hook peaks algorithm minimizes observed -sample retention time differences . Parameter span defines degree smoothing loess function used allow different regions along retention time axis adjusted different factor. value 0 likely cause overfitting, 1 cause retention times sample shifted constant value. Values 0.4 0.6 seem reasonable experiments. alignment suggested evaluate results using plotAdjustedRtime function. function plots differences adjusted raw retention times sample y-axis along adjusted retention times x-axis (line hence representing retention time adjustment one sample/file). Points indicate position individual hook peaks along retention time axis, dotted line connecting peaks belonging feature (algorithm minimized difference retention times). Alignment results: differences raw adjusted retention times sample. rule thumb, differences raw adjusted retention times plot reasonable. Also, possible, hook peaks present along wide span retention time range, avoid need extrapolation (usually results strong adjustment). example, largest adjustments 1 2 seconds, reasonable given two samples measured measurement run. Also, features used alignment (.e. hook peaks) spread across full retention time range. evaluate impact alignment next also plot BPC alignment. similar way , set chromPeaks = \"none\" chromatogram call tell function include identified chromatographic peaks returned chromatographic data. BPC (top) (bottom) alignment. base peak chromatograms nicely aligned retention time adjustment. addition general assessment, alignment result also evaluated selected compounds (internal standards). thus plot EIC [M+H]+ ion serine alignment. EIC Serine (left) (right) alignment serine peaks also nicely aligned retention time adjustment. , advisable evaluate impact alignment several EICs, ideally also spread along retention time range. Note adjustRtime, addition retention times individual (MS1) spectra files, adjusted also retention times identified chromatographic peaks, well retention times possibly present MS2 spectra. adjusted retention times stored new spectra variable \"rtime_adjusted\" result object’s Spectra. rtime function result object default return (adjusted) values.","code":"#' Extract base peak chromatograms bpc_raw <- chromatogram(data, aggregationFun = \"max\", chromPeaks = \"none\") plot(bpc_raw, peakType = \"none\") plot(serine_chr, xlim = c(175, 190)) grid() #' Define the settings for the initial peak grouping - details for #' choices in the next section. pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 1, binSize = 0.02) data <- groupChromPeaks(data, pdp) #' Define settings for the alignment pgp <- PeakGroupsParam(minFraction = 1, span = 0.6) data <- adjustRtime(data, param = pgp) #' Plot the difference between raw and adjusted retention times plotAdjustedRtime(data) grid() par(mfrow = c(2, 1)) #' Plot the raw base peak chromatogram plot(bpc_raw) grid() #' Plot the BPC after alignment plot(chromatogram(data, aggregationFun = \"max\", chromPeaks = \"none\")) grid() par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5)) plot(serine_chr) grid() #' EIC after alignment serine_chr_adj <- chromatogram(data, rt = c(164, 200),                                mz = serine_mz + c(-0.05, 0.05),                                aggregationFun = \"max\") plot(serine_chr_adj) grid()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"correspondence","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Correspondence","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"final step LC-MS preprocessing xcms correspondence analysis, chromatographic peaks types ions (compounds) grouped across samples form called LC-MS features. xcms, correspondence performed using groupChromPeaks function. correspondence algorithm can selected configured respective parameter objects: NearestPeaksParam: performs peak grouping based proximity chromatographic peaks different samples m/z - retention time space, similar original correspondence method mzMine (Katajamaa, Miettinen, Oresic 2006). PeakDensityParam: performs simple fast correspondence analysis based density chromatographic peaks (different samples) along retention time axis within slices small m/z ranges (C. . Smith et al. 2006). methods group chromatographic peaks different samples similar m/z retention times features. example use peak density method. algorithm iterates small slices along m/z dimension groups within slice chromatographic peaks similar retention times. grouping depends distribution (density) chromatographic peaks samples along retention time axis. Peaks similar retention time result higher peak density certain retention time thus grouped together. grouping depends smoothness density curve can configured parameter bw. illustration showing chromatographic peaks within small m/z range grouped peakDensity method shown sketch . Settings algorithm can best tested optimized using plotChromPeakDensity function extracted chromatograms. extract chromatogram m/z slice containing signal [M+H]+ ion serine evaluate result peakDensity correspondence analysis using function. use default settings (bw = 30) use sample group assignment defined sampleData.  upper panel plot shows chromatographic data selected m/z slice identified peaks highlighted grey. lower panel plots retention time identified chromatographic peaks x-axis index sample peak identified. chromatographic peak thus represented point plot (x-axis value retention time y-axis value sample identified). example one chromatographic peak identified sample retention time 180 seconds two peaks thus shown. black solid line represents density estimation (.e. distribution retention times) identified chromatographic peaks along retention time axis. smoothness curve (created base R density function) configured parameter bw. peakDensity algorithm assigns chromatographic peaks within peak density estimation curve feature. Chromatographic peaks assigned feature indicated grey rectangle plot. present example, retention times two chromatographic peaks similar, rectangle narrow looks thus like vertical line. Based result, default settings (bw = 30) seemed correctly define features. however advisable evaluate settings multiple slices, ideally signal one compound present. slices identified e.g. plot created plotChromPeaks function (see example chromatographic peak detection section). example extract chromatogram m/z slice containing signal known isomers betaine valine ([M+H]+ m/z 118.08625). Correspondence analysis default settings m/z slice containing signal multiple ions. slice contains signal several ions resulting multiple chromatographic peaks along retention time axis. default settings, particular bw = 30, peaks however assigned feature (indicated grey rectangle). Signal different ions thus treated single entity. repeat analysis strongly reduced value parameter bw. Correspondence analysis reduced bw setting m/z slice containing signal multiple ions. Setting bw = 1.8 strongly reduced smoothness density curve resulting higher number density peaks hence nice grouping (aligned) chromatographic peaks separate features. Note height peaks density curve considered grouping. defined bw appropriate data set, proceed perform correspondence analysis full data set. parameters peakDensity binSize minFraction. former defines m/z widths slices along m/z dimension algorithm iterate . value depends resolution (noise) instrument, set small value, also large (avoid peaks different ions, slightly different m/z similar retention times, grouped feature). minFraction parameter (already discussed ) defines proportion samples within least one sample group chromatographic peaks need identified order define feature. example use binSize = 0.02 hence grouping chromatographic peaks, similar retention time, difference m/z smaller 0.02 feature minFraction = 0.4 thus defining features chromatographic peak identified least 50% samples per sample group. 300 features identified example data set. , suggested evaluate results selected compounds/ions. therefore extract chromatogram m/z range containing signals betaine valine. correspondence analysis also features extracted chromatogram call can show results actual correspondence analysis (based also settings used) setting simulate = FALSE plotChromPeakDensity call. Result correspondence slice containing isomers valine betaine. evaluate results also different slice containing signal ions isomers leucine isoleucine ([M+H]+ m/z 132.10191). Result correspondence slice containing isomers leucine isoleucine. Despite close, chromatographic peaks two isomers successfully grouped separate features. Even partially overlapping signal third ion eluting time hence partially overlapping peak retention time 152 seconds grouped , separate, feature. discretion data analysts define fine coarse feature grouping . Especially larger experiments, samples also larger variation retention time might always possible completely separate closely eluting ions sometimes might acceptable group single feature (keeping mind feature however represent signal different ions/compounds). Similar peak detection alignment results, also results correspondence analysis added XcmsExperiment object. can extracted featureDefinitions function, extracts definition LC-MS features featureValues function extracts numerical matrix feature abundances (samples). extract definition features display first 6 rows row defines one feature provides information ’s m/z (column \"mzmed\") retention time (column \"rtmed\"). Additional columns list number chromatographic peaks assigned feature MS level. Column \"peakidx\" provides indices chromatographic peaks chromPeaks matrix assigned feature - generally users need extract information. feature abundance matrix, final result xcms preprocessing, can extracted featureValues function. default, parameter method = \"maxint\", returns feature integrated peak signal chromatographic peak highest signal per sample. Note effect features one chromatographic peak per sample (.e., multiple chromatographic peaks sample grouped feature closeness retention time). Setting method = \"sum\" contrast sum abundances chromatographic peaks. Note method = \"sum\" suggested , like example, neighboring overlapping peaks per sample merged avoid overestimation feature abundance. extract feature abundances show first 6 rows. now use feature matrix downstream analysis. feature matrix might however, can also seen second row (feature FT002), contain missing values. represent features chromatographic peak identified one () sample(s). number imputation methods exist deal missing values, might advisable instead rescue signal. xcms provides gap filling explained next section.","code":"#' Extract a chromatogram for a m/z range containing serine chr_1 <- chromatogram(data, mz = serine_mz + c(-0.005, 0.005))  #' Default parameters for peak density; bw = 30 pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 30)  #' Test these settings on the extracted slice plotChromPeakDensity(chr_1, param = pdp) #' Plot the chromatogram for an m/z slice containing betaine and valine mzr <- 118.08625 + c(-0.01, 0.01) chr_2 <- chromatogram(data, mz = mzr, aggregationFun = \"max\")  #' Correspondence in that slice using default settings plotChromPeakDensity(chr_2, param = pdp) #' Reducing the bandwidth pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8) plotChromPeakDensity(chr_2, param = pdp) #' Set optimized settings pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 0.4, binSize = 0.02)  #' Perform the correspondence analysis data <- groupChromPeaks(data, param = pdp) data ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 595 in MS level(s): 1  ##   - adjusted retention times: mean absolute difference 0.301 seconds ##   - correspondence results: 361 features in MS level(s): 1 #' Extract chromatogram including signal for betaine and valine chr_2 <- chromatogram(data, mz = 118.08625 + c(-0.01, 0.01),                       aggregationFun = \"max\") #' Setting simulate = FALSE to show the actual correspondence results plotChromPeakDensity(chr_2, simulate = FALSE) #' Extract chromatogram with signal for isomers leucine and isoleucine chr_3 <- chromatogram(data, mz = 132.10191 + c(-0.01, 0.01),                       aggregationFun = \"max\") plotChromPeakDensity(chr_3, simulate = FALSE) #' Definition of the features featureDefinitions(data) |> head() ##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL ## FT001 105.0418 105.0417 105.0418 167.68597 167.48455 167.88740      2    2 ## FT002 105.0415 105.0415 105.0415 157.71871 157.71871 157.71871      1    1 ## FT003 105.0697 105.0691 105.0703  31.80794  31.68918  31.92670      2    2 ## FT004 105.1103 105.1100 105.1105  63.75047  63.35239  64.14855      2    2 ## FT005 105.4734 105.4732 105.4736 201.57593 201.36133 201.79053      2    2 ## FT006 105.7166 105.7160 105.7172 181.21578 181.08901 181.34256      2    2 ##        peakidx ms_level ## FT001 112, 396        1 ## FT002      111        1 ## FT003  19, 317        1 ## FT004  48, 348        1 ## FT005 260, 580        1 ## FT006 135, 444        1 #' Get abundances for the first 6 features featureValues(data, method = \"sum\") |> head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                               NA ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"gap-filling","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Gap filling","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Missing values feature matrices xcms-based preprocessing represent cases , particular sample, chromatographic peak identified m/z - retention time region feature. either represent truly missing value (ion/compound present sample) failure peak detection algorithm identify peak (either measured signal noisy, low, combination ). illustrate extract m/z - retention time region selected features, extract EICs plot (using different color sample). Examples features peak identified one sample. Indeed, feature, chromatographic peak detection failed identify peak one two samples. features upper panel, signal likely low, bottom left feature signal likely noisy, bottom right sparse (.e. data points properly detect peak). cases, however, signal (presumably) ion measured samples. Thus, reporting missing value correct cases. aim gap filling now rescue signal features integrating intensities measured within feature’s m/z - retention time area sample(s) chromatographic peak detected. xcms can done fillChromPeaks function ChromPeakAreaParam allows configure algorithm. perform gap filling summing also number missing values running fillChromPeaks. fillChromPeaks thus rescue signal 26 features. extract EICs visually inspect . Features missing values even gap-filling. features indeed signal measured second sample signal also low sample chromatographic peak detected. contrast, 4 example features signal rescued. visualize gap-filled chromatographic peaks . Features filled-signal. nice way check gap-filling able correctly rescue signals plot, features least one missing value, average detected average filled-signal. Ideally, done QC samples repeatedly measured samples difference feature abundance samples expected. code extracts first detected feature values (setting filled = FALSE featureValues call), detected filled-signal detected signal subsequently replaced NA. Finally, calculating row averages matrices (excluding missing values), values plotted . Detected (x-axis) filled (y-axis) signal. black solid line represents identity line. expected, detected signal generally higher filled-signal. biggest part (particular higher intensities), filled-detected feature values similar suggesting gap filling step indeed rescued signal.","code":"#' Extract the m/z-rt region for selected peaks mz_rt <- featureArea(data, features = c(\"FT026\", \"FT028\", \"FT246\", \"FT306\")) mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 2 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 2  #' Extract their EICs and plot them chrs <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                      rt = mz_rt[, c(\"rtmin\", \"rtmax\")]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Number of missing values sum(is.na(featureValues(data))) ## [1] 135 #' Perform gap filling data <- fillChromPeaks(data, param = ChromPeakAreaParam())  #' Number of missing values after gap filling sum(is.na(featureValues(data))) ## [1] 28 #' Identify features with missing values fts <- rownames(featureValues(data))[is.na(rowSums(featureValues(data)))]  #' Define m/z - rt regions for these features mz_rt <- featureArea(data, features = fts)  #' Expand the retention time by 1 second on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 1 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 1  chrs_na <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                         rt = mz_rt[, c(\"rtmin\", \"rtmax\")])  plot(chrs_na, col = c(\"red\", \"blue\"), lwd = 2) #' Extract the m/z-rt region for selected peaks mz_rt <- featureArea(data, features = c(\"FT026\", \"FT028\", \"FT246\", \"FT306\")) mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 2 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 2  #' Extract their EICs and plot them chrs <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                      rt = mz_rt[, c(\"rtmin\", \"rtmax\")]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Get only detected signal vals_detect <- featureValues(data, filled = FALSE) #' Get detected and filled-in signal vals_filled <- featureValues(data) #' Replace detected signal with NA vals_filled[!is.na(vals_detect)] <- NA  #' Identify features with at least one filled peak has_filled <- is.na(rowSums(vals_detect))  #' Calculate row averages avg_detect <- rowMeans(vals_detect, na.rm = TRUE) avg_filled <- rowMeans(vals_filled, na.rm = TRUE)  #' Restrict to features with at least one filled peak avg_detect <- avg_detect[has_filled] avg_filled <- avg_filled[has_filled]  #' plot the values against each other (in log2 scale) plot(log2(avg_detect), log2(avg_filled),      xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      pch = 21, bg = \"#00000080\") grid() abline(0, 1)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-result","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Preprocessing result","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"xcms preprocessing results stored within XcmsExperiment object. includes identified chromatographic peaks, alignment results well correspondence results. addition, guarantee reproducibility, result object keeps track performed processing steps contains also individual parameter objects used various preprocessing steps. can extracted processHistory function: individual parameter object can extracted follows: Thus, used preprocessing algorithms along settings reported along preprocessing results. described , values individual features can extracted result object featureValues function definition features (used initial annotation features based m/z /retention times) using featureDefinitions function. addition, XcmsExperiment result object, internal Spectra object, keeps link full MS data used analysis. downstream analyses, don’t need access MS data anymore preprocessing results represented equally well using SummarizedExperiment object, Bioconductor’s standard container large-scale omics data. xcms provides quantify function convenience function extract results XcmsExperiment result object return SummarizedExperiment. function takes parameters featureValues, internally used extract feature value matrix. sample annotations can now accessed colData function feature definitions (.e. annotation individual rows/features) rowData function: feature values stored assay within object. access simply use assay function.","code":"#' Process history processHistory(data) ## [[1]] ## Object of class \"XProcessHistory\" ##  type: Peak detection  ##  date: Tue Sep 26 13:30:15 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: CentWaveParam  ##  MS level(s) 1  ##  ## [[2]] ## Object of class \"XProcessHistory\" ##  type: Peak refinement  ##  date: Tue Sep 26 13:30:19 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: MergeNeighboringPeaksParam  ##  MS level(s) 1  ##  ## [[3]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue Sep 26 13:30:22 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[4]] ## Object of class \"XProcessHistory\" ##  type: Retention time correction  ##  date: Tue Sep 26 13:30:22 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakGroupsParam  ##  MS level(s) 1  ##  ## [[5]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Tue Sep 26 13:30:29 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[6]] ## Object of class \"XProcessHistory\" ##  type: Missing peak filling  ##  date: Tue Sep 26 13:30:34 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: ChromPeakAreaParam  ##  MS level(s) 1 #' Peak detection parameters processHistory(data)[[1]]@param ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 30 ##  - peakwidth: [1]  2 10 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 2 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE #' Extract results as a SummarizedExperiment library(SummarizedExperiment) res <- quantify(data, method = \"sum\") #' Get sample annotations colData(res) ## DataFrame with 2 rows and 5 columns ##                                           file      sample injection_index ##                                    <character> <character>       <numeric> ## 20171016_POOL_POS_1_105-134.mzML 20171016_P...      POOL_1               1 ## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19 ##                                        group spectraOrigin ##                                  <character>   <character> ## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT... ## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT... #' Get feature annotations rowData(res) ## DataFrame with 361 rows and 9 columns ##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks ##       <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> ## FT001   105.042   105.042   105.042  167.6860  167.4845  167.8874         2 ## FT002   105.042   105.042   105.042  157.7187  157.7187  157.7187         1 ## FT003   105.070   105.069   105.070   31.8079   31.6892   31.9267         2 ## FT004   105.110   105.110   105.111   63.7505   63.3524   64.1486         2 ## FT005   105.473   105.473   105.474  201.5759  201.3613  201.7905         2 ## ...         ...       ...       ...       ...       ...       ...       ... ## FT357   133.928   133.928   133.928  198.5823  198.5823  198.5823         1 ## FT358   133.960   133.960   133.961   30.8309   30.8063   30.8554         2 ## FT359   133.956   133.956   133.956  199.0661  198.9950  199.1372         2 ## FT360   133.973   133.973   133.973  206.8712  206.3899  207.3524         2 ## FT361   133.973   133.973   133.973  200.2484  200.2484  200.2484         1 ##            POOL  ms_level ##       <numeric> <integer> ## FT001         2         1 ## FT002         1         1 ## FT003         2         1 ## FT004         2         1 ## FT005         2         1 ## ...         ...       ... ## FT357         1         1 ## FT358         2         1 ## FT359         2         1 ## FT360         2         1 ## FT361         1         1 #' Get feature values assay(res) |> head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                        3183.9546 ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"what-next","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"What next?","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"preprocessing, data normalized scaled remove technical variances data. simple e.g. median scaling done lines R code also advanced (always needed) normalization algorithms available e.g. Bioconductor’s preprocessCore package. Differential abundance analysis performed using r Biocpkg(\"limma\") package packages methods available R. mentioned , many chromatographic peaks (subsequently also features) untargeted metabolomics data sets represent isotopes also different ions/adducts compound. CAMERA package aimed identify group features data set. similar feature grouping (compounding) can also done preprocessing results newer versions xcms using MsFeatures package. package enables grouping features variety different methods. See also feature grouping vignette xcms details. Finally, MetaboAnnotation provides functions assist annotation features LC-MS well LC-MS/MS experiments. allow either perform initial annotation based m/z values combination m/z retention time values. addition, also annotations based fragment spectra (available) supported (without considering addition features’ retention times. information provided MetaboAnnotation vignette MetaboAnnotation tutorial. information general MS data analysis R spectra similarity calculations can found RforMassSpectrometry book various workshops/tutorials SpectraTutorials.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"final-words","dir":"Articles","previous_headings":"","what":"Final words","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"don’t use defaults xcms. use infrastructure inspect summarize data. don’t limit just xcms, use vast number additional packages, methods, visualizations R. build custom workflows, data visualization approaches analysis method.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-visualizations","dir":"Articles","previous_headings":"Appendix","what":"Additional visualizations","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Visualization key understand signal measured MS instrument also evaluate performance (quality) preprocessing. LC-MS data particularly difficult visualize 3-dimensional nature. Focusing specific m/z retention time ranges (EICs) can help. section provide additional examples data can visualized. particular, show multiple EICs can combined single plot.  data, just “3 dimensional”       TODO: continue : plotChromPeaks extract chromatograms specific rt range full m/z. visualize stacked plot. alternative, also possible visualize two EICs combined plot using plotChromatogramsOverlay functions. allows immediate visual comparison peak shapes , isotope peaks, expected highly similar. plotChromatogramsOverlay function set stacked = 0.1 causes EICs drawn slightly shifted along y-axis (hence EICs stacked). gives little 3-dimensional impression data. plotChromatogramsOverlay also returns y-positions EIC can use draw horizontal line indicate m/z EICs.","code":"data_1 <- data[1] plotChromPeaks(data) #' Full data for rt range cpks <- chromPeaks(data_1, rt = c(20, 220), type = \"any\")  chrs_1 <- chromatogram(data_1, mz = cpks[, c(\"mzmin\", \"mzmax\")],                        rt = cbind(rep(20, nrow(cpks)),                                   rep(220, nrow(cpks))))  y <- plotChromatogramsOverlay(chrs_1, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\")  #' focus on an area, where peaks seem \"darker\" abline(v = c(130, 150), lty = 3, col = \"#ff000080\") chrs_1s <- filterRt(chrs_1, rt = c(130, 150))  y <- plotChromatogramsOverlay(chrs_1s, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\") #' Focus on an area with \"darker\" peaks. plotChromPeaks(data_1) rect(125, 113, 145, 119, lty = 3, border = \"#ff000080\") cpks <- chromPeaks(data_1, rt = c(125, 145), mz = c(113, 119)) chrs_1s <- chromatogram(data_1, mz = cpks[, c(\"mzmin\", \"mzmax\")],                         rt = cbind(rep(125, nrow(cpks)),                                    rep(145, nrow(cpks)))) y <- plotChromatogramsOverlay(chrs_1s, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\") abline(h = y[[1]], col = \"grey\") mzs <- format(rowMeans(mz(chrs_1s)), digits = 5) text(x = rep(126, length(mzs)), y = y[[1]],      labels = paste0(\"m/z = \", mzs), pos = 1) #' Focus on a whole rt range plotChromPeaks(data_1) abline(v = c(185, 210), lty = 3, col = \"#ff000080\") chrs_1s <- filterRt(chrs_1, rt = c(185, 210)) y <- plotChromatogramsOverlay(chrs_1s, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\") y <- plotChromatogramsOverlay(chrs, stacked = 0.1, bty = \"n\") abline(h = y[[1]], col = \"grey\") mzs <- format(rowMeans(mz(chrs)), digits = 5) text(x = c(175, 175), y = y[[1]],      labels = paste0(\"m/z = \", mzs), pos = 1)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"bonus-material---peak-detection-fun","dir":"Articles","previous_headings":"Appendix","what":"Bonus material - peak detection fun","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"section apply lessons learned previous sections, particular adapt peak detection setting rather noisy chromatographic data. load example data text file. data two columns, one retention times one intensities. can now create Chromatogram object plot data.  two peaks present data, signal latter particularly noisy. goal now perform peak detection identify two peaks. first try default settings centWave clearly shows tune parameters (note setting sn = 0 required present data set enough background data points algorithm estimate noise level properly). parameter now adapt data? choices? Go ahead try different settings setting combination see can succeed detecting two peaks. Eventually might even try different peak detection algorithm (e.g. MatchedFilterParam).  default parameters centWave clearly failed identify two large peaks, defining smaller fragments potential peaks. Especially second peak peculiar tri-forked shape seems cause troubles. even hydrophilic liquid interaction chromatography (HILIC), known potentially result noisy odd-shaped peaks, rather unusual peak shape. fact, signal analyzing chromatographic origin:  example data represents panorama picture featuring mountains Dolomites, Paternkofel (left peak, colored red) famous Drei Zinnen (right tri-forked peak colored green).","code":"data <- read.table(     system.file(\"txt\", \"chromatogram.txt\", package = \"xcmsTutorials\"),     sep = \"\\t\", header = TRUE) head(data) ##    rt intensity ## 1 100         0 ## 2 110         0 ## 3 120         1 ## 4 130         2 ## 5 140         4 ## 6 150         6 chr <- Chromatogram(rtime = data$rt, intensity = data$intensity) par(mar = c(2, 2, 0, 0)) plot(chr) xchr <- findChromPeaks(chr, param = CentWaveParam(sn = 0)) par(mar = c(2, 2, 0, 0)) plot(xchr)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-things","dir":"Articles","previous_headings":"","what":"Additional things","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"extract EICs two peaks using chromPeakChromatograms function. convenience function easier faster extraction EICs selected peaks (specific sample). sam data (samples) also extracted chromatogram function specifying m/z retention time range chromatographic peak. call provide IDs (row names) chromatographic peaks parameter peaks expand retention time range extract data 5 seconds (either side peak) setting expandRt = 5. next plot chromatograms. identified chromatographic peaks automatically highlighted, present, grey color.","code":"#' Extract EIC for two identified chromatographic peaks chrs <- chromPeakChromatograms(data, peaks = c(\"CP499\", \"CP520\"), expandRt = 5) plot(chrs)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"","code":"sessionInfo() ## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Etc/UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] RColorBrewer_1.1-3          png_0.1-8                   ##  [3] SummarizedExperiment_1.31.1 GenomicRanges_1.53.1        ##  [5] GenomeInfoDb_1.37.4         IRanges_2.35.2              ##  [7] MatrixGenerics_1.13.1       matrixStats_1.0.0           ##  [9] MetaboCoreUtils_1.9.2       Spectra_1.11.10             ## [11] MsExperiment_1.3.0          xcms_3.99.3                 ## [13] MSnbase_2.27.1              ProtGenerics_1.33.1         ## [15] S4Vectors_0.39.2            mzR_2.35.1                  ## [17] Rcpp_1.0.11                 Biobase_2.61.0              ## [19] BiocGenerics_0.47.0         BiocParallel_1.35.4         ## [21] rmarkdown_2.25              knitr_1.44                  ## [23] BiocStyle_2.29.2            ##  ## loaded via a namespace (and not attached): ##  [1] bitops_1.0-7                rlang_1.1.1                 ##  [3] magrittr_2.0.3              clue_0.3-65                 ##  [5] MassSpecWavelet_1.67.0      compiler_4.3.1              ##  [7] systemfonts_1.0.4           vctrs_0.6.3                 ##  [9] stringr_1.5.0               pkgconfig_2.0.3             ## [11] crayon_1.5.2                fastmap_1.1.1               ## [13] XVector_0.41.1              utf8_1.2.3                  ## [15] preprocessCore_1.63.1       ragg_1.2.5                  ## [17] purrr_1.0.2                 MultiAssayExperiment_1.27.5 ## [19] xfun_0.40                   zlibbioc_1.47.0             ## [21] cachem_1.0.8                jsonlite_1.8.7              ## [23] progress_1.2.2              DelayedArray_0.27.10        ## [25] prettyunits_1.2.0           parallel_4.3.1              ## [27] cluster_2.1.4               R6_2.5.1                    ## [29] bslib_0.5.1                 stringi_1.7.12              ## [31] limma_3.57.8                jquerylib_0.1.4             ## [33] bookdown_0.35               iterators_1.0.14            ## [35] igraph_1.5.1                splines_4.3.1               ## [37] Matrix_1.6-1.1              tidyselect_1.2.0            ## [39] abind_1.4-5                 yaml_2.3.7                  ## [41] doParallel_1.0.17           codetools_0.2-19            ## [43] affy_1.79.3                 lattice_0.21-8              ## [45] tibble_3.2.1                plyr_1.8.8                  ## [47] evaluate_0.21               survival_3.5-7              ## [49] desc_1.4.2                  pillar_1.9.0                ## [51] affyio_1.71.0               BiocManager_1.30.22         ## [53] foreach_1.5.2               MALDIquant_1.22.1           ## [55] ncdf4_1.21                  generics_0.1.3              ## [57] rprojroot_2.0.3             RCurl_1.98-1.12             ## [59] hms_1.1.3                   ggplot2_3.4.3               ## [61] munsell_0.5.0               scales_1.2.1                ## [63] glue_1.6.2                  lazyeval_0.2.2              ## [65] MsFeatures_1.9.0            tools_4.3.1                 ## [67] mzID_1.39.0                 robustbase_0.99-0           ## [69] QFeatures_1.11.2            vsn_3.69.0                  ## [71] RANN_2.6.1                  fs_1.6.3                    ## [73] XML_3.99-0.14               grid_4.3.1                  ## [75] impute_1.75.1               MsCoreUtils_1.13.1          ## [77] colorspace_2.1-0            GenomeInfoDbData_1.2.10     ## [79] cli_3.6.1                   textshaping_0.3.6           ## [81] fansi_1.0.4                 S4Arrays_1.1.6              ## [83] dplyr_1.1.3                 AnnotationFilter_1.25.0     ## [85] pcaMethods_1.93.0           gtable_0.3.4                ## [87] DEoptimR_1.1-2              sass_0.4.7                  ## [89] digest_0.6.33               SparseArray_1.1.12          ## [91] multtest_2.57.0             memoise_2.0.1               ## [93] htmltools_0.5.6             pkgdown_2.0.7               ## [95] lifecycle_1.0.3             statmod_1.5.0               ## [97] MASS_7.3-60"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Thank Philippine Louail fixing typos suggesting improvements.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Rainer. Author, maintainer. Philippine Louail. Contributor.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J (2023). xcmsTutorials: Exploring Analyzing LC-MS data Spectra xcms. R package version 0.99.1, https://jorainer.github.io/xcmsTutorials/.","code":"@Manual{,   title = {xcmsTutorials: Exploring and Analyzing LC-MS data with Spectra and xcms},   author = {Johannes Rainer},   year = {2023},   note = {R package version 0.99.1},   url = {https://jorainer.github.io/xcmsTutorials/}, }"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"exploring-and-analyzing-lc-ms-data-with-spectra-and-xcms","dir":"","previous_headings":"","what":"Exploring and Analyzing LC-MS data with Spectra and xcms","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workshop provides overview recent developments Bioconductor work mass spectrometry (MsExperiment, Spectra) specifically LC-MS data (xcms) walks preprocessing small data set emphasizing selection data-dependent settings individual pre-processing steps. present workshop represents updated version workshop given Metabolomics Society conference 2018 Seattle (http://metabolomics2018.org). Covered topics : - Data import representation. - Accessing, subsetting visualizing data. - Centroiding profile mode MS data. - Chromatographic peak detection. - Empirically determine appropriate settings analyzed data set. - Evaluation identified peaks. - Alignment (retention time correction). - Correspondence (grouping chromatographic peaks across samples). full R code examples along comprehensive descriptions provided xcms-preprocessing.Rmd file. file can opened e.g. RStudio allows execution individual R commands (see section additionally required R packages). R command rmarkdown::render(\"xcms-preprocessing.Rmd\") generate html file xcms-preprocessing.html.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"-line code evaluation, workshop can also run using self-contained docker image R packages server version RStudio (Posit) pre-installed: Get docker image tutorial docker pull jorainer/xcms_tutorials:latest. Start docker using Enter http://localhost:8787 web browser log username rstudio password bioc. RStudio server version: open R-markdown (.Rmd) files vignettes folder evaluate R code blocks. manual installation, R version >= 4.3.0 required well recent versions packages MsExperiment, Spectra particular xcms (version >= 3.99.0 needed). can installed using code :","code":"docker run \\     -e PASSWORD=bioc \\     -p 8787:8787 \\     jorainer/xcms_tutorials:latest install.packages(\"BiocManager\") BiocManager::install(\"jorainer/xcmsTutorials\",     dependencies = TRUE, ask = FALSE, update = TRUE)"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"additional-documentation-resources-and-tutorials","dir":"","previous_headings":"","what":"Additional documentation resources and tutorials","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Tutorial additional examples explanations MS2-based annotations: https://jorainer.github.io/SpectraTutorials/ Repository MsCoreUtils package: https://rformassspectrometry.github.io/MsCoreUtils/ Repository MetaboCoreUtils package: https://rformassspectrometry.github.io/MetaboCoreUtils/ Repository Spectra package: https://rformassspectrometry.github.io/Spectra/ Repository MetaboAnnotation package: https://rformassspectrometry.github.io/MetaboAnnotation/ Repository CompoundDb package: https://rformassspectrometry.github.io/CompoundDb/","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.1","title":"xcmsTutorials 0.99","text":"Add requirements xcms Spectra packages well R version.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-2","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.2.0","title":"xcmsTutorials 0.2","text":"Rewrite parts tutorial based feedback corrections provided Philippine Louail.","code":""},{"path":[]}]
