[{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"document discuss liquid chromatography (LC) mass spectrometry (MS) data handling exploration using MsExperiment r Biocpkg(\"Spectra\") Bioconductor packages perform preprocessing small LC-MS data set using xcms package. Functionality MetaboCoreUtils MsCoreUtils packages used general tasks frequently performed metabolomics data analysis. Ultimately, functionality packages can combined build custom, data set-specific (reproducible) analysis workflows. present workshop, first focus data import, access visualization followed description simple data centroiding approach finally present xcms-based LC-MS data preprocessing comprises chromatographic peak detection, alignment correspondence. Data normalization procedures, compound identification differential abundance analysis covered . Particular emphasis given deriving defining data set-dependent values critical xcms preprocessing parameters.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Preprocessing first step analysis untargeted LC-MS gas chromatography (GC)-MS data. aim preprocessing quantification signals ions measured sample, adjusting potential retention time drifts samples followed matching quantified signal across samples within experiment. resulting two-dimensional matrix abundances called LC-MS features samples can processed, e.g. normalizing data remove differences due sample processing, batch effects injection order-dependent signal drifts. LC-MS features usually characterized mass--charge ration (m/z) retention time hence need annotated actual ions metabolites represent. Data normalization annotation covered links related tutorials workshops provided end document.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"mass-spectrometry","dir":"Articles","previous_headings":"Introduction","what":"Mass spectrometry","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Mass spectrometry allows measure abundances charged molecules (ions) sample. Abundances determined ion counts specific mass--charge ratio m/z. measured signal represented spectrum: intensities along m/z.  Many ions result, measured MS alone, similar m/z. Thus, making difficult impossible discriminate . MS therefore frequently coupled second technology separate prior quantification based properties mass (e.g. based polarity). Common choices gas chromatography (GC) liquid chromatography (LC). typical LC-MS setup sample gets injected system, molecules sample separated LC column, get ionized measured (discrete time points) MS instrument (see Figure simple visualization). Molecules get thus separated two different dimensions, retention time dimension (LC) mass--charge dimension (MS) making easier measure identify molecules complex samples.  GC/LC-MS based untargeted metabolomics experiments, data analyzed along retention time dimension chromatographic peaks (supposed represent signal ions certain type molecule) quantified.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"definitions-and-common-naming-convention","dir":"Articles","previous_headings":"Introduction","what":"Definitions and common naming convention","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Naming conventions terms used document : chromatographic peak: peak containing signal ion retention time dimension (different mass peak represents signal along m/z dimension within spectrum). chromatographic peak detection: process chromatographic peaks identified within sample (file). alignment: process adjusts retention time differences (.e. possible signal drifts LC) measurements/files. correspondence: grouping chromatographic peaks (presumably ion) across samples/files. feature (LC-MS features): entity representing signal type ion/molecule, characterized specific retention time m/z. xcms, features represent identified chromatographic peaks grouped across samples/files.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-import-and-exploration","dir":"Articles","previous_headings":"","what":"Data import and exploration","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"example data set workflow consists two files mzML format signals pooled human serum samples measured ultra high performance liquid chromatography (UHPLC) system (Agilent 1290) coupled Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument. Chromatographic separation based hydrophilic interaction liquid chromatography (HILIC) separating metabolites depending polarity. input files contain signals measured MS instrument (called profile mode data). reduce file sizes, data set restricted m/z range 105 134 retention times 0 260 seconds. QC pool samples taken larger experiment injected measurement run different time points (injected position 1 19 measurement run). code block first load required libraries define location mzML files, distributed msdata R package. also define data.frame names mzML files, arbitrary sample name, index respective sample measured within LC-MS run sample group samples. generally suggested provide experiment-relevant phenotypic technical information data frame. Also, data frame defined xls sheet imported read_xlsx function readxl R package. data frame passed, along file names, readMsExperiment call import data. MS data experiment now represented MsExperiment object.","code":"library(xcms) library(MsExperiment) library(Spectra)  #' Define the file names. fls <- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)  #' Define a data.frame with additional information on these files. pd <- data.frame(file = basename(fls),                  sample = c(\"POOL_1\", \"POOL_2\"),                  injection_index = c(1, 19),                  group = \"POOL\") #' Import the data of the experiment data <- readMsExperiment(fls, sampleData = pd) data ## Object of class MsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s)."},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"basic-data-access","dir":"Articles","previous_headings":"Data import and exploration","what":"Basic data access","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"MsExperiment object manages linkage samples spectra. length MsExperiment defined number samples (files) within object. Subset MsExperiment restrict () data within object selected sample(s). restrict data second sample use: thus subsetted full data, including sample information spectra data second file. Phenotype information can retrieved sampleData function MsExperiment object. MS data stored Spectra object within MsExperiment can accessed using spectra function. new version xcms uses thus modern flexible infrastructure MS data analysis provided Spectra package. still possible supported use xcms together r Biocpkg(\"MSnbase\") package, users advised switch new infrastructure provides flexibility higher performance. Spectra object represents full LC-MS data experiment. element object spectrum (one sample/file) information provided respective original data (mzML) file. Note , additional packages MsBackendRawFileReader, also possible import MS data files mzML, mzXML CDF files. next examples briefly explain Spectra object illustrate use objects using simple examples. information Spectra objects can found package’s documentation SpectraTutorials. Besides peak data (m/z intensity values) also additional spectra variables (metadata) available Spectra object. can listed using spectraVariables function call example MS data . avoid nested function calls hence improve readability code, use R pipe operator |> allows concatenate consecutive calls readable fashion. Thus, spectra general information MS level (\"msLevel\") retention time (\"rtime\") available. spectra variables dedicated accessor functions available (msLevel, rtime) addition possible access variable using $ name variable (like accessing columns data.frame). example extract msLevel spectra variable use table function result get overview number spectra different MS levels available object. present data set contains thus 1,862 spectra, MS level 1. Spectra objects, MS spectra organized linear fashion, .e. single long list spectra. Spectra thus contains spectra data files, first spectra first file second, order provided original data files (hence generally ordered retention time). access spectra specific sample either subset MsExperiment particular sample use fromFile function returns spectrum index file within MsExperiment belongs. subset object first data file, extract retention times spectra file , using head function, display first 6 . basic data summaries can helpful first initial quality assessment potentially identify problematic data files e.g. unexpected low number spectra sparse spectra (.e. spectra mass peaks). example list number spectra per file present data set using fromFile , described , returns spectrum data set index sample/file belongs . also check number peaks per spectrum different data files. number peaks per spectrum can extracted lengths function. extract values, split file calculate quartiles peak counts using quantile function. Thus, present data set, number spectra also average number peaks per spectra comparable. Individual MS spectra can accessed subsetting Spectra object returned spectra. example subset data second sample, extract spectra sample subset spectrum number 123. m/z intensity values can extracted Spectra using mz intensity functions (always) return list numeric vectors respective values: Alternatively, peaksData function used extract m/z intensity values spectrum (two column) numeric matrix. total ion signal spectrum calculated simply summing intensities peaks spectrum. perform operation spectrum extracted . operation can also applied full data set. example calculate total ion signal spectrum first file determine distribution using quantiles function. repeat operation second file. total ion signals two data files (expected) similar. Spectra object thus possibility inspect explore (raw) MS data experiment use functionality create quality assessment functions. Alternatively, also MsQuality package calculate core MS quality metrics full experiment (MsExperiment) individual data files (Spectra). TODO: ADD REFERENCE MSQUALITY PAPER.","code":"length(data) ## [1] 2 #' Subset the data data_2 <- data[2] data_2 ## Object of class MsExperiment  ##  Spectra: MS1 (931)  ##  Experiment data: 1 sample(s) ##  Sample data links: ##   - spectra: 1 sample(s) to 931 element(s). #' Extract sample information sampleData(data_2) ## DataFrame with 1 row and 5 columns ##            file      sample injection_index       group spectraOrigin ##     <character> <character>       <numeric> <character>   <character> ## 1 20171016_P...      POOL_2              19        POOL /usr/local... #' Access the MS data spectra(data) ## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend: ##        msLevel     rtime scanIndex ##      <integer> <numeric> <integer> ## 1            1     0.280         1 ## 2            1     0.559         2 ## 3            1     0.838         3 ## 4            1     1.117         4 ## 5            1     1.396         5 ## ...        ...       ...       ... ## 1858         1   258.636       927 ## 1859         1   258.915       928 ## 1860         1   259.194       929 ## 1861         1   259.473       930 ## 1862         1   259.752       931 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML #' List available spectra variables spectra(data) |>     spectraVariables() ##  [1] \"msLevel\"                  \"rtime\"                    ##  [3] \"acquisitionNum\"           \"scanIndex\"                ##  [5] \"dataStorage\"              \"dataOrigin\"               ##  [7] \"centroided\"               \"smoothed\"                 ##  [9] \"polarity\"                 \"precScanNum\"              ## [11] \"precursorMz\"              \"precursorIntensity\"       ## [13] \"precursorCharge\"          \"collisionEnergy\"          ## [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\"  ## [17] \"isolationWindowUpperMz\"   \"peaksCount\"               ## [19] \"totIonCurrent\"            \"basePeakMZ\"               ## [21] \"basePeakIntensity\"        \"ionisationEnergy\"         ## [23] \"lowMZ\"                    \"highMZ\"                   ## [25] \"mergedScan\"               \"mergedResultScanNum\"      ## [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"   ## [29] \"injectionTime\"            \"filterString\"             ## [31] \"spectrumId\"               \"ionMobilityDriftTime\"     ## [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\" #' List number of spectra per MS level spectra(data) |>     msLevel() |>     table() ##  ##    1  ## 1862 #' Display the first 6 retention times of spectra from the first sample data[1] |>     spectra() |>     rtime() |>     head() ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 #' Count the number of spectra per file data |>     fromFile() |>     table() ##  ##   1   2  ## 931 931 #' Get the distribution of peak counts per file spectra(data) |>     lengths() |>     split(fromFile(data)) |>     lapply(quantile) ## $`1` ##     0%    25%    50%    75%   100%  ##  456.0 1122.5 1536.0 2089.0 3995.0  ##  ## $`2` ##     0%    25%    50%    75%   100%  ##  481.0 1101.5 1557.0 2153.5 4088.0 #' Extract one spectrum from the second file sp <- spectra(data[2])[123] sp ## MSn data (Spectra) with 1 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1    34.314       123 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_3_105-134.mzML #' Extract m/z values mz(sp) ## NumericList of length 1 ## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539 #' Extract intensity values intensity(sp) ## NumericList of length 1 ## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0 #' Extract the full peaks data peaksData(sp)[[1]] |> head() ##            mz intensity ## [1,] 105.9535         0 ## [2,] 105.9550       282 ## [3,] 105.9565         0 ## [4,] 105.9579       141 ## [5,] 105.9594         0 ## [6,] 106.0596         0 #' Calculate total ion signal for the extracted spectrum intensity(sp) |>     sum() ## [1] 604912 #' Calculate the distribution of total ion signal of the first file spectra(data[1]) |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   69074.0  445575.5  697201.0  897149.5 1562795.0 #' Repeat for the second file spectra(data[2]) |>     intensity() |>     sum() |>     quantile() ##        0%       25%       50%       75%      100%  ##   70414.0  404923.5  674512.0  878191.0 1679901.0"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"data-visualization","dir":"Articles","previous_headings":"Data import and exploration","what":"Data visualization","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Visualization crucial quality assessment MS data. LC-MS data visualizing base peak chromatogram (BPC) total ion chromatogram (TIC) example allow evaluate performance liquid chromatography various samples experiment. create plot extract BPC data. BPC extracts maximum peak signal spectrum data file allows thus plot information (y-axis) retention time spectrum. also extract values similarly total ion intensity previous section, use chromatogram function allows extraction chromatographic data MS data. parameter aggregationFun = \"max\" define report maximum signal per spectrum (setting aggregationFun = \"sum\" contrast sum intensities spectrum hence create TIC).  plot shows BPC two data files (line representing one sample) provides information retention times signal measured (thus retention times compounds eluted LC column). can clearly spot regions along retention time compounds eluted. Also, BPC two data files look similar, expected since represent sample pool. BPC collapsed 3-dimensional LC-MS data (m/z retention time intensity) 2 dimensions (retention time intensity). orthogonal visualization base peak spectrum (BPS) collapses data retention time dimension. visualization provide information abundant masses (rather mass--charge values) data set (regardless retention time measured). contrast BPC however straight forward create visualization: mass peaks, even representing signal ion, never identical consecutive spectra, slightly differ based measurement error/resolution instrument. plot spectra 2 consecutive scans. Spectra two consecutive scan first file two spectra now merged reporting m/z (rather peaks similar m/z consecutive spectra) maximal signal observed. Spectra, combineSpectra function allows aggregate/combine sets spectra single spectrum. default, function combine sets spectra (can defined parameter f) creating union peaks present spectra set. mass peaks similar m/z value (depending parameter ppm) peaks’ intensities aggregated using function defined parameter intensityFun one peak reported. setting combine spectra one file (using f = fromFile(data)) single spectrum containing mass peaks present spectra file. Mass peaks difference m/z smaller ppm (parts-per-million m/z value) combined one peak maximal intensity grouped peaks reported. Note set ppm rather small value present data profile mode. bps thus Spectra two spectra representing BPS two data files. plot . Base peak spectrum two samples. BPS thus show common ions present two samples. Apparently quite overlap ion content two files. Apart general data overview also possible (also suggested) explore data detail. end next focus specific subset data expect signal compound present serum samples (ions molecule serine). particular LC-MS setup used present samples, ions metabolite expected elute 180 seconds (retention time determined measuring pure standard compound LC-MS setup). thus filter spectra data using filterRt function extracting spectra measured 180 181 seconds. present data set 6 spectra measured within one second samples. extracting data Spectra object however lost now direct (inherent) association spectra samples experiment. extract name original data file data imported (see example ) use determine originating sample, involve additional R code. Alternatively, use filterRt function also directly MsExperiment subset whole MsExperiment keeping hence link samples spectra. Note however filter subset functions present available MsExperiment objects available Spectra objects. present purpose however important keep sample association intact thus proceed plot previously extracted spectra. MS1 spectra measured 180 181 seconds can immediately spot several mass peaks spectrum, largest one m/z 130 seconds second largest 106, represent signal ion Serine. calculate exact (monoisotopic) mass serine chemical formula C3H7NO3 using calculateMass function MetaboCoreUtils package. native serine molecule however uncharged can thus measured mass spectrometry. order detectable, molecules need ionized injected MS instrument. different ions can () generated molecule, one commonly generated ions positive polarity [M+H]+ ion (protonated ion). calculate m/z values specific ions/adducts molecules, can use mass2mz function, also MetaboCoreUtils package. calculate m/z [M+H]+ ion serine providing monoisotopic mass molecule specifying adduct interested . Also types adducts supported. listed adductNames function (adductNames() positively charged adductNames(\"negative\") negatively charge ions). mass2mz function always returns matrix columns reporting m/z requested adduct(s) molecule(s) available rows. Since requested single ion reduce matrix single numeric value. can now use information subset MS data signal recorded ions particular m/z. use chromatogram function provide m/z range interest mz parameter function. Note also possible first filter data set m/z using filterMzRange function extract chromatogram. Ion trace ion serine strong signal visible around retention time 180 seconds likely represents signal [M+H]+ ion serine. Note , retention time molecule specific LC-MS setup known beforehand, extracting chromatograms m/z interest full retention time range can help determining likely retention time. object returned chromatogram function arranges individual MChromatogram objects (representing chromatographic data consisting pairs retention time intensity values one sample) two-dimensional array, columns samples (files) rows data slices (.e., m/z - rt ranges). Note type data representation, defined MSnbase package, likely replaced future efficient flexible data structure similar Spectra. Data individual chromatograms can accessed using intensity rtime functions (similar mz intensity functions Spectra object). Note NA reported m/z range chromatographic data extracted intensity measured given retention time. last focus tentative signal serine extracting ion chromatogram restricting retention time range containing signal. also pass retention time m/z range parameters rt mz chromatogram function instead filter whole experiment retention time m/z calling chromatogram created data subset. example code thus create extracted ion chromatogram (EIC, sometimes also referred XIC) [M+H]+ ion serine. Extracted ion chromatogram serine. area chromatographic peak supposed proportional amount corresponding ion respective sample identification quantification peaks one goals LC-MS data preprocessing. inspected signal measured ions serine, workflow () also repeated potentially present ions (internal standards) evaluate LC-MS data experiment.","code":"#' Extract and plot a BPC bpc <- chromatogram(data, aggregationFun = \"max\") plot(bpc) plotSpectra(spectra(data)[123:124], xlim = c(105, 130)) #' Combine all spectra of one file into a single spectrum bps <- spectra(data) |>     combineSpectra(f = fromFile(data), intensityFun = max, ppm = 5) bps ## MSn data (Spectra) with 2 spectra in a MsBackendMemory backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1     0.280         1 ## 2         1     0.275         1 ##  ... 33 more variables/columns. ## Processing: ##  Switch backend from MsBackendMzR to MsBackendMemory [Wed Sep 27 07:52:35 2023] ##  Switch backend from MsBackendMzR to MsBackendMemory [Wed Sep 27 07:52:37 2023] ##  Merge 2 Spectra into one [Wed Sep 27 07:52:39 2023] #' Plot the BPS plotSpectra(bps) sps <- spectra(data) |>     filterRt(c(180, 181)) sps ## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ## 4         1   180.235       646 ## 5         1   180.514       647 ## 6         1   180.793       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## 20171016_POOL_POS_3_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Wed Sep 27 07:52:40 2023] basename(dataOrigin(sps)) ## [1] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_1_105-134.mzML\" ## [3] \"20171016_POOL_POS_1_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" ## [5] \"20171016_POOL_POS_3_105-134.mzML\" \"20171016_POOL_POS_3_105-134.mzML\" #' subset the whole MsExperiment data_sub <- filterRt(data, rt = c(180, 181)) #' extract spectra from the subset for the first sample spectra(data_sub[1]) ## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend: ##     msLevel     rtime scanIndex ##   <integer> <numeric> <integer> ## 1         1   180.240       646 ## 2         1   180.519       647 ## 3         1   180.798       648 ##  ... 33 more variables/columns. ##  ## file(s): ## 20171016_POOL_POS_1_105-134.mzML ## Processing: ##  Filter: select retention time [180..181] on MS level(s) 1 [Wed Sep 27 07:52:40 2023] plotSpectra(sps) library(MetaboCoreUtils) mass_serine <- calculateMass(\"C3H7NO3\") mass_serine ##  C3H7NO3  ## 105.0426 serine_mz <- mass2mz(mass_serine, \"[M+H]+\") serine_mz ##           [M+H]+ ## C3H7NO3 106.0499 serine_mz <- serine_mz[1, 1] #' Extract an full RT chromatogram for ions with an m/z similar than serine serine_chr <- chromatogram(data, mz = serine_mz + c(-0.05, 0.05)) plot(serine_chr) #' get intensity valuesfor the chromatogram of the first sample intensity(serine_chr[1, 1]) |>     head() ## [1]  NA 559 659 278 492  NA #' get the respective retention times of the first sample rtime(serine_chr[1, 1]) |>     head() ## [1] 0.280 0.559 0.838 1.117 1.396 1.675 #' Create an EIC for serine data |> filterRt(rt = c(175, 189)) |> filterMz(mz = serine_mz + c(-0.05, 0.05)) |> chromatogram() |> plot()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"centroiding-of-profile-ms-data","dir":"Articles","previous_headings":"","what":"Centroiding of profile MS data","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"MS instruments allow export data profile centroid mode. Profile data contains signal discrete m/z values (retention times) instrument collected data (R. Smith et al. 2014). MS instruments continuously sample record signals, therefore mass peak single ion one spectrum consist multiple intensities discrete m/z values. process reduce distribution signals single representative mass peak (centroid) called centroiding. process results much smaller file sizes, little information loss. xcms, specifically centWave chromatographic peak detection algorithm, designed centroided data, thus, prior data analysis, profile data, example data used , centroided. inspect profile data one spectra extracted focus mass peak serine. Profile-mode mass peak [M+H]+ ion serine. theoretical m/z ion indicated dotted red line. Instead single peak, several mass peaks recorded MS instrument m/z close theoretical m/z [M+H]+ ion serine (indicated red dotted line). can also visualize information differently: plot function MsExperiment generates two-dimensional visualization three-dimensional LC-MS data: peaks drawn respective location two-dimensional m/z vs retention time plane intensity color coded. subset data m/z - retention time region containing signal serine visualize full MS data measured region data files. Profile data Serine. lower panel plot shows mass peaks measured instrument: point represents one mass peak intensity color coded (blue representing low, yellow high intensity). column data points represents data spectrum. upper panel plot shows chromatographic visualization data lower panel, .e., retention time (spectrum) sum intensities shown. Note , possible create plot full MS data experiment, type visualization works best small m/z - retention time regions. Next, smooth data spectrum using Savitzky-Golay filter, usually improves data quality reducing noise. Subsequently perform centroiding data based simple peak-picking strategy reports maximum signal mass peak spectrum. Finally, replace spectra data (MsExperiment) object centroided spectra visualize result repeating visualization . Centroided data Serine. impact centroiding clearly visible: signal ion spectrum reduced single data point. advanced centroiding options, can also fine-tune m/z value reported centroid, see documentation pickPeaks function centroiding vignette MSnbase package. now simply proceed data analysis, save centroided MS data mzML files also illustrate Spectra package can used export MS data. use export function data export centroided Spectra object. Parameter backend allows specify MS data backend used export, also define data format (use backend = MsBackendMzR() export data mzML format). Parameter file defines, spectrum, name file data exported. can import centroided data newly generated mzML files proceed analysis. , similar, code allow create scripts batch-perform R-based centroiding.","code":"#' Visualize the profile-mode mass peak for [M+H]+ of serine sps[1] |>     filterMzRange(c(106.02, 106.07)) |>     plotSpectra() abline(v = serine_mz, col = \"#ff000080\", lty = 3) data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() #' Smooth and centroid the spectra data sps_cent <- spectra(data) |> smooth(method = \"SavitzkyGolay\", halfWindowSize = 6L) |> pickPeaks(halfWindowSize = 2L)  #' replace spectra spectra(data) <- sps_cent  #' Plot the centroided data for Serine data |> filterRt(rt = c(175, 189)) |> filterMz(mz = c(106.02, 106.07)) |> plot() #' Export the centroided data to new mzML files. export(spectra(data), backend = MsBackendMzR(),        file = basename(dataOrigin(spectra(data)))) #' Re-import the centroided data. fls <- basename(fls)  #' Read the centroided data. data <- readMsExperiment(fls, sampleData = pd)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-of-lc-ms-data","dir":"Articles","previous_headings":"","what":"Preprocessing of LC-MS data","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Preprocessing (untargeted) LC-MS data aims detecting quantifying signal ions generated molecules present sample. consists following 3 steps: chromatographic peak detection, alignment (also called retention time correction) correspondence (also called peak grouping). resulting matrix feature abundances can used input downstream analyses including data normalization, identification features interest annotation features metabolites.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Chromatographic peak detection","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Chromatographic peak detection aims identify peaks along retention time axis represent signal individual compounds’ ions. involves identifying quantifying signals shown sketch . peak detection can performed xcms package using findChromPeaks function. Several peak detection algorithms available can selected configured specific parameter objects: MatchedFilterParam perform peak detection described original xcms article (C. . Smith et al. 2006), CentWaveParam perform continuous wavelet transformation (CWT)-based peak detection (Tautenhahn, Böttcher, Neumann 2008) MassifquantParam perform Kalman filter-based peak detection (Conley et al. 2014). Additional peak detection algorithms direct injection data also available xcms, discussed . example use centWave algorithm performs peak detection two steps: first identifies regions interest m/z - retention time space subsequently detects peaks regions using continuous wavelet transform (see original publication (Tautenhahn, Böttcher, Neumann 2008) details). algorithm can configured several parameters (see ?CentWaveParam), important peakwidth ppm. peakwidth defines minimal maximal expected width peak retention time dimension depends thus setup employed LC-MS system making parameter highly data set dependent. ppm hand depends precision MS instrument. section describe settings parameters can empirically determined data set. Generally, strongly discouraged blindly use default parameters peak detection algorithms. illustrate extract EIC serine run centWave-based peak detection data using centWave’s default settings. peak matrix returned chromPeaks empty, thus, default settings centWave failed identify chromatographic peak EIC serine. default values shown . Particularly settings peakwidth fit data. default parameter expects chromatographic peaks 20 50 seconds wide. plot extracted ion chromatogram (EIC) serine can however see values large present data set (see ). Extracted ion chromatogram serine. serine, chromatographic peak 5 seconds wide. thus adapt peakwidth present data set repeat peak detection using settings. general, lower upper peak width set include chromatographic peak widths. present data set set values 2 10 seconds, .e., half two times expected peak width. addition, setting integrate = 2, select different peak boundary estimation algorithm. works particularly well non-gaussian peak shapes ensures also signal peak’s tail integrated (eventually re-run code default integrate = 1 compare two approaches). EIC Serine detected chromatographic peak Acceptable values parameter peakwidth can thus derived visual inspection EICs ions known present sample (e.g. internal standards). Ideally, done several compounds/ions. Tip: ensure EIC contains also enough signal left right actual chromatographic peak allow centWave properly estimate background noise. Alternatively, reduce value snthresh parameter. data set-specific peakwidth able detect peak serine (highlighted grey plot ). can now use chromPeaks function extract information identified chromatographic peaks object. result returned matrix row representing one identified chromatographic peak. retention time ranges peaks provided columns \"rtmin\" \"rtmax\", integrated peak area (.e., abundance ion) column \"\", maximal signal peak column \"maxo\" signal noise ratio column\"sn\". adapted settings thus able identify chromatographic peak serine ion two samples. second important parameter centWave ppm used initial definition regions interest (ROI) actual peak detection performed. define ROI, algorithm evaluates mass peak spectrum whether mass peak similar m/z (reasonably high intensity) also found subsequent spectrum. , mass peaks difference m/z smaller ppm consecutive scans considered. illustrate , plot full MS data data subset containing signal serine.  can observe scattering data points around m/z 105.05 lower panel plot. scattering also decreases increasing signal intensity (many MS instruments precision signal increases intensity). investigate observed differences m/z values signal serine first subset data first file restrict m/z range values 106.045 106.055. restricted MS data spectra single mass peak per spectrum (presumably representing signal serine ion). next extract m/z values peaks consecutive scans calculate absolute difference . can also express differences ppm (parts per million) average m/z peaks. difference m/z values serine data thus 0 27 ppm. maximum value used centWave’s ppm parameter. Ideally, evaluated several ions set value allows capture full chromatographic peaks tested ions. can next perform peak detection full data set using settings ppm peakwidth parameters. results form chromatographic peak detection added findChromPeaks data variable now XcmsExperiment object , extending MsExperiment class inherits functionality properties, addition contains also xcms preprocessing results. can extract results peak detection step () chromPeaks function. optional parameters rt mz allow extract peak detection results specified m/z - retention time region. example extract chromatographic peaks m/z range 106 108 retention time 150 190. , row matrix contains one identified chromatographic peak columns \"mz\", \"mzmin\", \"mzmax\", \"rt\", \"rtmin\" \"rtmax\" defining ’s position (size) m/z - rt plane \"\" \"maxo\" (integrated maximum) intensity. Column \"sample\" indicates samples (data files) peak identified. chromatographic peak table contains pairs peaks similar retention times difference m/z values one. Together observed differences intensities, indicate one peaks represents carbon 13 isotope one monoisotopic main peak. frequently observed untargeted metabolomics. general overview peak detection results can also helpful determine (eventually) plot number identified chromatographic peaks per sample. count number peaks per sample. number peaks identified, expected since files contain measurements sample (QC pool). additional visual quality assessment, can also plot location identified chromatographic peaks m/z - retention time space data file using plotChromPeaks function. Location identified chromatographic peaks m/z - rt space. , similar pattern expected present two data files. chromatographic peak detection generally good idea visually inspect individual chromatographic peaks evaluate performance peak detection step. done plotting EICs known compounds/ions data randomly selected chromatographic peaks. illustrate define matrix m/z retention time ranges set (pre)selected peaks. matrix also created either randomly selecting peaks defining manually. example expand retention time m/z ranges peaks, extract EICs chromatogram function finally plot . Identified chromatographic peaks within plotted regions default highlighted semitransparent grey color.  peak detection worked nicely signals upper row, failed define chromatographic peaks containing full signal lower row. cases, signal split separate chromatographic peaks within sample. common problem centWave noisy broad signals. either try adapt centWave settings repeat chromatographic peak detection use refineChromPeaks function allows post-process peak detection results fix problems observed (see also documentation refineChromPeaks function possible refinement options). fuse wrongly split peaks second row, use MergeNeighboringPeaksParam algorithm configure merge chromatographic peaks similar m/z less 8 seconds apart retention time axis (parameter expandRt = 4; distance tail head peaks evaluated merging thus less 2 * expandRt) signal (intensity) two peaks higher 75% smaller apex intensity two peaks (parameter minProp = 0.75). apply settings EICs evaluate result post-processing.  peak post-processing able fuse signal neighboring peaks lower panel, keeping peaks different isomers present top right plot separate. next apply peak refinement full data set.","code":"#' Get the EIC for serine in all files serine_chr <- chromatogram(data, rt = c(164, 200),                            mz = serine_mz + c(-0.05, 0.05),                            aggregationFun = \"max\")  #' Get default centWave parameters cwp <- CentWaveParam()  #' \"dry-run\" peak detection on the EIC. res <- findChromPeaks(serine_chr, param = cwp) chromPeaks(res) ##      rt rtmin rtmax into intb maxo sn row column cwp ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 25 ##  - peakwidth: [1] 20 50 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 1 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE plot(serine_chr) cwp <- CentWaveParam(peakwidth = c(2, 10), integrate = 2)  serine_chr <- findChromPeaks(serine_chr, param = cwp)  #' Plot the data and higlight identified peak area plot(serine_chr) chromPeaks(serine_chr) ##           rt   rtmin   rtmax     into     intb     maxo  sn row column ## [1,] 181.356 178.566 189.447 74443.95 71731.60 37664.94 110   1      1 ## [2,] 181.072 178.561 187.210 70352.22 69008.98 38517.76 224   1      2 #' Restrict the data to signal from Serine srn <- data |> filterRt(rt = c(179, 186)) |> filterMz(mz = c(106.04, 106.07))  #' Plot the data plot(srn) #' Reduce the data set to signal of the [M+H]+ ion of serine srn_1 <- srn[1] |>     filterMzRange(c(106.045, 106.055)) |>     spectra() lengths(srn_1) ##  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 #' Calculate the difference in m/z values between scans mz_diff <- srn_1 |>     mz() |>     unlist() |>     diff() |>     abs() mz_diff ##                                     mz           mz           mz           mz  ## 2.904861e-03 4.357321e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.684509e-05 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 7.624200e-07 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00  ##           mz           mz           mz           mz           mz           mz  ## 1.425717e-03 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00  ##           mz  ## 1.493783e-03 mz_diff * 1e6 / mean(unlist(mz(srn_1))) ##                                     mz           mz           mz           mz  ## 27.391410160 41.087396603 27.391691523  1.112566483 13.695817196  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.158840954  0.000000000  0.000000000  0.682099561  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ##  0.007189246 13.695808133 13.695808133 12.807212147  0.000000000  0.000000000  ##           mz           mz           mz           mz           mz           mz  ## 13.443812242  0.000000000 13.695807986 13.957023433  0.000000000  0.000000000  ##           mz  ## 14.085643094 #' Perform peak detection cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 30, integrate = 2) data <- findChromPeaks(data, param = cwp) data ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 644 in MS level(s): 1 #' Access the peak detection results from a specific m/z - rt area chromPeaks(data, mz = c(106, 108), rt = c(150, 190)) ##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb ## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   509.4463 ## CP146 107.0653 107.0652 107.0653 173.543 171.032 179.682 11318.2801 11309.9091 ## CP157 107.0532 107.0522 107.0537 181.356 179.682 183.309  2905.1158  2901.7678 ## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73905.2115 ## CP469 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.7921 ## CP477 107.0656 107.0655 107.0657 172.980 169.632 178.003 11372.6845 11166.3372 ## CP492 107.0538 107.0510 107.0540 181.072 178.840 183.304  3155.0100  3149.2053 ## CP512 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70109.3562 ##             maxo   sn sample ## CP133   426.6084   35      1 ## CP146  4936.6783 4936      1 ## CP157  1628.9510  186      1 ## CP167 37664.9371  685      1 ## CP469   381.6084   54      2 ## CP477  4569.1399   79      2 ## CP492  2297.7972  230      2 ## CP512 38517.7622  830      2 #' Count peaks per file chromPeaks(data)[, \"sample\"] |>     table() ##  ##   1   2  ## 323 321 #' Plot the location of peaks in the m/z - rt plane par(mfrow = c(1, 2)) plotChromPeaks(data, 1) plotChromPeaks(data, 2) #' Extract m/z-rt regions for selected peaks mz_rt <- chromPeaks(data)[c(\"CP172\", \"CP100\", \"CP325\", \"CP618\"),                           c(\"rtmin\", \"rtmax\", \"mzmin\", \"mzmax\")] #' Expand the rt range by 10 seconds on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 10 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 10 #' Expand the m/z range by 0.005 on both sides mz_rt[, \"mzmin\"] <- mz_rt[, \"mzmin\"] - 0.005 mz_rt[, \"mzmax\"] <- mz_rt[, \"mzmax\"] + 0.005  #' Extract the EICs eics <- chromatogram(data, rt = mz_rt[, c(\"rtmin\", \"rtmax\")],                      mz = mz_rt[, c(\"mzmin\", \"mzmax\")]) #' Plot the EICs plot(eics) #' Define the setting for the peak refinement mpp <- MergeNeighboringPeaksParam(expandRt = 4, minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = mpp)  #' Plot the result plot(eics) #' Perform peak refinement data <- refineChromPeaks(data, param = mpp)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"alignment","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Alignment","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"chromatography helps better discriminate analytes also affected variances lead shifts retention times measurement runs. differences can usually already seen base peak chromatogram total ion chromatogram. thus extract plot BPC data set. chromatogram call, set optional parameter chromPeaks = \"none\" avoid additional extraction identified chromatographic peaks. BPC files. samples measured setup measurement run, slight drifts signal visible. also already visible EIC serine, plot .  serine signal, seems retention time shift 1 second two samples. alignment step aims minimize retention time differences samples within experiment (see illustration). xcms, alignment can performed adjustRtime function one available alignment algorithms, can selected, configured, respective parameter objects: PeakGroupsParam: peakGroups (C. . Smith et al. 2006) method aligns samples based retention times set called hook peaks (housekeeping peaks) different samples experiment. peaks supposed represent signal ions expected present samples experiment method aligns samples minimizing -sample retention time differences observed peaks. ObiwarpParam: obiwarp (Prince Marcotte 2006) performs retention time adjustment based full m/z - retention time data. See documentation ObiwarpParam xcms vignette information. , default, retention time shifts estimated full data set, also possible estimate subset samples, repeatedly measured QC samples (e.g. sample pools) adjust full experiment based . See alignment section xcms vignette information subset-based alignment. Note subset-based alignment requires samples loaded order measured. example use peakGroups method , mentioned , aligns samples based retention times hook peaks (housekeeping peaks). define , need first run initial correspondence analysis group chromatographic peaks across samples. use peakDensity method correspondence. Details method explanations choices parameters provided next section. brief, parameter sampleGroups defines sample group experiment individual samples belong , parameter minFraction specifies proportion samples (one sample group) chromatographic peak needs identified (particular m/z - retention time region) group LC-MS feature. example use sample group definition sampleData data variable set minFraction = 1 requiring thus chromatographic peak identified 100% available samples define feature. Generally, correspondence performed heterogeneous samples minFraction values 0.6 0.8 used instead. Since aim initial correspondence define (presumably well separated) groups chromatographic peaks across samples, settings need fully optimized. step now grouped chromatographic peaks across samples defined called LC-MS features (simply features). can thus now run alignment using peakGroups algorithm. main parameter define hook peaks () minFraction. Similar definition , minFraction refers proportion samples chromatographic peak needs present. setting minFraction = 1 base alignment features peaks identified 100% samples data set. alignments based repeatedly measured samples (e.g. also subset-based alignment sample pools) values >= 0.9 can used. Otherwise, values 0.7 0.9 might advisable ensure reasonable set features selected. identified features used hook peaks algorithm minimizes observed -sample retention time differences . Parameter span defines degree smoothing loess function used allow different regions along retention time axis adjusted different factor. value 0 likely cause overfitting, 1 cause retention times sample shifted constant value. Values 0.4 0.6 seem reasonable experiments. alignment suggested evaluate results using plotAdjustedRtime function. function plots differences adjusted raw retention times sample y-axis along adjusted retention times x-axis (line hence representing retention time adjustment one sample/file). Points indicate position individual hook peaks along retention time axis, dotted line connecting peaks belonging feature (algorithm minimized difference retention times). Alignment results: differences raw adjusted retention times sample. rule thumb, differences raw adjusted retention times plot reasonable. Also, possible, hook peaks present along wide span retention time range, avoid need extrapolation (usually results strong adjustment). example, largest adjustments 1 2 seconds, reasonable given two samples measured measurement run. Also, features used alignment (.e. hook peaks) spread across full retention time range. evaluate impact alignment next also plot BPC alignment. similar way , set chromPeaks = \"none\" chromatogram call tell function include identified chromatographic peaks returned chromatographic data. BPC (top) (bottom) alignment. base peak chromatograms nicely aligned retention time adjustment. addition general assessment, alignment result also evaluated selected compounds (internal standards). thus plot EIC [M+H]+ ion serine alignment. EIC Serine (left) (right) alignment serine peaks also nicely aligned retention time adjustment. , advisable evaluate impact alignment several EICs, ideally also spread along retention time range. Note adjustRtime, addition retention times individual (MS1) spectra files, adjusted also retention times identified chromatographic peaks, well retention times possibly present MS2 spectra. adjusted retention times stored new spectra variable \"rtime_adjusted\" result object’s Spectra. rtime function result object default return (adjusted) values.","code":"#' Extract base peak chromatograms bpc_raw <- chromatogram(data, aggregationFun = \"max\", chromPeaks = \"none\") plot(bpc_raw, peakType = \"none\") plot(serine_chr, xlim = c(175, 190)) grid() #' Define the settings for the initial peak grouping - details for #' choices in the next section. pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 1, binSize = 0.02) data <- groupChromPeaks(data, pdp) #' Define settings for the alignment pgp <- PeakGroupsParam(minFraction = 1, span = 0.6) data <- adjustRtime(data, param = pgp) #' Plot the difference between raw and adjusted retention times plotAdjustedRtime(data) grid() par(mfrow = c(2, 1)) #' Plot the raw base peak chromatogram plot(bpc_raw) grid() #' Plot the BPC after alignment plot(chromatogram(data, aggregationFun = \"max\", chromPeaks = \"none\")) grid() par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5)) plot(serine_chr) grid() #' EIC after alignment serine_chr_adj <- chromatogram(data, rt = c(164, 200),                                mz = serine_mz + c(-0.05, 0.05),                                aggregationFun = \"max\") plot(serine_chr_adj) grid()"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"correspondence","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Correspondence","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"final step LC-MS preprocessing xcms correspondence analysis, chromatographic peaks types ions (compounds) grouped across samples form called LC-MS features. xcms, correspondence performed using groupChromPeaks function. correspondence algorithm can selected configured respective parameter objects: NearestPeaksParam: performs peak grouping based proximity chromatographic peaks different samples m/z - retention time space, similar original correspondence method mzMine (Katajamaa, Miettinen, Oresic 2006). PeakDensityParam: performs simple fast correspondence analysis based density chromatographic peaks (different samples) along retention time axis within slices small m/z ranges (C. . Smith et al. 2006). methods group chromatographic peaks different samples similar m/z retention times features. example use peak density method. algorithm iterates small slices along m/z dimension groups within slice chromatographic peaks similar retention times. grouping depends distribution (density) chromatographic peaks samples along retention time axis. Peaks similar retention time result higher peak density certain retention time thus grouped together. grouping depends smoothness density curve can configured parameter bw. illustration showing chromatographic peaks within small m/z range grouped peakDensity method shown sketch . Settings algorithm can best tested optimized using plotChromPeakDensity function extracted chromatograms. extract chromatogram m/z slice containing signal [M+H]+ ion serine evaluate result peakDensity correspondence analysis using function. use default settings (bw = 30) use sample group assignment defined sampleData.  upper panel plot shows chromatographic data selected m/z slice identified peaks highlighted grey. lower panel plots retention time identified chromatographic peaks x-axis index sample peak identified. chromatographic peak thus represented point plot (x-axis value retention time y-axis value sample identified). example one chromatographic peak identified sample retention time 180 seconds two peaks thus shown. black solid line represents density estimation (.e. distribution retention times) identified chromatographic peaks along retention time axis. smoothness curve (created base R density function) configured parameter bw. peakDensity algorithm assigns chromatographic peaks within peak density estimation curve feature. Chromatographic peaks assigned feature indicated grey rectangle plot. present example, retention times two chromatographic peaks similar, rectangle narrow looks thus like vertical line. Based result, default settings (bw = 30) seemed correctly define features. however advisable evaluate settings multiple slices, ideally signal one compound present. slices identified e.g. plot created plotChromPeaks function (see example chromatographic peak detection section). example extract chromatogram m/z slice containing signal known isomers betaine valine ([M+H]+ m/z 118.08625). Correspondence analysis default settings m/z slice containing signal multiple ions. slice contains signal several ions resulting multiple chromatographic peaks along retention time axis. default settings, particular bw = 30, peaks however assigned feature (indicated grey rectangle). Signal different ions thus treated single entity. repeat analysis strongly reduced value parameter bw. Correspondence analysis reduced bw setting m/z slice containing signal multiple ions. Setting bw = 1.8 strongly reduced smoothness density curve resulting higher number density peaks hence nice grouping (aligned) chromatographic peaks separate features. Note height peaks density curve considered grouping. defined bw appropriate data set, proceed perform correspondence analysis full data set. parameters peakDensity binSize minFraction. former defines m/z widths slices along m/z dimension algorithm iterate . value depends resolution (noise) instrument, set small value, also large (avoid peaks different ions, slightly different m/z similar retention times, grouped feature). minFraction parameter (already discussed ) defines proportion samples within least one sample group chromatographic peaks need identified order define feature. example use binSize = 0.02 hence grouping chromatographic peaks, similar retention time, difference m/z smaller 0.02 feature minFraction = 0.4 thus defining features chromatographic peak identified least 50% samples per sample group. 300 features identified example data set. , suggested evaluate results selected compounds/ions. therefore extract chromatogram m/z range containing signals betaine valine. correspondence analysis also features extracted chromatogram call can show results actual correspondence analysis (based also settings used) setting simulate = FALSE plotChromPeakDensity call. Result correspondence slice containing isomers valine betaine. evaluate results also different slice containing signal ions isomers leucine isoleucine ([M+H]+ m/z 132.10191). Result correspondence slice containing isomers leucine isoleucine. Despite close, chromatographic peaks two isomers successfully grouped separate features. Even partially overlapping signal third ion eluting time hence partially overlapping peak retention time 152 seconds grouped , separate, feature. discretion data analysts define fine coarse feature grouping . Especially larger experiments, samples also larger variation retention time might always possible completely separate closely eluting ions sometimes might acceptable group single feature (keeping mind feature however represent signal different ions/compounds). Similar peak detection alignment results, also results correspondence analysis added XcmsExperiment object. can extracted featureDefinitions function, extracts definition LC-MS features featureValues function extracts numerical matrix feature abundances (samples). extract definition features display first 6 rows row defines one feature provides information ’s m/z (column \"mzmed\") retention time (column \"rtmed\"). Additional columns list number chromatographic peaks assigned feature MS level. Column \"peakidx\" provides indices chromatographic peaks chromPeaks matrix assigned feature - generally users need extract information. feature abundance matrix, final result xcms preprocessing, can extracted featureValues function. default, parameter method = \"maxint\", returns feature integrated peak signal chromatographic peak highest signal per sample. Note effect features one chromatographic peak per sample (.e., multiple chromatographic peaks sample grouped feature closeness retention time). Setting method = \"sum\" contrast sum abundances chromatographic peaks. Note method = \"sum\" suggested , like example, neighboring overlapping peaks per sample merged avoid overestimation feature abundance. extract feature abundances show first 6 rows. now use feature matrix downstream analysis. feature matrix might however, can also seen second row (feature FT002), contain missing values. represent features chromatographic peak identified one () sample(s). number imputation methods exist deal missing values, might advisable instead rescue signal. xcms provides gap filling explained next section.","code":"#' Extract a chromatogram for a m/z range containing serine chr_1 <- chromatogram(data, mz = serine_mz + c(-0.005, 0.005))  #' Default parameters for peak density; bw = 30 pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 30)  #' Test these settings on the extracted slice plotChromPeakDensity(chr_1, param = pdp) #' Plot the chromatogram for an m/z slice containing betaine and valine mzr <- 118.08625 + c(-0.01, 0.01) chr_2 <- chromatogram(data, mz = mzr, aggregationFun = \"max\")  #' Correspondence in that slice using default settings plotChromPeakDensity(chr_2, param = pdp) #' Reducing the bandwidth pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8) plotChromPeakDensity(chr_2, param = pdp) #' Set optimized settings pdp <- PeakDensityParam(sampleGroups = sampleData(data)$group, bw = 1.8,                         minFraction = 0.4, binSize = 0.02)  #' Perform the correspondence analysis data <- groupChromPeaks(data, param = pdp) data ## Object of class XcmsExperiment  ##  Spectra: MS1 (1862)  ##  Experiment data: 2 sample(s) ##  Sample data links: ##   - spectra: 2 sample(s) to 1862 element(s). ##  xcms results: ##   - chromatographic peaks: 589 in MS level(s): 1  ##   - adjusted retention times: mean absolute difference 0.328 seconds ##   - correspondence results: 357 features in MS level(s): 1 #' Extract chromatogram including signal for betaine and valine chr_2 <- chromatogram(data, mz = 118.08625 + c(-0.01, 0.01),                       aggregationFun = \"max\") #' Setting simulate = FALSE to show the actual correspondence results plotChromPeakDensity(chr_2, simulate = FALSE) #' Extract chromatogram with signal for isomers leucine and isoleucine chr_3 <- chromatogram(data, mz = 132.10191 + c(-0.01, 0.01),                       aggregationFun = \"max\") plotChromPeakDensity(chr_3, simulate = FALSE) #' Definition of the features featureDefinitions(data) |> head() ##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL ## FT001 105.0418 105.0417 105.0418 167.68279 167.48793 167.87765      2    2 ## FT002 105.0415 105.0415 105.0415 157.71770 157.71770 157.71770      1    1 ## FT003 105.0697 105.0691 105.0703  31.80814  31.67350  31.94279      2    2 ## FT004 105.1103 105.1100 105.1105  63.71309  63.37961  64.04656      2    2 ## FT005 105.4734 105.4732 105.4736 201.57632 201.37059 201.78204      2    2 ## FT006 105.7166 105.7160 105.7172 181.21585 181.08578 181.34592      2    2 ##        peakidx ms_level ## FT001 115, 393        1 ## FT002      114        1 ## FT003  21, 317        1 ## FT004  49, 348        1 ## FT005 261, 573        1 ## FT006 138, 440        1 #' Get abundances for the first 6 features featureValues(data, method = \"sum\") |> head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                               NA ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"gap-filling","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Gap filling","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Missing values feature matrices xcms-based preprocessing represent cases , particular sample, chromatographic peak identified m/z - retention time region feature. either represent truly missing value (ion/compound present sample) failure peak detection algorithm identify peak (either measured signal noisy, low, combination ). illustrate extract m/z - retention time region selected features, extract EICs plot (using different color sample). Examples features peak identified one sample. Indeed, feature, chromatographic peak detection failed identify peak one two samples. features upper panel, signal likely low, bottom left feature signal likely noisy, bottom right sparse (.e. data points properly detect peak). cases, however, signal (presumably) ion measured samples. Thus, reporting missing value correct cases. aim gap filling now rescue signal features integrating intensities measured within feature’s m/z - retention time area sample(s) chromatographic peak detected. xcms can done fillChromPeaks function ChromPeakAreaParam allows configure algorithm. perform gap filling summing also number missing values running fillChromPeaks. fillChromPeaks thus rescue signal 26 features. extract EICs visually inspect . Features missing values even gap-filling. features indeed signal measured second sample signal also low sample chromatographic peak detected. contrast, 4 example features signal rescued. visualize gap-filled chromatographic peaks . Features filled-signal. nice way check gap-filling able correctly rescue signals plot, features least one missing value, average detected average filled-signal. Ideally, done QC samples repeatedly measured samples difference feature abundance samples expected. code extracts first detected feature values (setting filled = FALSE featureValues call), detected filled-signal detected signal subsequently replaced NA. Finally, calculating row averages matrices (excluding missing values), values plotted . Detected (x-axis) filled (y-axis) signal. black solid line represents identity line. expected, detected signal generally higher filled-signal. biggest part (particular higher intensities), filled-detected feature values similar suggesting gap filling step indeed rescued signal.","code":"#' Extract the m/z-rt region for selected peaks mz_rt <- featureArea(data, features = c(\"FT026\", \"FT028\", \"FT246\", \"FT306\")) mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 2 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 2  #' Extract their EICs and plot them chrs <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                      rt = mz_rt[, c(\"rtmin\", \"rtmax\")]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Number of missing values sum(is.na(featureValues(data))) ## [1] 133 #' Perform gap filling data <- fillChromPeaks(data, param = ChromPeakAreaParam())  #' Number of missing values after gap filling sum(is.na(featureValues(data))) ## [1] 25 #' Identify features with missing values fts <- rownames(featureValues(data))[is.na(rowSums(featureValues(data)))]  #' Define m/z - rt regions for these features mz_rt <- featureArea(data, features = fts)  #' Expand the retention time by 1 second on both sides mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 1 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 1  chrs_na <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                         rt = mz_rt[, c(\"rtmin\", \"rtmax\")])  plot(chrs_na, col = c(\"red\", \"blue\"), lwd = 2) #' Extract the m/z-rt region for selected peaks mz_rt <- featureArea(data, features = c(\"FT026\", \"FT028\", \"FT246\", \"FT306\")) mz_rt[, \"rtmin\"] <- mz_rt[, \"rtmin\"] - 2 mz_rt[, \"rtmax\"] <- mz_rt[, \"rtmax\"] + 2  #' Extract their EICs and plot them chrs <- chromatogram(data, mz = mz_rt[, c(\"mzmin\", \"mzmax\")],                      rt = mz_rt[, c(\"rtmin\", \"rtmax\")]) plot(chrs, col = c(\"red\", \"blue\"), lwd = 2) #' Get only detected signal vals_detect <- featureValues(data, filled = FALSE) #' Get detected and filled-in signal vals_filled <- featureValues(data) #' Replace detected signal with NA vals_filled[!is.na(vals_detect)] <- NA  #' Identify features with at least one filled peak has_filled <- is.na(rowSums(vals_detect))  #' Calculate row averages avg_detect <- rowMeans(vals_detect, na.rm = TRUE) avg_filled <- rowMeans(vals_filled, na.rm = TRUE)  #' Restrict to features with at least one filled peak avg_detect <- avg_detect[has_filled] avg_filled <- avg_filled[has_filled]  #' plot the values against each other (in log2 scale) plot(log2(avg_detect), log2(avg_filled),      xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      pch = 21, bg = \"#00000080\") grid() abline(0, 1)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"preprocessing-result","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"Preprocessing result","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"xcms preprocessing results stored within XcmsExperiment object. includes identified chromatographic peaks, alignment results well correspondence results. addition, guarantee reproducibility, result object keeps track performed processing steps contains also individual parameter objects used various preprocessing steps. can extracted processHistory function: individual parameter object can extracted follows: Thus, used preprocessing algorithms along settings reported along preprocessing results. described , values individual features can extracted result object featureValues function definition features (used initial annotation features based m/z /retention times) using featureDefinitions function. addition, XcmsExperiment result object, internal Spectra object, keeps link full MS data used analysis. downstream analyses, don’t need access MS data anymore preprocessing results represented equally well using SummarizedExperiment object, Bioconductor’s standard container large-scale omics data. xcms provides quantify function convenience function extract results XcmsExperiment result object return SummarizedExperiment. function takes parameters featureValues, internally used extract feature value matrix. sample annotations can now accessed colData function feature definitions (.e. annotation individual rows/features) rowData function: feature values stored assay within object. access simply use assay function.","code":"#' Process history processHistory(data) ## [[1]] ## Object of class \"XProcessHistory\" ##  type: Peak detection  ##  date: Wed Sep 27 07:52:57 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: CentWaveParam  ##  MS level(s) 1  ##  ## [[2]] ## Object of class \"XProcessHistory\" ##  type: Peak refinement  ##  date: Wed Sep 27 07:53:01 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: MergeNeighboringPeaksParam  ##  MS level(s) 1  ##  ## [[3]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Wed Sep 27 07:53:03 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[4]] ## Object of class \"XProcessHistory\" ##  type: Retention time correction  ##  date: Wed Sep 27 07:53:03 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakGroupsParam  ##  MS level(s) 1  ##  ## [[5]] ## Object of class \"XProcessHistory\" ##  type: Peak grouping  ##  date: Wed Sep 27 07:53:09 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: PeakDensityParam  ##  MS level(s) 1  ##  ## [[6]] ## Object of class \"XProcessHistory\" ##  type: Missing peak filling  ##  date: Wed Sep 27 07:53:15 2023  ##  info:   ##  fileIndex: 1,2  ##  Parameter class: ChromPeakAreaParam  ##  MS level(s) 1 #' Peak detection parameters processHistory(data)[[1]]@param ## Object of class:  CentWaveParam  ##  Parameters: ##  - ppm: [1] 30 ##  - peakwidth: [1]  2 10 ##  - snthresh: [1] 10 ##  - prefilter: [1]   3 100 ##  - mzCenterFun: [1] \"wMean\" ##  - integrate: [1] 2 ##  - mzdiff: [1] -0.001 ##  - fitgauss: [1] FALSE ##  - noise: [1] 0 ##  - verboseColumns: [1] FALSE ##  - roiList: list() ##  - firstBaselineCheck: [1] TRUE ##  - roiScales: numeric(0) ##  - extendLengthMSW: [1] FALSE #' Extract results as a SummarizedExperiment library(SummarizedExperiment) res <- quantify(data, method = \"sum\") #' Get sample annotations colData(res) ## DataFrame with 2 rows and 5 columns ##                                           file      sample injection_index ##                                    <character> <character>       <numeric> ## 20171016_POOL_POS_1_105-134.mzML 20171016_P...      POOL_1               1 ## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19 ##                                        group spectraOrigin ##                                  <character>   <character> ## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT... ## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT... #' Get feature annotations rowData(res) ## DataFrame with 357 rows and 9 columns ##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks ##       <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> <numeric> ## FT001   105.042   105.042   105.042  167.6828  167.4879  167.8776         2 ## FT002   105.042   105.042   105.042  157.7177  157.7177  157.7177         1 ## FT003   105.070   105.069   105.070   31.8081   31.6735   31.9428         2 ## FT004   105.110   105.110   105.111   63.7131   63.3796   64.0466         2 ## FT005   105.473   105.473   105.474  201.5763  201.3706  201.7820         2 ## ...         ...       ...       ...       ...       ...       ...       ... ## FT353   133.928   133.928   133.928   198.587  198.5874  198.5874         1 ## FT354   133.960   133.960   133.961    30.831   30.8218   30.8402         2 ## FT355   133.956   133.956   133.956   199.067  198.9900  199.1432         2 ## FT356   133.973   133.973   133.973   206.872  206.4049  207.3387         2 ## FT357   133.973   133.973   133.973   200.256  200.2561  200.2561         1 ##            POOL  ms_level ##       <numeric> <integer> ## FT001         2         1 ## FT002         1         1 ## FT003         2         1 ## FT004         2         1 ## FT005         2         1 ## ...         ...       ... ## FT353         1         1 ## FT354         2         1 ## FT355         2         1 ## FT356         2         1 ## FT357         1         1 #' Get feature values assay(res) |> head() ##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML ## FT001                        3202.7445                        2285.2830 ## FT002                        3605.3915                        3186.1339 ## FT003                         744.8752                        1057.4312 ## FT004                       18126.4603                       19369.4039 ## FT005                       23243.6129                       31960.3709 ## FT006                         671.5842                         617.7545"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"what-next","dir":"Articles","previous_headings":"Preprocessing of LC-MS data","what":"What next?","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"preprocessing, data normalized scaled remove technical variances data. simple e.g. median scaling done lines R code also advanced (always needed) normalization algorithms available e.g. Bioconductor’s preprocessCore package. Differential abundance analysis performed using r Biocpkg(\"limma\") package packages methods available R. mentioned , many chromatographic peaks (subsequently also features) untargeted metabolomics data sets represent isotopes also different ions/adducts compound. CAMERA package aimed identify group features data set. similar feature grouping (compounding) can also done preprocessing results newer versions xcms using MsFeatures package. package enables grouping features variety different methods. See also feature grouping vignette xcms details. Finally, MetaboAnnotation provides functions assist annotation features LC-MS well LC-MS/MS experiments. allow either perform initial annotation based m/z values combination m/z retention time values. addition, also annotations based fragment spectra (available) supported (without considering addition features’ retention times. information provided MetaboAnnotation vignette MetaboAnnotation tutorial. information general MS data analysis R spectra similarity calculations can found RforMassSpectrometry book various workshops/tutorials SpectraTutorials.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"final-words","dir":"Articles","previous_headings":"","what":"Final words","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"don’t use defaults xcms. use infrastructure inspect summarize data. don’t limit just xcms, use vast number additional packages, methods, visualizations R. build custom workflows, data visualization approaches analysis method.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-visualizations","dir":"Articles","previous_headings":"Appendix","what":"Additional visualizations","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Visualization key understand signal measured MS instrument also evaluate performance (quality) preprocessing. LC-MS data particularly difficult visualize 3-dimensional nature. Focusing specific m/z retention time ranges (EICs) can help. section provide additional examples data can visualized. particular, show alternative way evaluate investigate identified chromatographic peaks data file. subset data first sample visualize identified chromatographic peaks m/z - retention time plane. Position identified chromatographic peaks first sample. plot provides information region peaks identified retention time widths peaks, allow investigate peak shapes intensities. information provided, single ion, extracted ion chromatogram. thus extract ion chromatograms every identified chromatographic peak first sample. parameter expandRt = 4 extract also signal measured 2 seconds peak. now plot 356 EICs separately (using plot function). alternative, can use plotChromatogramsOverlay function xcms package plot multiple EICs plot. setting parameter stacked value different 0 possible stack chromatograms along y-axis hence providing 3-dimensional impression data. easier visualization addition increase transparency colors individual lines (parameter col), identified chromatographic peaks (parameter peakCol peakBg foreground background color, respectively). identified chromatographic peaks one sample shown pseudo 3-dimensional plot. Instead full data range can also extract EICs selected regions data. define area m/z value 113 119 retention time 125 145 seconds.  next extract chromatographic peaks region, define m/z retention time ranges extract ion chromatograms slices. can now plot EICs region plotChromatogramsOverlay. function also silently returns y-position individual EICs plot assign variable y use information indicate m/z EICs along y-axis. EICs selected m/z - retention time region. EICs seem represent signals isotopes (e.g. EIC 114.07 115.07). infrastructure around xcms thus allows create customized visualizations data. Note however, plots created showed detected chromatographic peaks sample full MS data (.e. signals outside identified chromatographic peaks). LLLLLLLL alternative, also possible visualize two EICs combined plot using plotChromatogramsOverlay functions. allows immediate visual comparison peak shapes , isotope peaks, expected highly similar. plotChromatogramsOverlay function set stacked = 0.1 causes EICs drawn slightly shifted along y-axis (hence EICs stacked). gives little 3-dimensional impression data. plotChromatogramsOverlay also returns y-positions EIC can use draw horizontal line indicate m/z EICs.","code":"#' Plot identified chromatographic peaks in the first sample data_1 <- data[1] plotChromPeaks(data) chrs_all <- chromPeakChromatograms(data_1, expandRt = 4) plotChromatogramsOverlay(chrs_all, stacked = 1, bty = \"n\",                          col = \"#00000020\", peakCol = \"#00000020\",                          peakBg = \"#00000020\") plotChromPeaks(data_1) rect(125, 113, 145, 119, lty = 3, border = \"#ff000080\", lwd = 2) #' Extract chrom peaks from that region pks <- chromPeaks(data_1, mz = c(113, 119), rt = c(125, 145))  #' Extract EICs for the m/z slices of the chromatographic peaks #' and the full retention time window of the area chrs_sub <- chromatogram(data_1, mz = pks[, c(\"mzmin\", \"mzmax\")],                          rt = cbind(rep(125, nrow(pks)),                                     rep(145, nrow(pks)))) #' Plot the EICs of the selected area y <- plotChromatogramsOverlay(chrs_sub, stacked = 1, bty = \"n\",                               col = \"#00000020\", peakCol = \"#00000020\",                               peakBg = \"#00000020\")  #' Draw horizonal lines abline(h = y[[1]], col = \"#00000020\", lty = 3) #' Add m/z values of the EICs to the plot mzs <- format(rowMeans(mz(chrs_sub)), digits = 5) text(x = rep(126, length(mzs)), y = y[[1]],      labels = paste0(\"m/z = \", mzs), pos = 1) #' What could the differences be? pks <- pks[order(pks[, \"mz\"]), ] library(MetaboCoreUtils) isotopologues(pks[, c(\"mz\", \"into\")]) ## [[1]] ##       CP053  ##     2     3  ##  ## [[2]] ##       CP054  ##     4     5 tmp <- mass2mz(123, adductNames())  diffs <- outer(tmp[1, ], tmp[1, ], \"-\") diffs[lower.tri(diffs, TRUE)] <- NA diffs <- abs(diffs)  pk_diffs <- outer(pks[, \"mz\"], pks[, \"mz\"], \"-\") pk_diffs[lower.tri(pk_diffs, TRUE)] <- NA pk_diffs <- abs(pk_diffs)  res <- outer(pk_diffs, diffs, \"-\")  sort(unique(diffs)) ##   [1]   0.0398250   0.9840060   0.9840156   1.0072760   1.0471010   1.4686690 ##   [7]   1.4819440   1.5353330   2.1021720   2.4628858   2.4776950   2.9373380 ##  [13]   2.9509840   3.0040020   3.0706660   3.0706660   3.4469013   3.4834209 ##  [19]   3.4969271   3.9713840   4.0391600   4.5035491   4.9553900   4.9553900 ##  [25]   4.9655961   5.0101940   5.0187539   5.8453707   5.9296740   5.9683550 ##  [31]   5.9942000   6.0080040   6.0081800   6.0081800   6.1413320   6.4874229 ##  [37]   6.5009291   6.9812441   7.0154560   7.0313330   7.3273147   7.3273147 ##  [43]   7.3273147   7.9869700   8.5132770   9.0003400   9.5090280   9.5223030 ##  [49]   9.9655840   9.9843499  10.0442660  10.4646650  10.9909720  10.9909720 ##  [55]  11.0183740  11.9376780  11.9765350  11.9999980  12.0023800  12.0163600 ##  [61]  12.9032740  13.0236360  13.1726853  13.4686670  14.0125771  14.0156500 ##  [67]  14.3586477  14.4878991  14.6546293  14.6546293  14.9996560  15.0054460 ##  [73]  15.4945211  15.5476789  15.8542580  15.9737640  15.9739400  15.9739400 ##  [79]  16.0192727  16.0936220  16.8363427  16.9655941  16.9867290  17.0032882 ##  [85]  17.0265487  17.0265540  17.0265540  17.0663737  17.4959980  17.9564300 ##  [91]  17.9707350  18.0105600  18.0105642  18.0105647  18.0338300  18.0503892 ##  [97]  18.9779420  18.9945803  19.0178360  19.0309600  19.0313310  19.0446060 ## [103]  19.0446060  19.0446060  19.0446060  19.0446060  19.4661740  19.9453240 ## [109]  20.0098500  20.4734500  20.5000000  20.5000000  20.5132750  20.5132750 ## [115]  20.5132750  20.9293300  20.9293300  21.3398918  21.5074918  21.6859623 ## [121]  21.9421190  21.9819440  21.9819440  21.9819440  21.9819440  21.9819440 ## [127]  21.9819440  21.9819440  21.9955900  22.0486080  22.1016260  22.4915073 ## [133]  22.9761608  22.9892200  23.0159900  23.0347287  23.9601763  23.9969271 ## [139]  23.9999960  23.9999960  24.0187442  24.1636573  24.5114938  24.8233127 ## [145]  25.0526100  25.0526100  25.4788711  25.4955093  25.5320289  25.9395240 ## [151]  25.9533280  26.0180300  26.3586457  26.4816300  26.9373340  27.8273147 ## [157]  27.9949146  28.0313000  28.6672065  28.9789302  29.0101900  29.0132770 ## [163]  29.0429087  30.0269242  30.0355780  30.9822840  31.3242417  31.4909720 ## [169]  31.9475280  31.9477040  31.9478800  31.9863850  32.0262100  32.1506273 ## [175]  32.4898100  32.4984638  32.5132730  33.0334860  33.4824793  33.6859603 ## [181]  34.0500520  34.0531026  34.8852180  34.9761588  35.0138529  35.0183700 ## [187]  35.0371086  35.0371182  35.1546293  35.9601743  35.9945211  36.0211242 ## [193]  36.0211289  36.0609539  36.9873900  37.5000040  37.9160590  37.9557080 ## [199]  37.9558840  37.9558840  37.9558840  38.0755660  38.0892120  38.4840100 ## [205]  38.5107800  38.6515564  38.9631600  39.0084926  39.4779420  39.5180560 ## [211]  39.5446060  39.5578810  39.9794490  39.9925082  40.0580560  40.9469000 ## [217]  40.9867250  40.9867250  41.0132750  41.0265500  41.0265500  41.0265500 ## [223]  41.0265500  41.0265500  41.0265500  41.0265500  41.5147820  42.0074918 ## [229]  42.0293089  42.0338260  42.0469500  42.4553940  42.4819440  42.5220580 ## [235]  42.5618830  42.9915074  43.0309560  43.4894358  43.8855580  43.9240630 ## [241]  43.9638880  44.0972160  44.4734513  44.9711640  44.9860600  44.9979340 ## [247]  44.9982029  45.5262360  45.9788711  45.9819400  45.9819400  45.9877300 ## [253]  46.0054789  46.0453039  46.8719207  46.9949050  47.0882320  48.0374889 ## [259]  48.0411500  48.5302380  49.0527587  49.3348064  49.5017520  50.0268900 ## [265]  50.0367742  50.3188220  50.5090280  50.5488530  50.9921340  51.5344160 ## [271]  51.9794470  52.0136589  52.4996600  52.9867230  53.0030850  53.0265480 ## [277]  53.0476829  53.9298240  54.0316889  54.0493300  54.1992353  54.5384180 ## [283]  54.9824327  55.9664482  56.0319960  56.5172080  56.5446100  56.6621211 ## [289]  57.0003140  57.5286160  57.6461367  57.9012080  57.9734540  58.0030729 ## [295]  58.0132790  58.0218389  58.0530987  58.4293340  58.8852140  58.9949030 ## [301]  58.9972850  59.0107800  59.0371142  59.5486120  59.9915060  59.9915060 ## [307]  60.0033800  60.0176850  60.0180560  60.0575100  60.0578810  60.0711560 ## [313]  60.4927240  60.5326180  60.9873860  60.9904366  61.0647860  61.5000000 ## [319]  61.5000000  61.5000000  61.5265500  61.5398250  61.9744522  62.0126140 ## [325]  62.5253880  62.9288440  62.9424900  62.9686690  62.9686690  63.0084940 ## [331]  63.0084940  63.0320329  63.8954080  63.9894358  64.0157700  64.0160389 ## [337]  64.0425400  64.1147860  64.4373380  64.5040020  64.9734514  65.0030830 ## [343]  65.0265460  65.9975800  66.0262360  66.3380947  66.9680040  67.3453707 ## [349]  67.3851957  67.5081800  67.5355820  67.9874229  68.0473389  68.5195880 ## [355]  69.0701760  69.9035880  70.0132770  70.0367400  70.9972830  71.5442660 ## [361]  72.0057600  72.0344160  72.4909720  73.0129350  73.3535507  73.5163600 ## [367]  73.6654093  73.9770129  74.5482680  74.6726853  74.7125103  74.9686670 ## [373]  75.8719430  75.9117680  76.0449200  76.9190440  77.0180600  77.0446100 ## [379]  77.0476789  77.0840587  77.4739400  77.9741150  78.0139400  78.0286160 ## [385]  78.0316889  78.0680742  78.5265540  78.9027840  78.9426090  79.0212160 ## [391]  79.0361120  79.3617307  79.5105600  79.9690440  79.9850169  80.0350427 ## [397]  80.0528295  80.4779420  80.5309600  80.5446060  80.6808653  80.9927240 ## [403]  81.0190582  81.9734500  81.9734500  81.9734500  81.9734500  82.0000000 ## [409]  82.0000000  82.0132750  82.0132750  82.0398250  82.0531000  82.5352380 ## [415]  82.9419440  83.0603760  83.4819440  83.4819440  83.4819440  83.5486080 ## [421]  83.9613629  84.3719247  84.9244340  84.9506130  85.0129330  85.0441160 ## [427]  85.0441160  85.0441160  85.3559307  86.0126100  86.4859460  86.6890453 ## [433]  87.0320289  87.3801442  88.0081800  88.1147820  88.4649120  89.3273147 ## [439]  89.9693669  90.9426070  90.9737900  91.5355780  91.6992393  92.0442660 ## [445]  92.6832453  92.9383166  93.5262100  93.9223322  94.0132730  94.0163600 ## [451]  94.4729160  94.7074588  95.0404886  96.0245042  96.0626660  96.0786389 ## [457]  96.3852180  96.6546293  96.9506110  97.9473900  97.9739400  98.4873900 ## [463]  99.0000040  99.0265540  99.0296229  99.0796487  99.3715807  99.4558840 ## [469]  99.5755660 100.0105600 100.0636642 100.5528295 100.8983740 101.0180560 ## [475] 101.0180560 101.0180560 101.0180560 101.0442350 101.0446060 102.0347735 ## [481] 102.0706700 102.5265500 102.5265500 102.5265500 102.5795680 103.9553940 ## [487] 103.9553940 103.9690400 103.9819440 103.9819440 103.9952190 104.9894400 ## [493] 105.3012547 105.4638880 105.5305520 105.9734460 105.9734460 106.0629889 ## [499] 106.6988953 107.0260600 107.9945540 108.0003440 108.3719207 109.0139729 ## [505] 109.0661065 110.0967260 110.5665380 110.9836400 111.3092587 111.5438015 ## [511] 111.9328969 112.6285693 112.9557340 113.0442330 113.5175220 114.0262100 ## [517] 114.0350689 115.4298240 115.6992353 115.9952170 116.0473506 116.8984930 ## [523] 116.9918200 116.9919960 117.5319960 118.0446100 118.0742289 118.4338260 ## [529] 118.6365733 119.0006650 119.5307715 119.9293340 119.9558840 120.0626620 ## [535] 120.0755660 120.5359980 121.0661045 121.5575100 121.5711560 121.9172469 ## [541] 122.0159940 122.5347735 122.9601750 123.0000000 123.0000000 123.0000000 ## [547] 123.0000000 123.0000000 123.0000000 123.0000000 123.0265500 123.0265500 ## [553] 123.0398250 124.0072760 124.0194189 124.5084940 124.5751580 125.9509840 ## [559] 125.9638880 126.0317006 126.0706660 126.4207960 126.9713840 127.4028807 ## [565] 127.9553900 128.0101940 128.0585789 128.5229680 128.8984910 128.9296740 ## [571] 130.3538647 131.0006630 132.0003400 132.5621280 132.9655840 134.0183740 ## [577] 134.7301953 135.0398230 135.9298240 137.4117680 137.6811793 138.0319960 ## [583] 138.9737640 138.9739400 139.5139400 139.9867290 140.0265486 140.0265540 ## [589] 141.0105642 141.0338300 141.5793795 142.0446060 142.0446060 142.0575100 ## [595] 142.0711560 142.9453240 143.2571387 143.4734500 143.5531000 143.9293300 ## [601] 144.0422653 144.9421190 144.9819440 144.9819440 145.0084940 145.0262809 ## [607] 145.3593107 145.9892200 146.0159900 146.9999960 148.0526100 148.9395240 ## [613] 149.3984707 150.5844533 152.0101900 152.6866253 153.9822840 154.9477040 ## [619] 156.7257853 157.0531027 157.9117680 158.0183700 158.0371182 159.0211289 ## [625] 160.0139400 160.5000040 160.9160590 160.9558840 161.0455535 161.9631600 ## [631] 162.0084926 162.0528295 162.0926545 162.5180560 162.9925082 163.9469000 ## [637] 163.9867250 163.9867250 164.0265500 164.0265500 164.0531000 165.0338260 ## [643] 165.4553940 165.5220580 167.9860600 167.9979340 168.0610095 168.9819400 ## [649] 169.0054789 170.0882320 173.5090280 173.9921340 174.0691895 175.9867230 ## [655] 176.0476829 177.9824327 178.9664482 179.0793835 179.5446100 180.0003140 ## [661] 180.0633895 181.0030729 181.0132790 181.0530986 181.4293340 182.0371142 ## [667] 182.5486120 182.9915060 183.0180560 184.0347735 184.5000000 184.5000000 ## [673] 184.5000000 185.9424900 185.9686690 185.9686690 186.0084940 186.0320329 ## [679] 187.0157700 187.5040020 190.3453707 190.5355820 190.9874229 193.0132770 ## [685] 194.0790395 195.4909720 196.9770129 197.6726853 197.9686670 200.0087135 ## [691] 200.0446100 200.0476789 200.4739400 201.5265540 201.9426090 202.0361120 ## [697] 203.0350426 203.0793795 203.4779420 203.5446060 204.0190582 204.9734500 ## [703] 205.0000000 205.0000000 205.0132750 206.0167175 206.4819440 206.4819440 ## [709] 206.5486080 206.9613629 207.3719247 208.0441160 210.0320289 211.4649120 ## [715] 212.3273147 213.9426070 213.9737900 214.5355780 214.6992393 217.0132730 ## [721] 219.6546293 220.9739400 222.0265540 222.0296229 222.1103395 222.4558840 ## [727] 224.0180560 224.0446060 225.0613235 225.5265500 225.5265500 226.9819440 ## [733] 226.9952190 227.9894400 228.3012547 228.5305520 228.9734460 231.3719207 ## [739] 232.0139729 233.9836400 235.6285693 236.5175220 237.9645975 238.6992353 ## [745] 238.9952170 239.9918200 240.0667695 242.9558840 244.1059295 245.9601750 ## [751] 246.0000000 246.0265500 246.0265500 247.0072760 247.5084940 253.3538647 ## [757] 260.6811793 263.0265486 264.0105642 266.4734500 268.0084940 282.0211289 ## [763] 285.0528295 285.5180560 286.9867250 288.5220580 292.0054789 296.5090280 ## [769] 298.9867230 302.0793835 306.0180560 307.0347735 307.5000000 313.3453707 ## [775] 320.6726853 323.0087135 326.0793795 328.0000000 348.0613235 408.0528295 y <- plotChromatogramsOverlay(chrs, stacked = 0.1, bty = \"n\") abline(h = y[[1]], col = \"grey\") mzs <- format(rowMeans(mz(chrs)), digits = 5) text(x = c(175, 175), y = y[[1]],      labels = paste0(\"m/z = \", mzs), pos = 1)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"bonus-material---peak-detection-fun","dir":"Articles","previous_headings":"Appendix","what":"Bonus material - peak detection fun","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"section apply lessons learned previous sections, particular adapt peak detection setting rather noisy chromatographic data. load example data text file. data two columns, one retention times one intensities. can now create Chromatogram object plot data.  two peaks present data, signal latter particularly noisy. goal now perform peak detection identify two peaks. first try default settings centWave clearly shows tune parameters (note setting sn = 0 required present data set enough background data points algorithm estimate noise level properly). parameter now adapt data? choices? Go ahead try different settings setting combination see can succeed detecting two peaks. Eventually might even try different peak detection algorithm (e.g. MatchedFilterParam).  default parameters centWave clearly failed identify two large peaks, defining smaller fragments potential peaks. Especially second peak peculiar tri-forked shape seems cause troubles. even hydrophilic liquid interaction chromatography (HILIC), known potentially result noisy odd-shaped peaks, rather unusual peak shape. fact, signal analyzing chromatographic origin:  example data represents panorama picture featuring mountains Dolomites, Paternkofel (left peak, colored red) famous Drei Zinnen (right tri-forked peak colored green).","code":"data <- read.table(     system.file(\"txt\", \"chromatogram.txt\", package = \"xcmsTutorials\"),     sep = \"\\t\", header = TRUE) head(data) ##    rt intensity ## 1 100         0 ## 2 110         0 ## 3 120         1 ## 4 130         2 ## 5 140         4 ## 6 150         6 chr <- Chromatogram(rtime = data$rt, intensity = data$intensity) par(mar = c(2, 2, 0, 0)) plot(chr) xchr <- findChromPeaks(chr, param = CentWaveParam(sn = 0)) par(mar = c(2, 2, 0, 0)) plot(xchr)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"additional-things","dir":"Articles","previous_headings":"","what":"Additional things","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"extract EICs two peaks using chromPeakChromatograms function. convenience function easier faster extraction EICs selected peaks (specific sample). sam data (samples) also extracted chromatogram function specifying m/z retention time range chromatographic peak. call provide IDs (row names) chromatographic peaks parameter peaks expand retention time range extract data 5 seconds (either side peak) setting expandRt = 5. next plot chromatograms. identified chromatographic peaks automatically highlighted, present, grey color.","code":"#' Extract EIC for two identified chromatographic peaks chrs <- chromPeakChromatograms(data, peaks = c(\"CP499\", \"CP520\"), expandRt = 5) plot(chrs)"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"","code":"sessionInfo() ## R version 4.3.1 (2023-06-16) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               ##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8     ##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    ##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  ##  [9] LC_ADDRESS=C               LC_TELEPHONE=C             ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        ##  ## time zone: Etc/UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats4    stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] RColorBrewer_1.1-3          png_0.1-8                   ##  [3] SummarizedExperiment_1.31.1 GenomicRanges_1.53.1        ##  [5] GenomeInfoDb_1.37.4         IRanges_2.35.2              ##  [7] MatrixGenerics_1.13.1       matrixStats_1.0.0           ##  [9] MetaboCoreUtils_1.9.2       Spectra_1.11.11             ## [11] MsExperiment_1.3.0          xcms_3.99.4                 ## [13] MSnbase_2.27.1              ProtGenerics_1.33.1         ## [15] S4Vectors_0.39.2            mzR_2.35.1                  ## [17] Rcpp_1.0.11                 Biobase_2.61.0              ## [19] BiocGenerics_0.47.0         BiocParallel_1.35.4         ## [21] rmarkdown_2.25              knitr_1.44                  ## [23] BiocStyle_2.29.2            ##  ## loaded via a namespace (and not attached): ##  [1] bitops_1.0-7                rlang_1.1.1                 ##  [3] magrittr_2.0.3              clue_0.3-65                 ##  [5] MassSpecWavelet_1.67.0      compiler_4.3.1              ##  [7] systemfonts_1.0.4           vctrs_0.6.3                 ##  [9] stringr_1.5.0               pkgconfig_2.0.3             ## [11] crayon_1.5.2                fastmap_1.1.1               ## [13] XVector_0.41.1              utf8_1.2.3                  ## [15] preprocessCore_1.63.1       ragg_1.2.5                  ## [17] purrr_1.0.2                 MultiAssayExperiment_1.27.5 ## [19] xfun_0.40                   zlibbioc_1.47.0             ## [21] cachem_1.0.8                jsonlite_1.8.7              ## [23] progress_1.2.2              DelayedArray_0.27.10        ## [25] prettyunits_1.2.0           parallel_4.3.1              ## [27] cluster_2.1.4               R6_2.5.1                    ## [29] bslib_0.5.1                 stringi_1.7.12              ## [31] limma_3.57.8                jquerylib_0.1.4             ## [33] bookdown_0.35               iterators_1.0.14            ## [35] igraph_1.5.1                splines_4.3.1               ## [37] Matrix_1.6-1.1              tidyselect_1.2.0            ## [39] abind_1.4-5                 yaml_2.3.7                  ## [41] doParallel_1.0.17           codetools_0.2-19            ## [43] affy_1.79.3                 lattice_0.21-8              ## [45] tibble_3.2.1                plyr_1.8.8                  ## [47] evaluate_0.21               survival_3.5-7              ## [49] desc_1.4.2                  pillar_1.9.0                ## [51] affyio_1.71.0               BiocManager_1.30.22         ## [53] foreach_1.5.2               MALDIquant_1.22.1           ## [55] ncdf4_1.21                  generics_0.1.3              ## [57] rprojroot_2.0.3             RCurl_1.98-1.12             ## [59] hms_1.1.3                   ggplot2_3.4.3               ## [61] munsell_0.5.0               scales_1.2.1                ## [63] glue_1.6.2                  lazyeval_0.2.2              ## [65] MsFeatures_1.9.0            tools_4.3.1                 ## [67] mzID_1.39.0                 robustbase_0.99-0           ## [69] QFeatures_1.11.2            vsn_3.69.0                  ## [71] RANN_2.6.1                  fs_1.6.3                    ## [73] XML_3.99-0.14               grid_4.3.1                  ## [75] impute_1.75.1               MsCoreUtils_1.13.1          ## [77] colorspace_2.1-0            GenomeInfoDbData_1.2.10     ## [79] cli_3.6.1                   textshaping_0.3.6           ## [81] fansi_1.0.4                 S4Arrays_1.1.6              ## [83] dplyr_1.1.3                 AnnotationFilter_1.25.0     ## [85] pcaMethods_1.93.0           gtable_0.3.4                ## [87] DEoptimR_1.1-2              sass_0.4.7                  ## [89] digest_0.6.33               SparseArray_1.1.12          ## [91] multtest_2.57.0             memoise_2.0.1               ## [93] htmltools_0.5.6             pkgdown_2.0.7               ## [95] lifecycle_1.0.3             statmod_1.5.0               ## [97] MASS_7.3-60"},{"path":"https://jorainer.github.io/xcmsTutorials/articles/xcms-preprocessing.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Thank Philippine Louail fixing typos suggesting improvements.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Rainer. Author, maintainer. Philippine Louail. Contributor.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rainer J (2023). xcmsTutorials: Exploring Analyzing LC-MS data Spectra xcms. R package version 0.99.2, https://jorainer.github.io/xcmsTutorials/.","code":"@Manual{,   title = {xcmsTutorials: Exploring and Analyzing LC-MS data with Spectra and xcms},   author = {Johannes Rainer},   year = {2023},   note = {R package version 0.99.2},   url = {https://jorainer.github.io/xcmsTutorials/}, }"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"exploring-and-analyzing-lc-ms-data-with-spectra-and-xcms","dir":"","previous_headings":"","what":"Exploring and Analyzing LC-MS data with Spectra and xcms","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"workshop provides overview recent developments Bioconductor work mass spectrometry (MsExperiment, Spectra) specifically LC-MS data (xcms) walks preprocessing small data set emphasizing selection data-dependent settings individual pre-processing steps. present workshop represents updated version workshop given Metabolomics Society conference 2018 Seattle (http://metabolomics2018.org). Covered topics : - Data import representation. - Accessing, subsetting visualizing data. - Centroiding profile mode MS data. - Chromatographic peak detection. - Empirically determine appropriate settings analyzed data set. - Evaluation identified peaks. - Alignment (retention time correction). - Correspondence (grouping chromatographic peaks across samples). full R code examples along comprehensive descriptions provided xcms-preprocessing.Rmd file. file can opened e.g. RStudio allows execution individual R commands (see section additionally required R packages). R command rmarkdown::render(\"xcms-preprocessing.Rmd\") generate html file xcms-preprocessing.html.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"-line code evaluation, workshop can also run using self-contained docker image R packages server version RStudio (Posit) pre-installed: Get docker image tutorial docker pull jorainer/xcms_tutorials:latest. Start docker using Enter http://localhost:8787 web browser log username rstudio password bioc. RStudio server version: open R-markdown (.Rmd) files vignettes folder evaluate R code blocks. manual installation, R version >= 4.3.0 required well recent versions packages MsExperiment, Spectra particular xcms (version >= 3.99.0 needed). can installed using code :","code":"docker run \\     -e PASSWORD=bioc \\     -p 8787:8787 \\     jorainer/xcms_tutorials:latest install.packages(\"BiocManager\") BiocManager::install(\"jorainer/xcmsTutorials\",     dependencies = TRUE, ask = FALSE, update = TRUE)"},{"path":"https://jorainer.github.io/xcmsTutorials/index.html","id":"additional-documentation-resources-and-tutorials","dir":"","previous_headings":"","what":"Additional documentation resources and tutorials","title":"Exploring and Analyzing LC-MS data with Spectra and xcms","text":"Tutorial additional examples explanations MS2-based annotations: https://jorainer.github.io/SpectraTutorials/ Repository MsCoreUtils package: https://rformassspectrometry.github.io/MsCoreUtils/ Repository MetaboCoreUtils package: https://rformassspectrometry.github.io/MetaboCoreUtils/ Repository Spectra package: https://rformassspectrometry.github.io/Spectra/ Repository MetaboAnnotation package: https://rformassspectrometry.github.io/MetaboAnnotation/ Repository CompoundDb package: https://rformassspectrometry.github.io/CompoundDb/","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.2","title":"xcmsTutorials 0.99","text":"Add additional visualization options. Require xcms version >= 3.99.4.","code":""},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-99-1","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.99.1","title":"xcmsTutorials 0.99","text":"Add requirements xcms Spectra packages well R version.","code":""},{"path":[]},{"path":"https://jorainer.github.io/xcmsTutorials/news/index.html","id":"changes-in-xcmstutorials-0-2","dir":"Changelog","previous_headings":"","what":"Changes in xcmsTutorials 0.2.0","title":"xcmsTutorials 0.2","text":"Rewrite parts tutorial based feedback corrections provided Philippine Louail.","code":""},{"path":[]}]
