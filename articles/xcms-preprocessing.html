<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="xcmsTutorials">
<title>Exploring and Analyzing LC-MS data with Spectra and xcms • xcmsTutorials</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Exploring and Analyzing LC-MS data with Spectra and xcms">
<meta property="og:description" content="xcmsTutorials">
<meta property="og:image" content="https://jorainer.github.io/xcmsTutorials/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">xcmsTutorials</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.99.3</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/xcms-preprocessing.html">Exploring and Analyzing LC-MS data with Spectra and xcms</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/jorainer/xcmsTutorials/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Exploring and Analyzing LC-MS data with Spectra and xcms</h1>
                        <h4 data-toc-skip class="author">Philippine
Louail, Johannes Rainer</h4>
            <address class="author_afil">
      Eurac Research, Bolzano, Italy; <a href="mailto:johannes.rainer@eurac.edu" class="email">johannes.rainer@eurac.edu</a> github:
jorainer<br><h4 data-toc-skip class="date">October 2023</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jorainer/xcmsTutorials/blob/HEAD/vignettes/xcms-preprocessing.Rmd" class="external-link"><code>vignettes/xcms-preprocessing.Rmd</code></a></small>
      <div class="d-none name"><code>xcms-preprocessing.Rmd</code></div>
    </address>
</div>

    
    
<div class="section level2">
<h2 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h2>
<p>In this document we discuss liquid chromatography (LC) mass
spectrometry (MS) data handling and exploration using the <em><a href="https://bioconductor.org/packages/3.18/MsExperiment" class="external-link">MsExperiment</a></em>
and <code>r Biocpkg("Spectra")</code> Bioconductor packages and perform
the preprocessing of a small LC-MS data set using the <em><a href="https://bioconductor.org/packages/3.18/xcms" class="external-link">xcms</a></em>
package. Functionality from the <em><a href="https://bioconductor.org/packages/3.18/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
and <em><a href="https://bioconductor.org/packages/3.18/MsCoreUtils" class="external-link">MsCoreUtils</a></em>
packages are used for general tasks frequently performed during
metabolomics data analysis. Ultimately, the functionality from these
packages can be combined to build custom, data set-specific (and
reproducible) analysis workflows.</p>
<p>In the present workshop, we first focus on data import, access and
visualization which is followed by the description of a simple data
centroiding approach and finally we present an <em>xcms</em>-based LC-MS
data preprocessing that comprises chromatographic peak detection,
alignment and correspondence. Data normalization procedures, compound
identification and differential abundance analysis are not covered here.
Particular emphasis is given on deriving and defining data set-dependent
values for the most critical <em>xcms</em> preprocessing parameters.</p>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Preprocessing is the first step in the analysis of
<em>untargeted</em> LC-MS or gas chromatography (GC)-MS data. The aim of
the preprocessing is the quantification of signals from ions measured in
a sample, adjusting for any potential retention time drifts between
samples followed by the matching of the quantified signal across samples
within an experiment. The resulting two-dimensional matrix with
abundances of the so called <em>LC-MS features</em> in all samples can
then be further processed, e.g. by normalizing the data to remove
differences due to sample processing, batch effects or injection
order-dependent signal drifts. LC-MS features are usually only
characterized by their mass-to-charge ration (<em>m/z</em>) and
retention time and hence need to be annotated to the actual ions and
metabolites they represent. Data normalization and annotation are not
covered in here but links to related tutorials and workshops are
provided at the end of the document.</p>
<div class="section level3">
<h3 id="mass-spectrometry">Mass spectrometry<a class="anchor" aria-label="anchor" href="#mass-spectrometry"></a>
</h3>
<p>Mass spectrometry allows to measure abundances of charged molecules
(ions) in a sample. Abundances are determined as ion counts for a
specific mass-to-charge ratio <em>m/z</em>. The measured signal is
represented as a spectrum: intensities along <em>m/z</em>.</p>
<p><img src="images/MS.png"></p>
<p>Many ions will result, when measured with MS alone, in a very similar
<em>m/z</em>. Thus, making it difficult or impossible to discriminate
them. MS is therefore frequently coupled with a second technology to
separate them prior quantification based on properties other than their
mass (e.g. based on their polarity). Common choices are gas
chromatography (GC) or liquid chromatography (LC). In a typical LC-MS
setup a sample gets injected into the system, the molecules in the
sample are separated in the LC column, get ionized and then measured (at
discrete time points) by the MS instrument (see Figure below for a
simple visualization). Molecules get thus separated on two different
dimensions, the retention time dimension (from the LC) and the
mass-to-charge dimension (from the MS) making it easier to measure and
identify molecules in more complex samples.</p>
<p><img src="images/LC-MS-drawing.gif"></p>
<p>In such GC/LC-MS based untargeted metabolomics experiments, the data
is analyzed along the retention time dimension and
<em>chromatographic</em> peaks (which are supposed to represent the
signal from ions of a certain type of molecule) are quantified.</p>
</div>
<div class="section level3">
<h3 id="definitions-and-common-naming-convention">Definitions and common naming convention<a class="anchor" aria-label="anchor" href="#definitions-and-common-naming-convention"></a>
</h3>
<p>Naming conventions and terms used in this document are:</p>
<ul>
<li>
<em>chromatographic peak</em>: peak containing the signal from an
ion in retention time dimension (different from a <em>mass</em> peak
that represents the signal along the <em>m/z</em> dimension within a
spectrum).</li>
<li>
<em>chromatographic peak detection</em>: process in which
chromatographic peaks are identified within a sample (file).</li>
<li>
<em>alignment</em>: process that adjusts for retention time
differences (i.e. possible signal drifts from the LC) between
measurements/files.</li>
<li>
<em>correspondence</em>: grouping of chromatographic peaks
(presumably from the same ion) across samples/files.</li>
<li>
<em>feature</em> (or <em>LC-MS features</em>): entity representing
signal from the same type of ion/molecule, characterized by its specific
retention time and <em>m/z</em>. In <em>xcms</em>, features represent
identified chromatographic peaks grouped across samples/files.</li>
</ul>
</div>
<div class="section level3">
<h3 id="goals-of-this-workshop">Goals of this workshop<a class="anchor" aria-label="anchor" href="#goals-of-this-workshop"></a>
</h3>
<ul>
<li><p>Learn how R/<em>xcms</em> and the packages from the
RforMassSpectrometry initiative can be used to inspect, evaluate and
analyze LC-MS data.</p></li>
<li><p>Learn the basis to build reproducible analysis workflows,
tailored and customized for individual data sets.</p></li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="data-import-and-exploration">Data import and exploration<a class="anchor" aria-label="anchor" href="#data-import-and-exploration"></a>
</h2>
<p>The example data set of this workflow consists of two files in mzML
format with signals from pooled human serum samples measured with a
ultra high performance liquid chromatography (UHPLC) system (Agilent
1290) coupled with a Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument.
Chromatographic separation was based on hydrophilic interaction liquid
chromatography (HILIC) separating metabolites depending on their
polarity. The input files contain all signals measured by the MS
instrument (so called <em>profile mode</em> data). To reduce file sizes,
the data set was restricted to an <em>m/z</em> range from 105 to 134 and
retention times from 0 to 260 seconds. Both QC pool samples were taken
from a larger experiment and were injected in the same measurement run
at different time points (injected in position 1 and 19 of the
measurement run).</p>
<p>In the code block below we first load all required libraries and
define the location of the mzML files, which are distributed through the
<em>msdata</em> R package. We also define a <code>data.frame</code> with
the names of the mzML files, an arbitrary sample name, the index in
which the respective sample was measured within the LC-MS run and the
sample <em>group</em> of the samples. It is generally suggested to
provide all experiment-relevant phenotypic and technical information
through such a data frame. Also, the data frame could be defined in an
xls sheet that could then be imported with the <code>read_xlsx</code>
function from the <em>readxl</em> R package. This data frame is then
passed, along with the file names, to the <code>readMsExperiment</code>
call to import the data.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/sneumann/xcms" class="external-link">xcms</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/MsExperiment" class="external-link">MsExperiment</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/Spectra" class="external-link">Spectra</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Define the file names.</span></span>
<span><span class="va">fls</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.files.html" class="external-link">dir</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"sciex"</span>, package <span class="op">=</span> <span class="st">"msdata"</span><span class="op">)</span>, full.names <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Define a data.frame with additional information on these files.</span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="va">fls</span><span class="op">)</span>,</span>
<span>                 sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"POOL_1"</span>, <span class="st">"POOL_2"</span><span class="op">)</span>,</span>
<span>                 injection_index <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">19</span><span class="op">)</span>,</span>
<span>                 group <span class="op">=</span> <span class="st">"POOL"</span><span class="op">)</span></span>
<span><span class="co">#' Import the data of the experiment</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/readMsExperiment.html" class="external-link">readMsExperiment</a></span><span class="op">(</span><span class="va">fls</span>, sampleData <span class="op">=</span> <span class="va">pd</span><span class="op">)</span></span>
<span><span class="va">data</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class MsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span></code></pre>
<p>The MS data of the experiment is now <em>represented</em> by an
<code>MsExperiment</code> object.</p>
<div class="section level3">
<h3 id="basic-data-access">Basic data access<a class="anchor" aria-label="anchor" href="#basic-data-access"></a>
</h3>
<p>The <code>MsExperiment</code> object manages the <em>linkage</em>
between samples and spectra. The <code>length</code> of an
<code>MsExperiment</code> is defined by the number of samples (files)
within the object.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 2</span></span></code></pre>
<p>Subset the <code>MsExperiment</code> will restrict (all) data within
the object to the selected sample(s). To restrict to data from the
second sample we use:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Subset the data</span></span>
<span><span class="va">data_2</span> <span class="op">&lt;-</span> <span class="va">data</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">data_2</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class MsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (931) </span></span>
<span><span class="co">##  Experiment data: 1 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 1 sample(s) to 931 element(s).</span></span></code></pre>
<p>This thus subsetted the full data, including sample information and
spectra data to those of the second file. Phenotype information can be
retrieved with the <code>sampleData</code> function from an
<code>MsExperiment</code> object.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract sample information</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">data_2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 1 row and 5 columns</span></span>
<span><span class="co">##            file      sample injection_index       group spectraOrigin</span></span>
<span><span class="co">##     &lt;character&gt; &lt;character&gt;       &lt;numeric&gt; &lt;character&gt;   &lt;character&gt;</span></span>
<span><span class="co">## 1 20171016_P...      POOL_2              19        POOL /usr/local...</span></span></code></pre>
<p>The MS data is stored as a <code>Spectra</code> object within the
<code>MsExperiment</code> and can be accessed using the
<code>spectra</code> function.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Access the MS data</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##        msLevel     rtime scanIndex</span></span>
<span><span class="co">##      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1            1     0.280         1</span></span>
<span><span class="co">## 2            1     0.559         2</span></span>
<span><span class="co">## 3            1     0.838         3</span></span>
<span><span class="co">## 4            1     1.117         4</span></span>
<span><span class="co">## 5            1     1.396         5</span></span>
<span><span class="co">## ...        ...       ...       ...</span></span>
<span><span class="co">## 1858         1   258.636       927</span></span>
<span><span class="co">## 1859         1   258.915       928</span></span>
<span><span class="co">## 1860         1   259.194       929</span></span>
<span><span class="co">## 1861         1   259.473       930</span></span>
<span><span class="co">## 1862         1   259.752       931</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span></code></pre>
<p>The new version of <em>xcms</em> uses thus the more modern and
flexible infrastructure for MS data analysis provided by the <em><a href="https://bioconductor.org/packages/3.18/Spectra" class="external-link">Spectra</a></em>
package. While it is still possible and supported to use <em>xcms</em>
together with the <code>r Biocpkg("MSnbase")</code> package, users are
advised to switch to this new infrastructure as it provides more
flexibility and a higher performance.</p>
<p>This <code>Spectra</code> object represents the full LC-MS data of
the experiment. Each element in this object is a spectrum (in one
sample/file) with all information provided by the respective original
data (mzML) file. Note that, through additional packages such as the
<em><a href="https://bioconductor.org/packages/3.18/MsBackendRawFileReader" class="external-link">MsBackendRawFileReader</a></em>,
it would also be possible to import MS data from other files than mzML,
mzXML or CDF files.</p>
<p>In the next few examples we briefly explain the <code>Spectra</code>
object and illustrate the use of such objects using some simple
examples. More information on <code>Spectra</code> objects can be found
in the package’s <a href="https://RforMassSpectrometry.github.io/Spectra" class="external-link">documentation</a>
or the <a href="https://jorainer.github.io/SpectraTutorials" class="external-link">SpectraTutorials</a>.
Besides the peak data (<em>m/z</em> and intensity values) also
additional spectra variables (metadata) are available in a
<code>Spectra</code> object. These can be listed using the
<code>spectraVariables</code> function that we call on our example MS
data below. To avoid nested function calls and hence improve the
readability of the code, we use the R pipe operator <code>|&gt;</code>
that allows to concatenate consecutive calls in a more readable
fashion.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' List available spectra variables</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectraVariables</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] "msLevel"                  "rtime"                   </span></span>
<span><span class="co">##  [3] "acquisitionNum"           "scanIndex"               </span></span>
<span><span class="co">##  [5] "dataStorage"              "dataOrigin"              </span></span>
<span><span class="co">##  [7] "centroided"               "smoothed"                </span></span>
<span><span class="co">##  [9] "polarity"                 "precScanNum"             </span></span>
<span><span class="co">## [11] "precursorMz"              "precursorIntensity"      </span></span>
<span><span class="co">## [13] "precursorCharge"          "collisionEnergy"         </span></span>
<span><span class="co">## [15] "isolationWindowLowerMz"   "isolationWindowTargetMz" </span></span>
<span><span class="co">## [17] "isolationWindowUpperMz"   "peaksCount"              </span></span>
<span><span class="co">## [19] "totIonCurrent"            "basePeakMZ"              </span></span>
<span><span class="co">## [21] "basePeakIntensity"        "ionisationEnergy"        </span></span>
<span><span class="co">## [23] "lowMZ"                    "highMZ"                  </span></span>
<span><span class="co">## [25] "mergedScan"               "mergedResultScanNum"     </span></span>
<span><span class="co">## [27] "mergedResultStartScanNum" "mergedResultEndScanNum"  </span></span>
<span><span class="co">## [29] "injectionTime"            "filterString"            </span></span>
<span><span class="co">## [31] "spectrumId"               "ionMobilityDriftTime"    </span></span>
<span><span class="co">## [33] "scanWindowLowerLimit"     "scanWindowUpperLimit"</span></span></code></pre>
<p>Thus, for all spectra we have general information such as the MS
level (<code>"msLevel"</code>) or the retention time
(<code>"rtime"</code>) available. For most of these spectra variables
dedicated accessor functions are available (such as
<code>msLevel</code>, <code>rtime</code>) and in addition it is possible
to access any variable using <code>$</code> and the name of the variable
(like accessing the columns of a <code>data.frame</code>). As an example
we extract below the <code>msLevel</code> spectra variable and use the
<code>table</code> function on the result to get an overview of the
number of spectra from different MS levels available in the object.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' List number of spectra per MS level</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">msLevel</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##    1 </span></span>
<span><span class="co">## 1862</span></span></code></pre>
<p>The present data set contains thus 1,862 spectra, all from MS level
1. In <code>Spectra</code> objects, MS spectra are organized in a linear
fashion, i.e. as a single long list of spectra. The <code>Spectra</code>
thus contains spectra from both data files, first all spectra from the
first file and then from the second, all in the order in which they are
provided in the original data files (hence generally ordered by
retention time). To access spectra from a specific sample we either
subset the <code>MsExperiment</code> to that particular sample or we use
the <code>fromFile</code> function that returns for each spectrum the
index of the file within the <code>MsExperiment</code> to which it
belongs. Below we subset our object to the first data file, extract the
retention times of the spectra from that file and, by using the
<code>head</code> function, display the first 6 of them.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Display the first 6 retention times of spectra from the first sample</span></span>
<span><span class="va">data</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.280 0.559 0.838 1.117 1.396 1.675</span></span></code></pre>
<p>Such basic data summaries can be helpful for a first initial quality
assessment to potentially identify problematic data files with e.g. a
unexpected low number of spectra or sparse spectra (i.e. spectra with
very few mass peaks). As an example we list below the number of spectra
per file in the present data set using <code>fromFile</code> that, as
described above, returns for each spectrum in the data set the index of
the sample/file to which it belongs to.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Count the number of spectra per file</span></span>
<span><span class="va">data</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://lgatto.github.io/MSnbase/reference/Spectrum-class.html" class="external-link">fromFile</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## 931 931</span></span></code></pre>
<p>We could also check the number of peaks per spectrum in the different
data files. The number of peaks per spectrum can be extracted with the
<code>lengths</code> function. Below we extract these values, split them
by file and then calculate the quartiles of the peak counts using the
<code>quantile</code> function.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the distribution of peak counts per file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/S4Vectors/man/splitAsList.html" class="external-link">split</a></span><span class="op">(</span><span class="fu"><a href="https://lgatto.github.io/MSnbase/reference/Spectrum-class.html" class="external-link">fromFile</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">quantile</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $`1`</span></span>
<span><span class="co">##     0%    25%    50%    75%   100% </span></span>
<span><span class="co">##  456.0 1122.5 1536.0 2089.0 3995.0 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`2`</span></span>
<span><span class="co">##     0%    25%    50%    75%   100% </span></span>
<span><span class="co">##  481.0 1101.5 1557.0 2153.5 4088.0</span></span></code></pre>
<p>Thus, for the present data set, the number of spectra and also the
average number of peaks per spectra are comparable.</p>
<p>Individual MS spectra can be accessed by subsetting the
<code>Spectra</code> object returned by <code>spectra</code>. As an
example we below subset the data to the second sample, extract the
spectra from that sample and subset to the spectrum number 123.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract one spectrum from the second file</span></span>
<span><span class="va">sp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">[</span><span class="fl">123</span><span class="op">]</span></span>
<span><span class="va">sp</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 1 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1    34.314       123</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span></code></pre>
<p><em>m/z</em> and intensity values can be extracted from a
<code>Spectra</code> using the <code>mz</code> and
<code>intensity</code> functions that (always) return a list of
<code>numeric</code> vectors with the respective values:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract m/z values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## NumericList of length 1</span></span>
<span><span class="co">## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract intensity values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## NumericList of length 1</span></span>
<span><span class="co">## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0</span></span></code></pre>
<p>Alternatively, the <code>peaksData</code> function could be used to
extract the <em>m/z</em> and intensity values of a spectrum as a (two
column) numeric matrix.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract the full peaks data</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">peaksData</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##            mz intensity</span></span>
<span><span class="co">## [1,] 105.9535         0</span></span>
<span><span class="co">## [2,] 105.9550       282</span></span>
<span><span class="co">## [3,] 105.9565         0</span></span>
<span><span class="co">## [4,] 105.9579       141</span></span>
<span><span class="co">## [5,] 105.9594         0</span></span>
<span><span class="co">## [6,] 106.0596         0</span></span></code></pre>
<p>The total ion signal of a spectrum could be calculated by simply
summing the intensities of all peaks in the spectrum. Below we perform
that operation on the spectrum extracted above.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate total ion signal for the extracted spectrum</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 604912</span></span></code></pre>
<p>The same operation can also be applied to the full data set. As an
example we calculate below the total ion signal for each spectrum in the
first file and determine the distribution of these using the
<code>quantiles</code> function.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the distribution of total ion signal of the first file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        0%       25%       50%       75%      100% </span></span>
<span><span class="co">##   69074.0  445575.5  697201.0  897149.5 1562795.0</span></span></code></pre>
<p>We repeat the operation for the second file.</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Repeat for the second file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        0%       25%       50%       75%      100% </span></span>
<span><span class="co">##   70414.0  404923.5  674512.0  878191.0 1679901.0</span></span></code></pre>
<p>The total ion signals of the two data files is (as expected) similar.
Through the <code>Spectra</code> object we have thus the possibility to
inspect and explore the (raw) MS data of an experiment and use its
functionality to create own quality assessment functions. Alternatively,
also the <em><a href="https://bioconductor.org/packages/3.18/MsQuality" class="external-link">MsQuality</a></em>
package could be to calculate core MS quality metrics on a full
experiment (<code>MsExperiment</code>) or individual data files
(<code>Spectra</code>). TODO: ADD REFERENCE TO MSQUALITY PAPER.</p>
</div>
<div class="section level3">
<h3 id="data-visualization">Data visualization<a class="anchor" aria-label="anchor" href="#data-visualization"></a>
</h3>
<p>Visualization is crucial for quality assessment of MS data. For LC-MS
data visualizing a base peak chromatogram (BPC) or total ion
chromatogram (TIC) would for example allow to evaluate the performance
of the liquid chromatography of the various samples in an experiment. To
create such a plot we below extract the BPC from our data. The BPC
extracts the maximum peak signal from each spectrum in a data file and
allows thus to plot this information (on the y-axis) against the
retention time for that spectrum. While we could also extract these
values similarly to the total ion intensity in the previous section, we
use below the <code>chromatogram</code> function that allows extraction
of chromatographic data from MS data. With parameter
<code>aggregationFun = "max"</code> we define to report the maximum
signal per spectrum (setting <code>aggregationFun = "sum"</code> would
in contrast sum up all intensities of a spectrum and hence create a
TIC).</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract and plot a BPC</span></span>
<span><span class="va">bpc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-14-1.png" width="960"></p>
<p>This plot shows the BPC for each of the two data files (each line
representing one sample) and provides the information at what retention
times signal was measured (thus at what retention times compounds eluted
from the LC column). We can clearly spot regions along the retention
time in which more compounds eluted. Also, the BPC of the two data files
look similar, which is expected since both represent the same sample
pool.</p>
<p>The BPC collapsed the 3-dimensional LC-MS data (<em>m/z</em> by
retention time by intensity) into 2 dimensions (retention time by
intensity). An orthogonal visualization to this would be a <em>base peak
spectrum</em> (BPS) that collapses the data in retention time dimension.
Such a visualization could provide information on the most abundant
masses (or rather mass-to-charge values) in the data set (regardless of
the retention time in which they were measured). In contrast to the BPC
it is however not straight forward to create such a visualization: mass
peaks, even if representing signal from the same ion, will never be
identical between consecutive spectra, but will slightly differ based on
the measurement error/resolution of the instrument.</p>
<p>Below we plot the spectra for 2 consecutive scans.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="fl">123</span><span class="op">:</span><span class="fl">124</span><span class="op">]</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">105</span>, <span class="fl">130</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-15-1.png" alt="Spectra from two consecutive scan of the first file" width="960"><p class="caption">
Spectra from two consecutive scan of the first file
</p>
</div>
<p>These two spectra could now be merged by reporting for each
<em>m/z</em> (or rather for peaks with very similar <em>m/z</em> in
consecutive spectra) the maximal signal observed. In <em>Spectra</em>,
the <code>combineSpectra</code> function allows to aggregate/combine
sets of spectra into a single spectrum. By default, this function will
combine sets of spectra (that can be defined with parameter
<code>f</code>) creating an union of the peaks present in spectra of a
set. For mass peaks with a similar <em>m/z</em> value (depending on
parameter <code>ppm</code>) the peaks’ intensities are aggregated using
the function defined with parameter <code>intensityFun</code> and only
one peak is reported. With the setting below we combine all spectra from
one file (by using <code>f = fromFile(data)</code>) into a single
spectrum containing mass peaks present in any of the spectra of that
file. Mass peaks with a difference in their <em>m/z</em> that is smaller
than <code>ppm</code> (parts-per-million of the <em>m/z</em> value) are
combined into one peak for which the maximal intensity of the grouped
peaks is reported. Note that we set <code>ppm</code> to a rather small
value because the present data is in profile mode.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Combine all spectra of one file into a single spectrum</span></span>
<span><span class="va">bps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/Spectra.html" class="external-link">combineSpectra</a></span><span class="op">(</span>f <span class="op">=</span> <span class="fu"><a href="https://lgatto.github.io/MSnbase/reference/Spectrum-class.html" class="external-link">fromFile</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>, ppm <span class="op">=</span> <span class="fl">5</span>, intensityFun <span class="op">=</span> <span class="va">max</span><span class="op">)</span></span>
<span><span class="va">bps</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 2 spectra in a MsBackendMemory backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1     0.280         1</span></span>
<span><span class="co">## 2         1     0.275         1</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Switch backend from MsBackendMzR to MsBackendMemory [Fri Sep 29 13:09:01 2023]</span></span>
<span><span class="co">##  Switch backend from MsBackendMzR to MsBackendMemory [Fri Sep 29 13:09:03 2023]</span></span>
<span><span class="co">##  Merge 2 Spectra into one [Fri Sep 29 13:09:05 2023]</span></span></code></pre>
<p><code>bps</code> is thus a <code>Spectra</code> with two spectra
representing the BPS of the two data files. Below we plot these.</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the BPS</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">bps</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-17-1.png" alt="Base peak spectrum for each of the two samples." width="960"><p class="caption">
Base peak spectrum for each of the two samples.
</p>
</div>
<p>These BPS thus show the most common ions present in each of the two
samples. Apparently there is quite some overlap in ion content between
the two files.</p>
<p>Apart from such general data overview it is also possible (and also
suggested) to explore the data in more detail. To this end we next focus
on a specific subset of the data were we expect signal for a compound
that should be present in serum samples (such as ions of the molecule
serine). With the particular LC-MS setup used for the present samples,
ions for this metabolite are expected to elute at about 180 seconds
(this retention time was determined by measuring a pure standard for
this compound on the same LC-MS setup). We thus filter below the spectra
data using the <code>filterRt</code> function extracting only spectra
measured between 180 and 181 seconds.</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">180</span>, <span class="fl">181</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">sps</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1   180.240       646</span></span>
<span><span class="co">## 2         1   180.519       647</span></span>
<span><span class="co">## 3         1   180.798       648</span></span>
<span><span class="co">## 4         1   180.235       646</span></span>
<span><span class="co">## 5         1   180.514       647</span></span>
<span><span class="co">## 6         1   180.793       648</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Filter: select retention time [180..181] on MS level(s) 1 [Fri Sep 29 13:09:06 2023]</span></span></code></pre>
<p>For the present data set there are 6 spectra measured within this one
second in both samples. By extracting the data as a <code>Spectra</code>
object we have however lost now the direct (inherent) association
between spectra and samples of the experiment. We could extract the name
of the original data file from which the data was imported (see example
below) and use that to determine the originating sample, but that would
involve additional R code.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">dataOrigin</a></span><span class="op">(</span><span class="va">sps</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "20171016_POOL_POS_1_105-134.mzML" "20171016_POOL_POS_1_105-134.mzML"</span></span>
<span><span class="co">## [3] "20171016_POOL_POS_1_105-134.mzML" "20171016_POOL_POS_3_105-134.mzML"</span></span>
<span><span class="co">## [5] "20171016_POOL_POS_3_105-134.mzML" "20171016_POOL_POS_3_105-134.mzML"</span></span></code></pre>
<p>Alternatively, we could use the <code>filterRt</code> function also
directly on the <code>MsExperiment</code> which would subset the whole
<code>MsExperiment</code> keeping hence the link between samples and
spectra. Note however that only few filter and subset functions are at
present available for <code>MsExperiment</code> objects while more are
available for <code>Spectra</code> objects.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' subset the whole MsExperiment</span></span>
<span><span class="va">data_sub</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span><span class="va">data</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">180</span>, <span class="fl">181</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#' extract spectra from the subset for the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data_sub</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1   180.240       646</span></span>
<span><span class="co">## 2         1   180.519       647</span></span>
<span><span class="co">## 3         1   180.798       648</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Filter: select retention time [180..181] on MS level(s) 1 [Fri Sep 29 13:09:06 2023]</span></span></code></pre>
<p>For the present purpose it is however not important to keep the
sample association intact and we thus proceed to plot the previously
extracted spectra.</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">sps</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-21-1.png" alt="MS1 spectra measured between 180 and 181 seconds" width="960"><p class="caption">
MS1 spectra measured between 180 and 181 seconds
</p>
</div>
<p>We can immediately spot several mass peaks in the spectrum, with the
largest one at an <em>m/z</em> of about 130 seconds and the second
largest at about 106, which could represent signal for an ion of <a href="https://en.wikipedia.org/wiki/Serine" class="external-link">Serine</a>. Below we
calculate the exact (monoisotopic) mass for serine from its chemical
formula <em>C3H7NO3</em> using the <code>calculateMass</code> function
from the <em><a href="https://bioconductor.org/packages/3.18/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
package.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></span><span class="op">)</span></span>
<span><span class="va">mass_serine</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/calculateMass.html" class="external-link">calculateMass</a></span><span class="op">(</span><span class="st">"C3H7NO3"</span><span class="op">)</span></span>
<span><span class="va">mass_serine</span></span></code></pre></div>
<pre><code><span><span class="co">##  C3H7NO3 </span></span>
<span><span class="co">## 105.0426</span></span></code></pre>
<p>The <em>native</em> serine molecule is however uncharged and can thus
not be measured by mass spectrometry. In order to be detectable,
molecules need to be ionized before being injected in an MS instrument.
While different ions can (and will) be generated for a molecule, one of
the most commonly generated ions in positive polarity is the
<em>[M+H]+</em> ion (protonated ion). To calculate the <em>m/z</em>
values for specific ions/adducts of molecules, we can use the
<code>mass2mz</code> function, also from the <em>MetaboCoreUtils</em>
package. Below we calculate the <em>m/z</em> for the <em>[M+H]+</em> ion
of serine providing the monoisotopic mass of that molecule and
specifying the adduct we are interested in. Also other types of adducts
are supported. These could be listed with the <code>adductNames</code>
function (<code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/adductNames.html" class="external-link">adductNames()</a></code> for all positively charged and
<code>adductNames("negative")</code> for all negatively charge
ions).</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">serine_mz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/mass2mz.html" class="external-link">mass2mz</a></span><span class="op">(</span><span class="va">mass_serine</span>, <span class="st">"[M+H]+"</span><span class="op">)</span></span>
<span><span class="va">serine_mz</span></span></code></pre></div>
<pre><code><span><span class="co">##           [M+H]+</span></span>
<span><span class="co">## C3H7NO3 106.0499</span></span></code></pre>
<p>The <code>mass2mz</code> function <strong>always</strong> returns a
<code>matrix</code> with columns reporting the <em>m/z</em> for the
requested adduct(s) of the molecule(s) which are available in the rows.
Since we requested a single ion we reduce this <code>matrix</code> to a
single <code>numeric</code> value.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">serine_mz</span> <span class="op">&lt;-</span> <span class="va">serine_mz</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span></span></code></pre></div>
<p>We can now use this information to subset the MS data to the signal
recorded for all ions with that particular <em>m/z</em>. We use again
the <code>chromatogram</code> function and provide the <em>m/z</em>
range of interest with the <code>mz</code> parameter of that function.
Note that it would also be possible to first filter the data set by
<em>m/z</em> using the <code>filterMzRange</code> function and then
extract the chromatogram.</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract an full RT chromatogram for ions with an m/z similar than serine</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-25-1.png" alt="Ion trace for an ion of serine" width="960"><p class="caption">
Ion trace for an ion of serine
</p>
</div>
<p>A strong signal is visible around a retention time of 180 seconds
which very likely represents signal for the <em>[M+H]+</em> ion of
serine. Note that, if the retention time of a molecule for a specific
LC-MS setup is not known beforehand, extracting such chromatograms for
the <em>m/z</em> of interest and the full retention time range can help
determining its likely retention time.</p>
<p>The object returned by the <code>chromatogram</code> function
arranges the individual <code>MChromatogram</code> objects (each
representing the chromatographic data consisting of pairs of retention
time and intensity values of one sample) in a two-dimensional array,
columns being samples (files) and rows data slices (i.e., <em>m/z</em> -
rt ranges). Note that this type of data representation, defined in the
<em><a href="https://bioconductor.org/packages/3.18/MSnbase" class="external-link">MSnbase</a></em>
package, is likely to be replaced in future with a more efficient and
flexible data structure similar to <code>Spectra</code>. Data from the
individual chromatograms can be accessed using the
<code>intensity</code> and <code>rtime</code> functions (similar to the
<code>mz</code> and <code>intensity</code> functions for a
<code>Spectra</code> object).</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' get intensity valuesfor the chromatogram of the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1]  NA 559 659 278 492  NA</span></span></code></pre>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' get the respective retention times of the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.280 0.559 0.838 1.117 1.396 1.675</span></span></code></pre>
<p>Note that an <code>NA</code> is reported if in the <em>m/z</em> range
from which the chromatographic data was extracted no intensity was
measured at the given retention time.</p>
<p>At last we further focus on the tentative signal of serine extracting
the ion chromatogram restricting on the retention time range containing
its signal. While we could also pass the retention time and <em>m/z</em>
range with parameters <code>rt</code> and <code>mz</code> to the
<code>chromatogram</code> function we instead filter the whole
experiment by retention time and <em>m/z</em> before calling
<code>chromatogram</code> on the such created data subset. With the
example code below we thus create an extracted ion chromatogram (EIC,
sometimes also referred to as XIC) for the <em>[M+H]+</em> ion of
serine.</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create an EIC for serine</span></span>
<span><span class="va">data</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMz</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-26-1.png" alt="Extracted ion chromatogram for serine." width="960"><p class="caption">
Extracted ion chromatogram for serine.
</p>
</div>
<p>The area of such a chromatographic peak is supposed to be
proportional to the amount of the corresponding ion in the respective
sample and identification and quantification of such peaks is one of the
goals of the LC-MS data preprocessing.</p>
<p>While we inspected here the signal measured for ions of serine, this
workflow could (and should) also be repeated for other potentially
present ions (or internal standards) to evaluate the LC-MS data of an
experiment.</p>
</div>
</div>
<div class="section level2">
<h2 id="centroiding-of-profile-ms-data">Centroiding of profile MS data<a class="anchor" aria-label="anchor" href="#centroiding-of-profile-ms-data"></a>
</h2>
<p>MS instruments allow to export data in profile or centroid mode.
Profile data contains the signal for all discrete <em>m/z</em> values
(and retention times) for which the instrument collected data <span class="citation">(R. Smith et al. 2014)</span>. MS instruments
continuously sample and record signals, therefore a mass peak for a
single ion in one spectrum will consist of multiple intensities at
discrete <em>m/z</em> values. The process to reduce this distribution of
signals to a single representative mass peak (the centroid) is called
centroiding. This process results in much smaller file sizes, with only
little information loss. <em>xcms</em>, specifically the
<em>centWave</em> chromatographic peak detection algorithm, was designed
for centroided data, thus, prior to data analysis, profile data, such as
the example data used here, should be centroided.</p>
<p>Below we inspect the profile data for one of the spectra extracted
above and focus on the mass peak for serine.</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Visualize the profile-mode mass peak for [M+H]+ of serine</span></span>
<span><span class="va">sps</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">filterMzRange</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="va">serine_mz</span>, col <span class="op">=</span> <span class="st">"#ff000080"</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-27-1.png" alt="Profile-mode mass peak for the [M+H]+ ion of serine. The theoretical *m/z* of that ion is indicated with a dotted red line." width="960"><p class="caption">
Profile-mode mass peak for the [M+H]+ ion of serine. The theoretical
<em>m/z</em> of that ion is indicated with a dotted red line.
</p>
</div>
<p>Instead of a single peak, several mass peaks were recorded by the MS
instrument with an <em>m/z</em> very close to the theoretical
<em>m/z</em> for the <em>[M+H]+</em> ion of serine (indicated with a red
dotted line).</p>
<p>We can also visualize this information differently: the
<code>plot</code> function for <code>MsExperiment</code> generates a
two-dimensional visualization of the three-dimensional LC-MS data: peaks
are drawn at their respective location in the two-dimensional
<em>m/z</em> <em>vs</em> retention time plane with their intensity being
color coded. Below we subset the data to the <em>m/z</em> - retention
time region containing signal for serine and visualize the full MS data
measured for that region in both data files.</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMz</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/serine-profile-mode-data-1.png" alt="Profile data for Serine." width="960"><p class="caption">
Profile data for Serine.
</p>
</div>
<p>The lower panel of the plot shows all mass peaks measured by the
instrument: each point represents one mass peak with its intensity being
color coded (blue representing low, yellow high intensity). Each column
of data points represents data from the same spectrum. The upper panel
of the plot shows a chromatographic visualization of the data from the
lower panel, i.e., for each retention time (spectrum) the sum of
intensities is shown.</p>
<p>Note that, while it would be possible to create such a plot for the
full MS data of an experiment, this type of visualization works best for
small <em>m/z</em> - retention time regions.</p>
<p>Next, we <em>smooth</em> the data in each spectrum using a
Savitzky-Golay filter, which usually improves data quality by reducing
noise. Subsequently we perform the centroiding of the data based on a
simple peak-picking strategy that reports the maximum signal for each
mass peak in each spectrum. Finally, we replace the spectra in data
(<code>MsExperiment</code>) object with the centroided spectra and
visualize the result repeating the visualization from above.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Smooth and centroid the spectra data</span></span>
<span><span class="va">sps_cent</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">smooth</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"SavitzkyGolay"</span>, halfWindowSize <span class="op">=</span> <span class="fl">6L</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">pickPeaks</a></span><span class="op">(</span>halfWindowSize <span class="op">=</span> <span class="fl">2L</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' replace spectra</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">sps_cent</span></span>
<span></span>
<span><span class="co">#' Plot the centroided data for Serine</span></span>
<span><span class="va">data</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMz</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/centroiding-1.png" alt="Centroided data for Serine." width="960"><p class="caption">
Centroided data for Serine.
</p>
</div>
<p>The impact of the centroiding is clearly visible: each signal for an
ion in a spectrum was reduced to a single data point. For more advanced
centroiding options, that can also fine-tune the <em>m/z</em> value of
the reported centroid, see the documentation of the
<code>pickPeaks</code> function or the centroiding vignette of the
<em><a href="https://bioconductor.org/packages/3.18/MSnbase" class="external-link">MSnbase</a></em>
package.</p>
<p>While we could now simply proceed with the data analysis, we below
save the centroided MS data to mzML files to also illustrate how the
<em>Spectra</em> package can be used to export MS data.</p>
<p>We use the <code>export</code> function for data export of the
centroided <code>Spectra</code> object. Parameter <code>backend</code>
allows to specify the MS data backend that should be used for the
export, and that will also define the data format (use
<code>backend = MsBackendMzR()</code> to export data in mzML format).
Parameter <code>file</code> defines, for each spectrum, the name of the
file to which its data should be exported.</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Export the centroided data to new mzML files.</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">export</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>, backend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/MsBackend.html" class="external-link">MsBackendMzR</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>       file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">dataOrigin</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We can then import the centroided data again from the newly generated
mzML files and proceed with the analysis.</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Re-import the centroided data.</span></span>
<span><span class="va">fls</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="va">fls</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Read the centroided data.</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/readMsExperiment.html" class="external-link">readMsExperiment</a></span><span class="op">(</span><span class="va">fls</span>, sampleData <span class="op">=</span> <span class="va">pd</span><span class="op">)</span></span></code></pre></div>
<p>This, or similar, code would allow to create scripts to batch-perform
an R-based centroiding.</p>
</div>
<div class="section level2">
<h2 id="preprocessing-of-lc-ms-data">Preprocessing of LC-MS data<a class="anchor" aria-label="anchor" href="#preprocessing-of-lc-ms-data"></a>
</h2>
<p>Preprocessing of (untargeted) LC-MS data aims at detecting and
quantifying the signal from ions generated from all molecules present in
a sample. It consists of the following 3 steps: chromatographic peak
detection, alignment (also called retention time correction) and
correspondence (also called peak grouping). The resulting matrix of
feature abundances can then be used as an input in downstream analyses
including data normalization, identification of features of interest and
annotation of features to metabolites.</p>
<div class="section level3">
<h3 id="chromatographic-peak-detection">Chromatographic peak detection<a class="anchor" aria-label="anchor" href="#chromatographic-peak-detection"></a>
</h3>
<p>Chromatographic peak detection aims to identify peaks along the
retention time axis that represent the signal from individual compounds’
ions. This involves identifying and quantifying such signals as shown in
the sketch below.</p>
<div class="float">
<img src="images/LCMS-data-peaks.png" alt="Chromatographic peak detection"><div class="figcaption">Chromatographic peak detection</div>
</div>
<p>Such peak detection can be performed with the <em>xcms</em> package
using its <code>findChromPeaks</code> function. Several peak detection
algorithms are available that can be selected and configured with their
specific parameter objects:</p>
<ul>
<li>
<code>MatchedFilterParam</code> to perform peak detection as
described in the original <em>xcms</em> article <span class="citation">(C. A. Smith et al. 2006)</span>,</li>
<li>
<code>CentWaveParam</code> to perform a continuous wavelet
transformation (CWT)-based peak detection <span class="citation">(Tautenhahn, Böttcher, and Neumann 2008)</span>
and</li>
<li>
<code>MassifquantParam</code> to perform a Kalman filter-based peak
detection <span class="citation">(Conley et al. 2014)</span>.</li>
</ul>
<p>Additional peak detection algorithms for direct injection data are
also available in <em>xcms</em>, but not discussed here.</p>
<p>In our example we use the <em>centWave</em> algorithm that performs
peak detection in two steps: first it identifies <em>regions of
interest</em> in the <em>m/z</em> - retention time space and
subsequently detects peaks in these regions using a continuous wavelet
transform (see the original publication <span class="citation">(Tautenhahn, Böttcher, and Neumann 2008)</span> for
more details). The algorithm can be configured with several parameters
(see <code><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">?CentWaveParam</a></code>), with the most important being
<code>peakwidth</code> and <code>ppm</code>. <code>peakwidth</code>
defines the minimal and maximal expected width of the peak in retention
time dimension and depends thus on the setup of the employed LC-MS
system making this parameter highly data set dependent. <code>ppm</code>
on the other hand depends on the precision of the MS instrument. In this
section we describe how settings for these parameters can be empirically
determined for a data set.</p>
<p>Generally, it is strongly discouraged to blindly use the default
parameters for any of the peak detection algorithms. To illustrate this
we below extract the EIC for serine and run a <em>centWave</em>-based
peak detection on that data using <em>centWave</em>’s default
settings.</p>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the EIC for serine in all files</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">164</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>                           mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>                           aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Get default centWave parameters</span></span>
<span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' "dry-run" peak detection on the EIC.</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      rt rtmin rtmax into intb maxo sn row column</span></span></code></pre>
<p>The peak matrix returned by <code>chromPeaks</code> is empty, thus,
with the default settings <em>centWave</em> failed to identify any
chromatographic peak in the EIC for serine. These default values are
shown below.</p>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cwp</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class:  CentWaveParam </span></span>
<span><span class="co">##  Parameters:</span></span>
<span><span class="co">##  - ppm: [1] 25</span></span>
<span><span class="co">##  - peakwidth: [1] 20 50</span></span>
<span><span class="co">##  - snthresh: [1] 10</span></span>
<span><span class="co">##  - prefilter: [1]   3 100</span></span>
<span><span class="co">##  - mzCenterFun: [1] "wMean"</span></span>
<span><span class="co">##  - integrate: [1] 1</span></span>
<span><span class="co">##  - mzdiff: [1] -0.001</span></span>
<span><span class="co">##  - fitgauss: [1] FALSE</span></span>
<span><span class="co">##  - noise: [1] 0</span></span>
<span><span class="co">##  - verboseColumns: [1] FALSE</span></span>
<span><span class="co">##  - roiList: list()</span></span>
<span><span class="co">##  - firstBaselineCheck: [1] TRUE</span></span>
<span><span class="co">##  - roiScales: numeric(0)</span></span>
<span><span class="co">##  - extendLengthMSW: [1] FALSE</span></span></code></pre>
<p>Particularly the settings for <code>peakwidth</code> does not fit our
data. The default for this parameter expects chromatographic peaks
between 20 and 50 seconds wide. When we plot the extracted ion
chromatogram (EIC) for serine we can however see that these values are
too large for the present data set (see below).</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-29-1.png" alt="Extracted ion chromatogram for serine." width="960"><p class="caption">
Extracted ion chromatogram for serine.
</p>
</div>
<p>For serine, the chromatographic peak is about 5 seconds wide. We thus
adapt the <code>peakwidth</code> for the present data set and repeat the
peak detection using these settings. In general, the lower and upper
peak width should be set to include most of the chromatographic peak
widths. For the present data set we set the values to 2 to 10 seconds,
i.e., to about half and two times the expected peak width. In addition,
by setting <code>integrate = 2</code>, we select a different peak
boundary estimation algorithm. This works particularly well for
non-gaussian peak shapes and ensures that also signal from the peak’s
tail is integrated (eventually re-run the code with the default
<code>integrate = 1</code> to compare the two approaches).</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>peakwidth <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">10</span><span class="op">)</span>, integrate <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Run peak detection on the EIC</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the data and higlight identified peak area</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/centWave-adapted-1.png" alt="EIC for Serine with detected chromatographic peak" width="960"><p class="caption">
EIC for Serine with detected chromatographic peak
</p>
</div>
<p>Acceptable values for parameter <code>peakwidth</code> can thus be
derived through visual inspection of EICs for ions known to be present
in the sample (e.g. of internal standards). Ideally, this should be done
for several compounds/ions. Tip: ensure that the EIC contains also
enough signal left and right of the actual chromatographic peak to allow
<em>centWave</em> to properly estimate the background noise.
Alternatively, reduce the value for the <code>snthresh</code>
parameter.</p>
<p>With our data set-specific <code>peakwidth</code> we were able to
detect the peak for serine (highlighted in grey in the plot above). We
can now use the <code>chromPeaks</code> function to extract the
information on identified chromatographic peaks from our object.</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract identified chromatographic peaks from the EIC</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           rt   rtmin   rtmax     into     intb     maxo  sn row column</span></span>
<span><span class="co">## [1,] 181.356 178.566 189.447 74443.95 71734.01 37664.94 110   1      1</span></span>
<span><span class="co">## [2,] 181.072 178.561 187.210 70352.22 69008.98 38517.76 224   1      2</span></span></code></pre>
<p>The result is returned as a <code>matrix</code> with each row
representing one identified chromatographic peak. The retention time
ranges of the peaks are provided in columns <code>"rtmin"</code> and
<code>"rtmax"</code>, the integrated peak area (i.e., the
<em>abundance</em> of the ion) in column <code>"into"</code>, the
maximal signal of the peak in column <code>"maxo"</code> and the signal
to noise ratio in column<code>"sn"</code>. With our adapted settings we
were thus able to identify a chromatographic peak for the serine ion in
each of the two samples.</p>
<p>The second important parameter for <em>centWave</em> is
<code>ppm</code> which is used in the initial definition of the
<em>regions of interest</em> (ROI) in which the actual peak detection is
then performed. To define these ROI, the algorithm evaluates for each
mass peak in a spectrum whether a mass peak with a similar <em>m/z</em>
(and a reasonably high intensity) is also found in the subsequent
spectrum. For this, only mass peaks with a difference in their
<em>m/z</em> smaller than <code>ppm</code> in consecutive scans are
considered. To illustrate this, we plot again the full MS data for the
data subset containing signal for serine.</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Restrict the data to signal from Serine</span></span>
<span><span class="va">srn</span> <span class="op">&lt;-</span> <span class="va">data</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">179</span>, <span class="fl">186</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMz</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.04</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the data</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">srn</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/Serine-mz-scattering-plot-1.png" width="960"></p>
<p>We can observe some scattering of the data points around an
<em>m/z</em> of 105.05 in the lower panel of the above plot. This
scattering also decreases with increasing signal intensity (as for many
MS instruments the precision of the signal increases with the
intensity). To investigate the observed differences in <em>m/z</em>
values for the signal of serine we below first subset the data to the
first file and then restrict the <em>m/z</em> range further to values
between 106.045 and 106.055.</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Reduce the data set to signal of the [M+H]+ ion of serine</span></span>
<span><span class="va">srn_1</span> <span class="op">&lt;-</span> <span class="va">srn</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">filterMzRange</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.045</span>, <span class="fl">106.055</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>This restricted the MS data to spectra with a single mass peak per
spectrum (presumably representing signal from the serine ion).</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="va">srn_1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span></code></pre>
<p>We next extract the <em>m/z</em> values of the peaks from the
consecutive scans and calculate the absolute difference between
them.</p>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the difference in m/z values between scans</span></span>
<span><span class="va">mz_diff</span> <span class="op">&lt;-</span> <span class="va">srn_1</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">mz_diff</span></span></code></pre></div>
<pre><code><span><span class="co">##                                     mz           mz           mz           mz </span></span>
<span><span class="co">## 2.904861e-03 4.357321e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 1.684509e-05 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 7.624200e-07 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 1.425717e-03 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz </span></span>
<span><span class="co">## 1.493783e-03</span></span></code></pre>
<p>We can also express these differences in ppm (parts per million) of
the average <em>m/z</em> of the peaks.</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Differences in m/z values expressed as ppm</span></span>
<span><span class="va">mz_diff</span> <span class="op">*</span> <span class="fl">1e6</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">srn_1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                                     mz           mz           mz           mz </span></span>
<span><span class="co">## 27.391410160 41.087396603 27.391691523  1.112566483 13.695817196  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">##  0.158840954  0.000000000  0.000000000  0.682099561  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">##  0.007189246 13.695808133 13.695808133 12.807212147  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 13.443812242  0.000000000 13.695807986 13.957023433  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz </span></span>
<span><span class="co">## 14.085643094</span></span></code></pre>
<p>The difference in <em>m/z</em> values for the serine data is thus
between 0 and 27 ppm. The maximum value could then be used for
centWave’s <code>ppm</code> parameter. Ideally, this should be evaluated
for several ions and could be set to a value that allows to capture the
full chromatographic peaks for most of the tested ions. We can next
perform the peak detection on the full data set using our settings for
the <code>ppm</code> and <code>peakwidth</code> parameters.</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform peak detection on the full data set</span></span>
<span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>peakwidth <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">10</span><span class="op">)</span>, ppm <span class="op">=</span> <span class="fl">30</span>, integrate <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span></code></pre></div>
<p>The results form the chromatographic peak detection were added by the
<code>findChromPeaks</code> to our <code>data</code> variable which now
is an <code>XcmsExperiment</code> object that, by extending the
<code>MsExperiment</code> class inherits all of its functionality and
properties, but in addition contains also all <em>xcms</em>
preprocessing results.</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class XcmsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span>
<span><span class="co">##  xcms results:</span></span>
<span><span class="co">##   - chromatographic peaks: 653 in MS level(s): 1</span></span></code></pre>
<p>We can extract the results from the peak detection step (as above)
with the <code>chromPeaks</code> function. The optional parameters
<code>rt</code> and <code>mz</code> would allow to extract peak
detection results for a specified <em>m/z</em> - retention time region.
In our example we extract all chromatographic peaks between an
<em>m/z</em> range from 106 to 108 and a retention time from 150 to
190.</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Access the peak detection results from a specific m/z - rt area</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106</span>, <span class="fl">108</span><span class="op">)</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">150</span>, <span class="fl">190</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb</span></span>
<span><span class="co">## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   510.5323</span></span>
<span><span class="co">## CP146 107.0653 107.0652 107.0653 173.543 171.032 179.682 11318.2801 11308.5538</span></span>
<span><span class="co">## CP156 107.0532 107.0522 107.0537 181.356 179.682 183.309  2905.1158  2899.2205</span></span>
<span><span class="co">## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73916.8683</span></span>
<span><span class="co">## CP475 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.2785</span></span>
<span><span class="co">## CP482 107.0656 107.0655 107.0657 172.980 169.632 178.003 11372.6845 11166.3372</span></span>
<span><span class="co">## CP497 107.0538 107.0510 107.0540 181.072 178.840 183.304  3155.0100  3149.2053</span></span>
<span><span class="co">## CP516 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70106.7152</span></span>
<span><span class="co">##             maxo  sn sample</span></span>
<span><span class="co">## CP133   426.6084  38      1</span></span>
<span><span class="co">## CP146  4936.6783 833      1</span></span>
<span><span class="co">## CP156  1628.9510 129      1</span></span>
<span><span class="co">## CP167 37664.9371 688      1</span></span>
<span><span class="co">## CP475   381.6084  53      2</span></span>
<span><span class="co">## CP482  4569.1399  79      2</span></span>
<span><span class="co">## CP497  2297.7972 230      2</span></span>
<span><span class="co">## CP516 38517.7622 826      2</span></span></code></pre>
<p>Again, each row in this matrix contains one identified
chromatographic peak with columns <code>"mz"</code>,
<code>"mzmin"</code>, <code>"mzmax"</code>, <code>"rt"</code>,
<code>"rtmin"</code> and <code>"rtmax"</code> defining it’s
<em>position</em> (and size) in the <em>m/z</em> - rt plane and
<code>"into"</code> and <code>"maxo"</code> its (integrated and maximum)
intensity. Column <code>"sample"</code> indicates in which of our
samples (data files) the peak was identified.</p>
<p>The chromatographic peak table above contains pairs of peaks with
similar retention times and a difference in <em>m/z</em> values of about
one. Together with the observed differences in intensities, this could
indicate that one of the peaks represents the carbon 13 isotope and one
the monoisotopic <em>main</em> peak. This is frequently observed in
untargeted metabolomics.</p>
<p>As a general overview of the peak detection results it can also be
helpful to determine (and eventually) plot the number of identified
chromatographic peaks per sample. Below we count the number of peaks per
sample.</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Count peaks per file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span>, <span class="st">"sample"</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## 326 327</span></span></code></pre>
<p>About the same number of peaks was identified, which is to be
expected since both files contain measurements from the same sample (the
QC pool).</p>
<p>As an additional visual quality assessment, we can also plot the
location of the identified chromatographic peaks in the <em>m/z</em> -
retention time space for each data file using the
<code>plotChromPeaks</code> function.</p>
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the location of peaks in the m/z - rt plane</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/plotChromPeaks-1.png" alt="Location of the identified chromatographic peaks in the *m/z* - rt space." width="960"><p class="caption">
Location of the identified chromatographic peaks in the <em>m/z</em> -
rt space.
</p>
</div>
<p>Again, similar pattern are expected to be present for the two data
files.</p>
<p>After chromatographic peak detection it is generally a good idea to
visually inspect individual chromatographic peaks and evaluate the
performance of the peak detection step. This could be done by plotting
EICs of known compounds/ions in the data or by randomly select
chromatographic peaks. <em>m/z</em> - retention time regions for random
peaks could be defined using the example code below.</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Select 4 random peaks</span></span>
<span><span class="va">idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract m/z-rt regions for 4 random peaks</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[</span><span class="va">idx</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"rtmin"</span>, <span class="st">"rtmax"</span>, <span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' Expand the rt range by 10 seconds on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">10</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">10</span></span>
<span><span class="co">#' Expand the m/z range by 0.005 on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">0.005</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">0.005</span></span></code></pre></div>
<p>For our example we however manually define <em>m/z</em> - retention
time regions (similarly as it could be done for known compounds). Below
we extract the EICs for these regions with the <code>chromatogram</code>
function and subsequently plot them. Identified chromatographic peaks
within the plotted regions will by default be highlighted in a
semitransparent grey color.</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define m/z - retention time regions for EICs</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.045</span>, <span class="fl">106.055</span>, <span class="fl">165</span>, <span class="fl">195</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">132.096</span>, <span class="fl">132.107</span>, <span class="fl">135</span>, <span class="fl">160</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125.981</span>, <span class="fl">125.991</span>, <span class="fl">195</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">105.468</span>, <span class="fl">105.478</span>, <span class="fl">190</span>, <span class="fl">215</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract the EICs</span></span>
<span><span class="va">eics</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span>, <span class="op">)</span></span>
<span><span class="co">#' Plot the EICs</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">eics</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-38-1.png" width="960"></p>
<p>While the peak detection worked nicely for the signals in the upper
row, it failed to define chromatographic peaks containing the full
signal in the lower row. In both cases, the signal was split into
separate chromatographic peaks within the same sample. This is a common
problem with <em>centWave</em> on noisy and broad signals. We could
either try to adapt the <em>centWave</em> settings and repeat the
chromatographic peak detection or use the <code>refineChromPeaks</code>
function that allows to post-process peak detection results and fix
problems such as those observed above (see also the documentation of the
<code>refineChromPeaks</code> function for all possible refinement
options).</p>
<p>To fuse the wrongly split peaks in the second row, we use the
<code>MergeNeighboringPeaksParam</code> algorithm and configure it to
merge all chromatographic peaks with a similar <em>m/z</em> that are
less than 8 seconds apart from each other on the retention time axis
(parameter <code>expandRt = 4</code>; the distance tail to head of the
peaks evaluated for merging should thus be less than
<code>2 * expandRt</code>) and for which the signal (intensity) between
the two peaks is higher than 75% of the smaller apex intensity of the
two peaks (parameter <code>minProp = 0.75</code>). We below apply these
settings on the EICs and evaluate the result of this
post-processing.</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define the setting for the peak refinement</span></span>
<span><span class="va">mpp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">MergeNeighboringPeaksParam</a></span><span class="op">(</span>expandRt <span class="op">=</span> <span class="fl">4</span>, minProp <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Perform the peak refinement on the EICs</span></span>
<span><span class="va">eics</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks</a></span><span class="op">(</span><span class="va">eics</span>, param <span class="op">=</span> <span class="va">mpp</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">eics</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-39-1.png" width="960"></p>
<p>The peak post-processing was able to fuse the signal for the
neighboring peaks in the lower panel, while keeping the peaks for the
different isomers present in the top right plot separate. We next apply
this same peak refinement on the full data set.</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform peak refinement on the full data set</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, param <span class="op">=</span> <span class="va">mpp</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="alignment">Alignment<a class="anchor" aria-label="anchor" href="#alignment"></a>
</h3>
<p>While chromatography helps to better discriminate between analytes it
is also affected by variances that lead to shifts in retention times
between measurement runs. Such differences can usually already be seen
in a base peak chromatogram or total ion chromatogram. We thus extract
and plot below the BPC for our data set. In the
<code>chromatogram</code> call, we set the optional parameter
<code>chromPeaks = "none"</code> to avoid the additional extraction of
all identified chromatographic peaks.</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract base peak chromatograms</span></span>
<span><span class="va">bpc_raw</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span>, chromPeaks <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc_raw</span>, peakType <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/alignment-bpc-raw-1.png" alt="BPC of all files." width="960"><p class="caption">
BPC of all files.
</p>
</div>
<p>While both samples were measured with the same setup in the same
measurement run, slight drifts of the signal are visible. These were
also already visible in the EIC for serine, that we plot again
below.</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">190</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-41-1.png" width="960"></p>
<p>For the serine signal, there seems to be a retention time shift of
about 1 second between the two samples. The alignment step aims to
minimize these retention time differences between all samples within an
experiment (see below for an illustration).</p>
<div class="float">
<img src="images/alignment.png" alt="Alignment"><div class="figcaption">Alignment</div>
</div>
<p>In <em>xcms</em>, the alignment can be performed with the
<code>adjustRtime</code> function and one of the available alignment
algorithms, that can be selected, and configured, with the respective
parameter objects:</p>
<ul>
<li><p><code>PeakGroupsParam</code>: the <em>peakGroups</em> <span class="citation">(C. A. Smith et al. 2006)</span> method aligns samples
based on the retention times of a set of so called <em>hook peaks</em>
(or housekeeping peaks) in the different samples of an experiment. These
peaks are supposed to represent signal from ions expected to be present
in most of the samples of an experiment and the method aligns these
samples by minimizing the between-sample retention time differences
observed for these peaks.</p></li>
<li><p><code>ObiwarpParam</code>: <em>obiwarp</em> <span class="citation">(Prince and Marcotte 2006)</span> performs retention
time adjustment based on the full <em>m/z</em> - retention time data.
See the documentation for <code>ObiwarpParam</code> or the <em>xcms</em>
<a href="https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html" class="external-link">vignette</a>
for more information.</p></li>
</ul>
<p>While, by default, retention time shifts are estimated on the full
data set, it would also be possible to estimate them on a subset of
samples, such as repeatedly measured QC samples (e.g. sample pools) and
adjust the full experiment based on these. See the alignment section in
the <em>xcms</em> <a href="https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html" class="external-link">vignette</a>
for more information on this subset-based alignment. Note that such a
subset-based alignment requires the samples to be loaded in the order in
which they were measured.</p>
<p>For our example we use the <em>peakGroups</em> method that, as
mentioned above, aligns samples based on the retention times of <em>hook
peaks</em> (or housekeeping peaks). To define these, we need to first
run an initial correspondence analysis to group chromatographic peaks
across samples. Below we use the <em>peakDensity</em> method for
correspondence. Details about this method and explanations on the
choices of its parameters are provided in the next section. In brief,
parameter <code>sampleGroups</code> defines to which sample group of the
experiment individual samples belong to, and parameter
<code>minFraction</code> specifies the proportion of samples (of one
sample group) in which a chromatographic peak needs to be identified
(for a particular <em>m/z</em> - retention time region) to group them
into an LC-MS feature. For our example we use the sample group
definition in the <code>sampleData</code> of our <code>data</code>
variable and set <code>minFraction = 1</code> requiring thus a
chromatographic peak to be identified in 100% of available samples to
define a feature. Generally, if correspondence is performed on more
heterogeneous samples <code>minFraction</code> values between 0.6 and
0.8 could be used instead. Since the aim of this initial correspondence
is to define some (presumably well separated) groups of chromatographic
peaks across the samples, its settings does not need to be fully
optimized.</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define the settings for the initial peak grouping - details for</span></span>
<span><span class="co">#' choices in the next section.</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span>,</span>
<span>                        minFraction <span class="op">=</span> <span class="fl">1</span>, binSize <span class="op">=</span> <span class="fl">0.02</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">groupChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<p>This step now grouped chromatographic peaks across samples and
defined so called LC-MS features (or simply features). We can thus now
run the alignment using the <em>peakGroups</em> algorithm. The main
parameter to define the hook peaks is (again) <code>minFraction</code>.
Similar to the definition above, <code>minFraction</code> refers to the
proportion of samples in which a chromatographic peak needs to be
present. By setting <code>minFraction = 1</code> we base the alignment
on features with peaks identified in 100% of the samples in the data
set. For alignments that are based on repeatedly measured samples
(e.g. also for subset-based alignment on sample pools) values
<code>&gt;= 0.9</code> can be used. Otherwise, values between 0.7 and
0.9 might be more advisable to ensure that a reasonable set of features
are selected.</p>
<p>After having identified the features that should be used as <em>hook
peaks</em> the algorithm minimizes the observed between-sample retention
time differences for these. Parameter <code>span</code> defines the
degree of smoothing of the loess function that is used to allow
different regions along the retention time axis to be adjusted by a
different factor. A value of 0 will most likely cause overfitting, while
1 would cause all retention times of a sample to be shifted by a
constant value. Values between 0.4 and 0.6 seem to be reasonable for
most experiments.</p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define settings for the alignment</span></span>
<span><span class="va">pgp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">PeakGroupsParam</a></span><span class="op">(</span>minFraction <span class="op">=</span> <span class="fl">1</span>, span <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtime</a></span><span class="op">(</span><span class="va">data</span>, param <span class="op">=</span> <span class="va">pgp</span><span class="op">)</span></span></code></pre></div>
<p>After an alignment it is suggested to evaluate its results using the
<code>plotAdjustedRtime</code> function. This function plots the
differences between adjusted and raw retention times for each sample on
the y-axis along the adjusted retention times on the x-axis (each line
hence representing the retention time adjustment of one sample/file).
Points indicate the position of individual hook peaks along the
retention time axis, with a dotted line connecting the peaks belonging
to the same feature (for which the algorithm minimized the difference in
retention times).</p>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the difference between raw and adjusted retention times</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotAdjustedRtime.html" class="external-link">plotAdjustedRtime</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/alignment-result-1.png" alt="Alignment results: differences between raw and adjusted retention times for each sample." width="960"><p class="caption">
Alignment results: differences between raw and adjusted retention times
for each sample.
</p>
</div>
<p>As a rule of thumb, the differences between raw and adjusted
retention times in the plot above should be reasonable. Also, if
possible, hook peaks should be present along a wide span of the
retention time range, to avoid the need for extrapolation (which usually
results in a too strong adjustment). For our example, the largest
adjustments are between 1 and 2 seconds, which is reasonable given that
the two samples were measured during the same measurement run. Also,
features used for the alignment (i.e. hook peaks) are spread across the
full retention time range.</p>
<p>To evaluate the impact of the alignment we next also plot the BPC
before and after alignment. In a similar way as before, we set
<code>chromPeaks = "none"</code> in the <code>chromatogram</code> call
to tell the function to <strong>not</strong> include any identified
chromatographic peaks in the returned chromatographic data.</p>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the raw base peak chromatogram</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc_raw</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the BPC after alignment</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span>, chromPeaks <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/bpc-raw-adjusted-1.png" alt="BPC before (top) and after (bottom) alignment." width="960"><p class="caption">
BPC before (top) and after (bottom) alignment.
</p>
</div>
<p>The base peak chromatograms are nicely aligned after retention time
adjustment. In addition to this general assessment, the alignment result
should also be evaluated for selected compounds (or internal standards).
We thus below plot the EIC for the <em>[M+H]+</em> ion for serine before
and after alignment.</p>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4.5</span>, <span class="fl">1</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' EIC before alignment</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#' EIC after alignment</span></span>
<span><span class="va">serine_chr_adj</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">164</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>                               mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span><span class="op">)</span>,</span>
<span>                               aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr_adj</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/serine-xic-adjusted-1.png" alt="EIC for Serine before (left) and after (right) alignment" width="960"><p class="caption">
EIC for Serine before (left) and after (right) alignment
</p>
</div>
<p>The serine peaks are also nicely aligned after retention time
adjustment. Again, it is advisable to evaluate the impact of the
alignment on several EICs, ideally also spread along the retention time
range.</p>
<p>Note that <code>adjustRtime</code>, in addition to the retention
times of the individual (MS1) spectra of all files, adjusted also the
retention times of the identified chromatographic peaks, as well as
retention times of possibly present MS2 spectra. The adjusted retention
times are stored as a new spectra variable <code>"rtime_adjusted"</code>
in the result object’s <code>Spectra</code>. The <code>rtime</code>
function on the result object will by default return these (adjusted)
values.</p>
</div>
<div class="section level3">
<h3 id="correspondence">Correspondence<a class="anchor" aria-label="anchor" href="#correspondence"></a>
</h3>
<p>The final step of the LC-MS preprocessing with <em>xcms</em> is the
correspondence analysis, in which chromatographic peaks from the same
types of ions (compounds) are grouped across samples to form the so
called <em>LC-MS features</em>.</p>
<div class="float">
<img src="images/correspondence2_03.png" alt="Correspondence"><div class="figcaption">Correspondence</div>
</div>
<p>In <em>xcms</em>, correspondence is performed using the
<code>groupChromPeaks</code> function. The correspondence algorithm can
be selected and configured with the respective parameter objects:</p>
<ul>
<li><p><code>NearestPeaksParam</code>: performs peak grouping based on
the proximity of chromatographic peaks from different samples in the
<em>m/z</em> - retention time space, similar to the original
correspondence method of <em>mzMine</em> <span class="citation">(Katajamaa, Miettinen, and Oresic
2006)</span>.</p></li>
<li><p><code>PeakDensityParam</code>: performs a simple and fast
correspondence analysis based on the density of chromatographic peaks
(from different samples) along the retention time axis within slices of
small <em>m/z</em> ranges <span class="citation">(C. A. Smith et al.
2006)</span>.</p></li>
</ul>
<p>Both methods group chromatographic peaks from different samples with
similar <em>m/z</em> and retention times into features. For our example
we use the <em>peak density</em> method. This algorithm iterates through
small slices along the <em>m/z</em> dimension and groups within each
slice chromatographic peaks with similar retention times. The grouping
depends on the distribution (density) of chromatographic peaks from all
samples along the retention time axis. Peaks with similar retention time
will result in a higher peak density at a certain retention time and are
thus grouped together. The grouping depends on the <em>smoothness</em>
of the density curve and can be configured with parameter
<code>bw</code>.</p>
<p>An illustration showing how chromatographic peaks within a small
<em>m/z</em> range are grouped by the <em>peakDensity</em> method is
shown in the sketch below.</p>
<div class="float">
<img src="images/correspondence2_density.png" alt="peak density"><div class="figcaption">peak density</div>
</div>
<p>Settings for this algorithm can be best tested and optimized using
the <code>plotChromPeakDensity</code> function on extracted
chromatograms. We below extract a chromatogram for a <em>m/z</em> slice
containing signal for a <em>[M+H]+</em> ion of serine and evaluate the
result from a <em>peakDensity</em> correspondence analysis using that
function. We use the default settings (<code>bw = 30</code>) and use
again the sample group assignment defined in
<code>sampleData</code>.</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract a chromatogram for a m/z range containing serine</span></span>
<span><span class="va">chr_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Default parameters for peak density; bw = 30</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Test these settings on the extracted slice</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_1</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-43-1.png" width="960"></p>
<p>The upper panel in the plot shows the chromatographic data for the
selected <em>m/z</em> slice with the identified peaks highlighted in
grey. The lower panel plots the retention time of identified
chromatographic peaks on the x-axis against the index of the sample in
which the peak was identified. Each chromatographic peak is thus
represented with a point in that plot (x-axis value being its retention
time and the y-axis value the sample in which it was identified). In our
example there was one chromatographic peak identified in each sample at
a retention time of about 180 seconds and these two peaks are thus
shown. The black solid line represents the density estimation
(i.e. distribution or retention times) of the identified chromatographic
peaks along the retention time axis. The smoothness of this curve (which
is created with the base R <code>density</code> function) is configured
with the parameter <code>bw</code>. The <em>peakDensity</em> algorithm
assigns all chromatographic peaks within the same <em>peak</em> of this
density estimation curve to the same feature. Chromatographic peaks
assigned to the same feature are indicated with a grey rectangle in the
plot. In the present example, because retention times of the two
chromatographic peaks are very similar, this rectangle is very narrow
and looks thus more like a vertical line. Based on this result, the
default settings (<code>bw = 30</code>) seemed to correctly define
features. It is however advisable to evaluate settings on multiple
slices, ideally with signal from more than one compound being present.
Such slices could be identified in e.g. a plot created with the
<code>plotChromPeaks</code> function (see example in the chromatographic
peak detection section).</p>
<p>In our example we extract a chromatogram for an <em>m/z</em> slice
containing signal for known isomers betaine and valine ([M+H]+
<em>m/z</em> 118.08625).</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the chromatogram for an m/z slice containing betaine and valine</span></span>
<span><span class="va">mzr</span> <span class="op">&lt;-</span> <span class="fl">118.08625</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.01</span>, <span class="fl">0.01</span><span class="op">)</span></span>
<span><span class="va">chr_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">mzr</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Correspondence in that slice using default settings</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-bw-1.png" alt="Correspondence analysis with default settings on an *m/z* slice containing signal from multiple ions." width="960"><p class="caption">
Correspondence analysis with default settings on an <em>m/z</em> slice
containing signal from multiple ions.
</p>
</div>
<p>This slice contains signal from several ions resulting in multiple
chromatographic peaks along the retention time axis. With the default
settings, in particular with <code>bw = 30</code>, all these peaks were
however assigned to the same feature (indicated with the grey
rectangle). Signal from different ions would thus be treated as a single
entity. We repeat the analysis below with a strongly reduced value for
parameter <code>bw</code>.</p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Reducing the bandwidth</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-bw-fix-1.png" alt="Correspondence analysis with reduced bw setting on a *m/z* slice containing signal from multiple ions." width="960"><p class="caption">
Correspondence analysis with reduced bw setting on a <em>m/z</em> slice
containing signal from multiple ions.
</p>
</div>
<p>Setting <code>bw = 1.8</code> strongly reduced the smoothness of the
density curve resulting in a higher number of density <em>peaks</em> and
hence a nice grouping of (aligned) chromatographic peaks into separate
features. Note that the height of the peaks of the density curve are not
considered for the grouping.</p>
<p>By having defined a <code>bw</code> appropriate for our data set, we
proceed and perform the correspondence analysis on the full data set.
Other parameters of <em>peakDensity</em> are <code>binSize</code> and
<code>minFraction</code>. The former defines the <em>m/z</em> widths of
the slices along the <em>m/z</em> dimension the algorithm will iterate
through. This value depends on the resolution (and noise) of the
instrument, and should not be set to a too small value, but also not too
large (to avoid peaks from different ions, with slightly different
<em>m/z</em> but similar retention times, to be grouped into the same
feature). The <code>minFraction</code> parameter (already discussed
above) defines the proportion of samples within at least one sample
group in which chromatographic peaks need to be identified in order to
define a feature. For our example we use a <code>binSize = 0.02</code>
hence grouping chromatographic peaks, with similar retention time, and
with a difference in their <em>m/z</em> that is smaller than 0.02 into
the same feature and <code>minFraction = 0.4</code> thus defining
features for chromatographic peak that were identified in at least 50%
of samples per sample group.</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Set optimized settings</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span>,</span>
<span>                        minFraction <span class="op">=</span> <span class="fl">0.4</span>, binSize <span class="op">=</span> <span class="fl">0.02</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Perform the correspondence analysis on the full data</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">groupChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span>
<span><span class="va">data</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class XcmsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span>
<span><span class="co">##  xcms results:</span></span>
<span><span class="co">##   - chromatographic peaks: 595 in MS level(s): 1 </span></span>
<span><span class="co">##   - adjusted retention times: mean absolute difference 0.301 seconds</span></span>
<span><span class="co">##   - correspondence results: 361 features in MS level(s): 1</span></span></code></pre>
<p>Over 300 features were identified in our example data set. Again, it
is suggested to evaluate the results on selected compounds/ions. We
therefore extract below the chromatogram for the <em>m/z</em> range
containing signals for betaine and valine. After a correspondence
analysis also features are extracted by the <code>chromatogram</code>
call and we can show the results from the actual correspondence analysis
(based also on the settings that were used) by setting
<code>simulate = FALSE</code> in the <code>plotChromPeakDensity</code>
call.</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chromatogram including signal for betaine and valine</span></span>
<span><span class="va">chr_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="fl">118.08625</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.01</span>, <span class="fl">0.01</span><span class="op">)</span>,</span>
<span>                      aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="co">#' Setting simulate = FALSE to show the actual correspondence results</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, simulate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-evaluate-1.png" alt="Result of correspondence on a slice containing the isomers valine and betaine." width="960"><p class="caption">
Result of correspondence on a slice containing the isomers valine and
betaine.
</p>
</div>
<p>We evaluate the results also on a different slice containing signal
for ions from isomers leucine and isoleucine ([M+H]+ <em>m/z</em>
132.10191).</p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chromatogram with signal for isomers leucine and isoleucine</span></span>
<span><span class="va">chr_3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="fl">132.10191</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.01</span>, <span class="fl">0.01</span><span class="op">)</span>,</span>
<span>                      aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_3</span>, simulate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-evaluate-2-1.png" alt="Result of correspondence on a slice containing the isomers leucine and isoleucine." width="960"><p class="caption">
Result of correspondence on a slice containing the isomers leucine and
isoleucine.
</p>
</div>
<p>Despite being very close, chromatographic peaks of the two isomers
were successfully grouped into separate features. Even the partially
overlapping signal from a third ion eluting at about the same time and
hence partially overlapping with the peak at a retention time of 152
seconds was grouped into its own, separate, feature. It is at the
discretion of the data analysts to define how fine or coarse the feature
grouping should be. Especially for larger experiments, with more samples
and also larger variation in retention time it might not always be
possible to completely separate all closely eluting ions from each other
and sometimes it might be acceptable to group them into a single feature
(keeping in mind that this feature would then however represent signal
from different ions/compounds).</p>
<p>Similar to the peak detection and alignment results, also the results
from the correspondence analysis were added to the
<code>XcmsExperiment</code> object. These can be extracted with the
<code>featureDefinitions</code> function, that extracts the
<em>definition</em> of the LC-MS features and the
<code>featureValues</code> function that extracts the numerical matrix
with the feature abundances (in all samples). Below we extract the
definition of the features and display the first 6 rows</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Definition of the features</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL</span></span>
<span><span class="co">## FT001 105.0418 105.0417 105.0418 167.68597 167.48455 167.88740      2    2</span></span>
<span><span class="co">## FT002 105.0415 105.0415 105.0415 157.71871 157.71871 157.71871      1    1</span></span>
<span><span class="co">## FT003 105.0697 105.0691 105.0703  31.80794  31.68918  31.92670      2    2</span></span>
<span><span class="co">## FT004 105.1103 105.1100 105.1105  63.75047  63.35239  64.14855      2    2</span></span>
<span><span class="co">## FT005 105.4734 105.4732 105.4736 201.57593 201.36133 201.79053      2    2</span></span>
<span><span class="co">## FT006 105.7166 105.7160 105.7172 181.21578 181.08901 181.34256      2    2</span></span>
<span><span class="co">##        peakidx ms_level</span></span>
<span><span class="co">## FT001 112, 396        1</span></span>
<span><span class="co">## FT002      111        1</span></span>
<span><span class="co">## FT003  19, 317        1</span></span>
<span><span class="co">## FT004  48, 348        1</span></span>
<span><span class="co">## FT005 260, 580        1</span></span>
<span><span class="co">## FT006 135, 444        1</span></span></code></pre>
<p>Each row defines one feature and provides information on it’s
<em>m/z</em> (column <code>"mzmed"</code>) and retention time (column
<code>"rtmed"</code>). Additional columns list the number of
chromatographic peaks that were assigned to the feature and the MS
level. Column <code>"peakidx"</code> provides the indices of the
chromatographic peaks in the <code>chromPeaks</code> matrix that were
assigned to the feature - but generally users will not need or extract
that information.</p>
<p>The feature abundance matrix, which is the final result of the
<em>xcms</em> preprocessing, can be extracted with the
<code>featureValues</code> function. By default, with parameter
<code>method = "maxint"</code>, it returns for each feature the
integrated peak signal of the chromatographic peak with the highest
signal per sample. Note that this has only an effect for features with
more than one chromatographic peak per sample (i.e., if multiple
chromatographic peaks in the <strong>same</strong> sample were grouped
into the feature because of their closeness in retention time). Setting
<code>method = "sum"</code> would in contrast sum the abundances of such
chromatographic peaks. Note that <code>method = "sum"</code> is only
suggested if, like in our example, neighboring and overlapping peaks per
sample were merged to avoid an overestimation of the feature abundance.
Below we extract the feature abundances and show the first 6 rows.</p>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get abundances for the first 6 features</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span>, method <span class="op">=</span> <span class="st">"sum"</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## FT001                        3202.7445                        2285.2830</span></span>
<span><span class="co">## FT002                        3605.3915                               NA</span></span>
<span><span class="co">## FT003                         744.8752                        1057.4312</span></span>
<span><span class="co">## FT004                       18126.4603                       19369.4039</span></span>
<span><span class="co">## FT005                       23243.6129                       31960.3709</span></span>
<span><span class="co">## FT006                         671.5842                         617.7545</span></span></code></pre>
<p>We could now use this feature matrix for any downstream analysis.
Such feature matrix might however, as can also be seen in the second row
above (feature <em>FT002</em>), contain missing values. These represent
features for which no chromatographic peak was identified in one (or
more) sample(s). While a number of imputation methods exist to deal with
missing values, it might be more advisable to instead <em>rescue</em>
signal. <em>xcms</em> provides such <em>gap filling</em> which is
explained in the next section.</p>
</div>
<div class="section level3">
<h3 id="gap-filling">Gap filling<a class="anchor" aria-label="anchor" href="#gap-filling"></a>
</h3>
<p>Missing values in feature matrices from an <em>xcms</em>-based
preprocessing represent cases in which, in a particular sample, no
chromatographic peak was identified in the <em>m/z</em> - retention time
region of the feature. This could either represent a truly missing value
(because the ion/compound was not present in that sample) or a failure
of the peak detection algorithm to identify a peak (either because the
measured signal was too noisy, or too low, or a combination of
both).</p>
<p>To illustrate this we below define <em>m/z</em> - retention time
regions containing signal of features with missing values, extract their
EICs and plot them (using a different color for each sample). Note:
these regions were identified by first visually inspecting EICs for all
features with at least one missing value.</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define m/z - rt regions for selected examples with missing peaks</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">109.661</span>, <span class="fl">109.664</span>, <span class="fl">192</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">109.993</span>, <span class="fl">109.998</span>, <span class="fl">200</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125.586</span>, <span class="fl">125.591</span>, <span class="fl">195</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">130.959</span>, <span class="fl">130.961</span>, <span class="fl">197</span>, <span class="fl">201</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract their EICs and plot them</span></span>
<span><span class="va">chrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/features-missing-values-1.png" alt="Examples of features for which a peak was only identified in one sample." width="960"><p class="caption">
Examples of features for which a peak was only identified in one sample.
</p>
</div>
<p>Indeed, for all these feature, chromatographic peak detection failed
to identify a peak in one of the two samples. For the features in the
upper panel, the signal was most likely too low, while for the bottom
left feature the signal was likely too noisy, and for the bottom right
too sparse (i.e. to few data points to properly detect a peak). In all
cases, however, signal from (presumably) the same ion was measured in
both samples. Thus, reporting a missing value would not be correct for
these.</p>
<p>The aim of the <em>gap filling</em> is now to rescue signal for such
features by integrating the intensities measured within the feature’s
<em>m/z</em> - retention time area in the sample(s) in which no
chromatographic peak was detected. In <em>xcms</em> this can be done
with the <code>fillChromPeaks</code> function and the
<code>ChromPeakAreaParam</code> which allows to configure this
algorithm. Below we perform the gap filling showing also the number of
missing values before and after running <code>fillChromPeaks</code>.</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Number of missing values</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 135</span></span></code></pre>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform gap filling</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">fillChromPeaks</a></span><span class="op">(</span><span class="va">data</span>, param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">ChromPeakAreaParam</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Number of missing values after gap filling</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 28</span></span></code></pre>
<p>With <code>fillChromPeaks</code> we could thus <em>rescue</em> signal
for all but 26 features. Also for the 4 example features from above a
signal was filled-in. Below we visualize the gap-filled chromatographic
peaks for these.</p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract their EICs and plot them</span></span>
<span><span class="va">chrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/features-missing-values-filled-1.png" alt="Features with filled-in signal." width="960"><p class="caption">
Features with filled-in signal.
</p>
</div>
<p>In contrast, we identify and plot the EICs for features for which no
signal could be filled-in (i.e. which still have missing values in one
of the two samples).</p>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Identify features with missing values</span></span>
<span><span class="va">fts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' Extract the m/z - rt regions for these features</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XcmsExperiment.html" class="external-link">featureArea</a></span><span class="op">(</span><span class="va">data</span>, features <span class="op">=</span> <span class="va">fts</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Expand the retention time by 1 second on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">1</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span></span>
<span></span>
<span><span class="va">chrs_na</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                        rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"rtmin"</span>, <span class="st">"rtmax"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs_na</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/gap-filling-missing-1.png" alt="Features with missing values even after gap-filling." width="1152"><p class="caption">
Features with missing values even after gap-filling.
</p>
</div>
<p>For these features indeed no signal was measured in the second
sample.</p>
<p>An alternative way to confirm if gap-filling was able to correctly
rescue signals is to plot, for features with at least one missing value,
the average detected against the average filled-in signal. Ideally, this
should be done on QC samples or other repeatedly measured samples were
no difference in feature abundances between samples is expected.</p>
<p>The code below extracts first only the detected feature values (by
setting <code>filled = FALSE</code> in the <code>featureValues</code>
call), then the detected <strong>and</strong> filled-in signal. For the
latter, the detected signal is subsequently replaced with
<code>NA</code> to create a data matrix with only filled-in values.
Finally, after calculating the row averages for both matrices (excluding
missing values), these values are plotted against each other.</p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get only detected signal</span></span>
<span><span class="va">vals_detect</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span>, filled <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Get detected and filled-in signal</span></span>
<span><span class="va">vals_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Replace detected signal with NA</span></span>
<span><span class="va">vals_filled</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">vals_detect</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span>
<span></span>
<span><span class="co">#' Identify features with at least one filled peak</span></span>
<span><span class="va">has_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">vals_detect</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Calculate row averages</span></span>
<span><span class="va">avg_detect</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="va">vals_detect</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">avg_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="va">vals_filled</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Restrict to features with at least one filled peak</span></span>
<span><span class="va">avg_detect</span> <span class="op">&lt;-</span> <span class="va">avg_detect</span><span class="op">[</span><span class="va">has_filled</span><span class="op">]</span></span>
<span><span class="va">avg_filled</span> <span class="op">&lt;-</span> <span class="va">avg_filled</span><span class="op">[</span><span class="va">has_filled</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' plot the values against each other (in log2 scale)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_detect</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_filled</span><span class="op">)</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">avg_detect</span>, <span class="va">avg_filled</span><span class="op">)</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>     ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">avg_detect</span>, <span class="va">avg_filled</span><span class="op">)</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>     pch <span class="op">=</span> <span class="fl">21</span>, bg <span class="op">=</span> <span class="st">"#00000080"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/comparison-detected-filled-1.png" alt="Detected (x-axis) against filled (y-axis) signal. The black solid line represents the identity line." width="960"><p class="caption">
Detected (x-axis) against filled (y-axis) signal. The black solid line
represents the identity line.
</p>
</div>
<p>As expected, detected signal is generally higher than filled-in
signal. For the biggest part (in particular for higher intensities),
filled-in and detected feature values are similar suggesting that the
gap filling step indeed rescued signal.</p>
<p>We could also calculate statistics on these values. Below we fit a
linear regression line to the data and summarize its result.</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' fit a linear regression line to the data</span></span>
<span><span class="va">l</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_filled</span><span class="op">)</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_detect</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">l</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = log2(avg_filled) ~ log2(avg_detect))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residuals:</span></span>
<span><span class="co">##     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">## -3.5165 -0.4060  0.1467  0.7274  2.2150 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##                  Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept)      -1.51927    0.47004  -3.232  0.00164 ** </span></span>
<span><span class="co">## log2(avg_detect)  1.03552    0.04575  22.636  &lt; 2e-16 ***</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residual standard error: 1.093 on 105 degrees of freedom</span></span>
<span><span class="co">##   (28 observations deleted due to missingness)</span></span>
<span><span class="co">## Multiple R-squared:  0.8299, Adjusted R-squared:  0.8283 </span></span>
<span><span class="co">## F-statistic: 512.4 on 1 and 105 DF,  p-value: &lt; 2.2e-16</span></span></code></pre>
<p>With a value of 1.005, the slope of the line is thus very close to
the slope of the identity line and the two sets of values are also
highly correlated (R squared of 0.81).</p>
</div>
<div class="section level3">
<h3 id="preprocessing-result">Preprocessing result<a class="anchor" aria-label="anchor" href="#preprocessing-result"></a>
</h3>
<p>The <em>xcms</em> preprocessing results are all stored within an
<code>XcmsExperiment</code> object. This includes the identified
chromatographic peaks, the alignment results as well as the
correspondence results. In addition, to guarantee reproducibility, this
result object keeps track of all performed processing steps and contains
also the individual parameter objects used in the various preprocessing
steps. These can be extracted with the <code>processHistory</code>
function:</p>
<div class="sourceCode" id="cb119"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Process history</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">processHistory</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak detection </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:21 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: CentWaveParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak refinement </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:24 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: MergeNeighboringPeaksParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[3]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak grouping </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:26 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakDensityParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[4]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Retention time correction </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:26 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakGroupsParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[5]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak grouping </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:31 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakDensityParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[6]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Missing peak filling </span></span>
<span><span class="co">##  date: Fri Sep 29 13:09:36 2023 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: ChromPeakAreaParam </span></span>
<span><span class="co">##  MS level(s) 1</span></span></code></pre>
<p>An individual parameter object can be extracted as follows:</p>
<div class="sourceCode" id="cb121"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Peak detection parameters</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">processHistory</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">param</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class:  CentWaveParam </span></span>
<span><span class="co">##  Parameters:</span></span>
<span><span class="co">##  - ppm: [1] 30</span></span>
<span><span class="co">##  - peakwidth: [1]  2 10</span></span>
<span><span class="co">##  - snthresh: [1] 10</span></span>
<span><span class="co">##  - prefilter: [1]   3 100</span></span>
<span><span class="co">##  - mzCenterFun: [1] "wMean"</span></span>
<span><span class="co">##  - integrate: [1] 2</span></span>
<span><span class="co">##  - mzdiff: [1] -0.001</span></span>
<span><span class="co">##  - fitgauss: [1] FALSE</span></span>
<span><span class="co">##  - noise: [1] 0</span></span>
<span><span class="co">##  - verboseColumns: [1] FALSE</span></span>
<span><span class="co">##  - roiList: list()</span></span>
<span><span class="co">##  - firstBaselineCheck: [1] TRUE</span></span>
<span><span class="co">##  - roiScales: numeric(0)</span></span>
<span><span class="co">##  - extendLengthMSW: [1] FALSE</span></span></code></pre>
<p>Thus, the used preprocessing algorithms along with all their settings
are reported along the preprocessing results.</p>
<p>As described above, values for the individual features can be
extracted from the result object with the <code>featureValues</code>
function and the definition of the features (which could be used for an
initial annotation of the features based on their <em>m/z</em> and/or
retention times) using the <code>featureDefinitions</code> function. In
addition, the <code>XcmsExperiment</code> result object, through the
internal <code>Spectra</code> object, keeps a <em>link</em> to the full
MS data used for the analysis. For downstream analyses, that don’t need
access to this MS data anymore the preprocessing results could be
represented equally well using a <code>SummarizedExperiment</code>
object, which is Bioconductor’s standard container for large-scale omics
data. <em>xcms</em> provides with the <code>quantify</code> function a
convenience function to extract all results from an
<code>XcmsExperiment</code> result object and return it as a
<code>SummarizedExperiment</code>. This function takes the same
parameters than the <code>featureValues</code>, which is internally used
to extract the feature value matrix.</p>
<div class="sourceCode" id="cb123"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract results as a SummarizedExperiment</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bioconductor.org/packages/SummarizedExperiment" class="external-link">SummarizedExperiment</a></span><span class="op">)</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">quantify</a></span><span class="op">(</span><span class="va">data</span>, method <span class="op">=</span> <span class="st">"sum"</span><span class="op">)</span></span></code></pre></div>
<p>The sample annotations can now be accessed with the
<code>colData</code> function and the feature definitions
(i.e. annotation for individual rows/features) with the
<code>rowData</code> function:</p>
<div class="sourceCode" id="cb124"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get sample annotations</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">colData</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 2 rows and 5 columns</span></span>
<span><span class="co">##                                           file      sample injection_index</span></span>
<span><span class="co">##                                    &lt;character&gt; &lt;character&gt;       &lt;numeric&gt;</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML 20171016_P...      POOL_1               1</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19</span></span>
<span><span class="co">##                                        group spectraOrigin</span></span>
<span><span class="co">##                                  &lt;character&gt;   &lt;character&gt;</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT...</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT...</span></span></code></pre>
<div class="sourceCode" id="cb126"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get feature annotations</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">rowData</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 361 rows and 9 columns</span></span>
<span><span class="co">##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks</span></span>
<span><span class="co">##       &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;</span></span>
<span><span class="co">## FT001   105.042   105.042   105.042  167.6860  167.4845  167.8874         2</span></span>
<span><span class="co">## FT002   105.042   105.042   105.042  157.7187  157.7187  157.7187         1</span></span>
<span><span class="co">## FT003   105.070   105.069   105.070   31.8079   31.6892   31.9267         2</span></span>
<span><span class="co">## FT004   105.110   105.110   105.111   63.7505   63.3524   64.1486         2</span></span>
<span><span class="co">## FT005   105.473   105.473   105.474  201.5759  201.3613  201.7905         2</span></span>
<span><span class="co">## ...         ...       ...       ...       ...       ...       ...       ...</span></span>
<span><span class="co">## FT357   133.928   133.928   133.928  198.5823  198.5823  198.5823         1</span></span>
<span><span class="co">## FT358   133.960   133.960   133.961   30.8309   30.8063   30.8554         2</span></span>
<span><span class="co">## FT359   133.956   133.956   133.956  199.0661  198.9950  199.1372         2</span></span>
<span><span class="co">## FT360   133.973   133.973   133.973  206.8712  206.3899  207.3524         2</span></span>
<span><span class="co">## FT361   133.973   133.973   133.973  200.2484  200.2484  200.2484         1</span></span>
<span><span class="co">##            POOL  ms_level</span></span>
<span><span class="co">##       &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## FT001         2         1</span></span>
<span><span class="co">## FT002         1         1</span></span>
<span><span class="co">## FT003         2         1</span></span>
<span><span class="co">## FT004         2         1</span></span>
<span><span class="co">## FT005         2         1</span></span>
<span><span class="co">## ...         ...       ...</span></span>
<span><span class="co">## FT357         1         1</span></span>
<span><span class="co">## FT358         2         1</span></span>
<span><span class="co">## FT359         2         1</span></span>
<span><span class="co">## FT360         2         1</span></span>
<span><span class="co">## FT361         1         1</span></span></code></pre>
<p>The feature values are stored as an <em>assay</em> within the object.
To access that we simply use the <code>assay</code> function.</p>
<div class="sourceCode" id="cb128"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get feature values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">assay</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## FT001                        3202.7445                        2285.2830</span></span>
<span><span class="co">## FT002                        3605.3915                        3183.9546</span></span>
<span><span class="co">## FT003                         744.8752                        1057.4312</span></span>
<span><span class="co">## FT004                       18126.4603                       19369.4039</span></span>
<span><span class="co">## FT005                       23243.6129                       31960.3709</span></span>
<span><span class="co">## FT006                         671.5842                         617.7545</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="what-next">What next?<a class="anchor" aria-label="anchor" href="#what-next"></a>
</h3>
<p>After preprocessing, the data could be normalized or scaled to remove
any technical variances from the data. While a simple e.g. median
scaling could be done with a few lines of R code also more advanced (but
not always needed) normalization algorithms are available in
e.g. Bioconductor’s <em><a href="https://bioconductor.org/packages/3.18/preprocessCore" class="external-link">preprocessCore</a></em>
package.</p>
<p>Differential abundance analysis could be performed using the
<code>r Biocpkg("limma")</code> package or with any of the other
packages or methods available in R.</p>
<p>As mentioned above, many chromatographic peaks (and subsequently also
features) in untargeted metabolomics data sets will represent isotopes
or also different ions/adducts of the same compound. The <em><a href="https://bioconductor.org/packages/3.18/CAMERA" class="external-link">CAMERA</a></em>
package aimed to identify and group such features in a data set. A
similar feature grouping (compounding) can also be done for
preprocessing results from newer versions of <em>xcms</em> using the
<em><a href="https://bioconductor.org/packages/3.18/MsFeatures" class="external-link">MsFeatures</a></em>
package. This package enables grouping of features through a variety of
different methods. See also the <a href="https://sneumann.github.io/xcms/articles/LC-MS-feature-grouping.html" class="external-link">feature
grouping vignette</a> in <em>xcms</em> for more details.</p>
<p>Finally, the <em><a href="https://bioconductor.org/packages/3.18/MetaboAnnotation" class="external-link">MetaboAnnotation</a></em>
provides functions to assist in the annotation of features from LC-MS as
well as LC-MS/MS experiments. These allow to either perform an initial
annotation based on <em>m/z</em> values or through a combination of
<em>m/z</em> and retention time values. In addition, also annotations
based on fragment spectra (if available) are supported (with or without
considering in addition the features’ retention times. More information
is provided in the <a href="https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html" class="external-link">MetaboAnnotation
vignette</a> or <a href="https://jorainer.github.io/MetaboAnnotationTutorials/articles/annotation-use-cases.html" class="external-link">MetaboAnnotation
tutorial</a>.</p>
<p>For more information on general MS data analysis in R or spectra
similarity calculations can be found in the <a href="https://rformassspectrometry.github.io/book/" class="external-link">RforMassSpectrometry
book</a> or in the various workshops/tutorials at <a href="https://jorainer.github.io/SpectraTutorials" class="external-link">SpectraTutorials</a>.</p>
</div>
</div>
<div class="section level2">
<h2 id="final-words">Final words<a class="anchor" aria-label="anchor" href="#final-words"></a>
</h2>
<ul>
<li>Don’t use default settings for preprocessing algorithms.</li>
<li>Use the infrastructure provided by the RforMassSpectrometry package
ecosystem to inspect, explore and summarize the data.</li>
<li>Unleash the power of R!
<ul>
<li>Create own visualization/summarization functions if needed.</li>
<li>Combine functionalities from different packages.</li>
<li>Create customized (and reproducible) analysis workflows.</li>
</ul>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="appendix">Appendix<a class="anchor" aria-label="anchor" href="#appendix"></a>
</h2>
<div class="section level3">
<h3 id="additional-visualizations">Additional visualizations<a class="anchor" aria-label="anchor" href="#additional-visualizations"></a>
</h3>
<p>Visualization is key to understand the signal measured by an MS
instrument and also to evaluate the performance (and quality) of the
preprocessing. However, LC-MS data is particularly difficult to
visualize because of its 3-dimensional nature. Focusing on specific
<em>m/z</em> - retention time ranges (EICs) can help, but provides only
information on small subsets of the whole data. In this section we
present an alternative approach to visualize the whole chromatographic
peak space from an LC-MS experiment.</p>
<p>We below subset the data to the first sample and visualize the
identified chromatographic peaks in the <em>m/z</em> - retention time
plane using the <code>plotChromPeaks</code> data function already used
before.</p>
<div class="sourceCode" id="cb130"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot identified chromatographic peaks in the first sample</span></span>
<span><span class="va">data_1</span> <span class="op">&lt;-</span> <span class="va">data</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">data_1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-51-1.png" alt="Position of identified chromatographic peaks in the first sample." width="960"><p class="caption">
Position of identified chromatographic peaks in the first sample.
</p>
</div>
<p>While this plot provides information on the region in which peaks
were identified and on the retention time widths of the peaks, it does
not allow to investigate peak shapes or intensities. Such information
would be provided (for a single ion) by an extracted ion chromatogram.
We thus below extract ion chromatograms for every identified
chromatographic peak in the first sample. With parameter
<code>expandRt = 4</code> we increase for each chromatographic peak the
region from which the data will be extracted by 4 seconds on either
side.</p>
<div class="sourceCode" id="cb131"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract EICs for each identified chromatographic peak</span></span>
<span><span class="va">chrs_all</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/chromPeakChromatograms.html" class="external-link">chromPeakChromatograms</a></span><span class="op">(</span><span class="va">data_1</span>, expandRt <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<p>While we could now simply proceed and plot each of the 357 EICs
separately, we instead use below the
<code>plotChromatogramsOverlay</code> function that allows to plot
multiple EICs into the same plot hence providing an overview of the full
set of identified chromatographic peaks. By setting parameter
<code>stacked</code> to a value different then <code>0</code> it is
possible to <em>stack</em> the chromatograms along the y-axis hence
providing a simple 3-dimensional impression of the data. For easier
visualization we in addition increase the transparency of the colors for
the individual lines (parameter <code>col</code>), and the identified
chromatographic peaks (parameter <code>peakCol</code> and
<code>peakBg</code> for the foreground and background color,
respectively).</p>
<div class="sourceCode" id="cb132"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create a stacked EIC plot</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay</a></span><span class="op">(</span><span class="va">chrs_all</span>, stacked <span class="op">=</span> <span class="fl">1</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>                         col <span class="op">=</span> <span class="st">"#00000020"</span>, peakCol <span class="op">=</span> <span class="st">"#00000020"</span>,</span>
<span>                         peakBg <span class="op">=</span> <span class="st">"#00000020"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-53-1.png" alt="All identified chromatographic peaks in one sample shown as a pseudo 3-dimensional plot." width="960"><p class="caption">
All identified chromatographic peaks in one sample shown as a pseudo
3-dimensional plot.
</p>
</div>
<p>This plot thus provides a general overview of the detected signal
(chromatographic peaks) of a data file. we can immediately spot some
very high intensity peaks, regions with higher number of ions and also
signal from potential contaminants.</p>
<p>Instead of the full data range we can also zoom into a region and
extract EICs from that for a closer inspection of the data. Below we
define an area from a <em>m/z</em> value from 113 to 119 and a retention
time from 125 to 145 seconds.</p>
<div class="sourceCode" id="cb133"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot location of all peaks and highlight region of interest</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">data_1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/rect.html" class="external-link">rect</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fl">113</span>, <span class="fl">145</span>, <span class="fl">119</span>, lty <span class="op">=</span> <span class="fl">3</span>, border <span class="op">=</span> <span class="st">"#ff000080"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-54-1.png" alt="Selected region from which EICs should be extracted and plotted." width="960"><p class="caption">
Selected region from which EICs should be extracted and plotted.
</p>
</div>
<p>With the <em>m/z</em> ranges from the chromatographic peaks in that
region defined, we can next extract ion chromatograms for the data
slices defined by these <em>m/z</em> ranges and the selected (fixed)
retention time range.</p>
<div class="sourceCode" id="cb134"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chrom peaks from that region</span></span>
<span><span class="va">pks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">data_1</span>, mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">113</span>, <span class="fl">119</span><span class="op">)</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fl">145</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract EICs for the m/z slices of the chromatographic peaks</span></span>
<span><span class="co">#' and the full retention time window of the area</span></span>
<span><span class="va">chrs_sub</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">data_1</span>, mz <span class="op">=</span> <span class="va">pks</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                         rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pks</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                                    <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">145</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pks</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We can now plot the EICs from that region again using the
<code>plotChromatogramsOverlay</code> function. Next to plotting the
data, this function also silently returns the y-positions of the
individual EICs in the plot. We assign that below to a variable
<code>y</code> and use this information to draw the <em>m/z</em> for the
EICs along the y-axis.</p>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the EICs of the selected area</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay</a></span><span class="op">(</span><span class="va">chrs_sub</span>, stacked <span class="op">=</span> <span class="fl">1</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>                              col <span class="op">=</span> <span class="st">"#00000020"</span>, peakCol <span class="op">=</span> <span class="st">"#00000020"</span>,</span>
<span>                              peakBg <span class="op">=</span> <span class="st">"#00000020"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Draw horizonal lines</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>h <span class="op">=</span> <span class="va">y</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, col <span class="op">=</span> <span class="st">"#00000020"</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#' Add m/z values of the EICs to the plot</span></span>
<span><span class="va">mzs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MatrixGenerics/man/rowMeans.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">chrs_sub</span><span class="op">)</span><span class="op">)</span>, digits <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">126</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">mzs</span><span class="op">)</span><span class="op">)</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,</span>
<span>     labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"m/z = "</span>, <span class="va">mzs</span><span class="op">)</span>, pos <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-56-1.png" alt="EICs from a selected *m/z* - retention time region." width="960"><p class="caption">
EICs from a selected <em>m/z</em> - retention time region.
</p>
</div>
<p>Some of the EICs seem to represent signals from isotopes (e.g. the
EIC at 114.07 and 115.07). In fact, we can use the
<code>isotopologues</code> function from the
<code>r Biocpkg("MetaboCoreUtils")</code> to check whether pairs of
<em>m/z</em> and intensity values would match signal expected for
isotopes.</p>
<div class="sourceCode" id="cb136"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Order the extracted chromatographic peaks by m/z</span></span>
<span><span class="va">pks</span> <span class="op">&lt;-</span> <span class="va">pks</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">pks</span><span class="op">[</span>, <span class="st">"mz"</span><span class="op">]</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="co">#' Test which signals could come from isotopes</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues</a></span><span class="op">(</span><span class="va">pks</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"into"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">##       CP051 </span></span>
<span><span class="co">##     2     3 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">##       CP052 </span></span>
<span><span class="co">##     4     5</span></span></code></pre>
<p>Pairs of chromatographic peaks have been identified as being
potential isotopologues.</p>
</div>
<div class="section level3">
<h3 id="bonus-material---peak-detection-fun">Bonus material - peak detection fun<a class="anchor" aria-label="anchor" href="#bonus-material---peak-detection-fun"></a>
</h3>
<p>In this section we apply the lessons learned from previous sections,
in particular how to adapt peak detection setting on a rather noisy
<em>chromatographic</em> data. Below we load the example data from a
text file.</p>
<div class="sourceCode" id="cb138"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"txt"</span>, <span class="st">"chromatogram.txt"</span>, package <span class="op">=</span> <span class="st">"xcmsTutorials"</span><span class="op">)</span>,</span>
<span>    sep <span class="op">=</span> <span class="st">"\t"</span>, header <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##    rt intensity</span></span>
<span><span class="co">## 1 100         0</span></span>
<span><span class="co">## 2 110         0</span></span>
<span><span class="co">## 3 120         1</span></span>
<span><span class="co">## 4 130         2</span></span>
<span><span class="co">## 5 140         4</span></span>
<span><span class="co">## 6 150         6</span></span></code></pre>
<p>Our data has two columns, one with <em>retention times</em> and one
with <em>intensities</em>. We can now create a <code>Chromatogram</code>
object from that and plot the data.</p>
<div class="sourceCode" id="cb140"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://lgatto.github.io/MSnbase/reference/Chromatogram-class.html" class="external-link">Chromatogram</a></span><span class="op">(</span>rtime <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">rt</span>, intensity <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">intensity</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chr</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/peaks-plot-1.png" width="1152"></p>
<p>There are two peaks present in the data, with the signal from the
latter being particularly noisy. The goal is now to perform the peak
detection and to identify the two peaks. A first try with the default
settings for <em>centWave</em> clearly shows that we have to tune the
parameters (note that the setting of <code>sn = 0</code> is required for
the present data set as there are not enough <em>background</em> data
points for the algorithm to estimate the noise level properly).</p>
<p>Which parameter would you now adapt to the data? What would be your
choices? Go ahead and try different settings or setting combination to
see if you can succeed in detecting the two peaks. Eventually you might
even try a different peak detection algorithm
(e.g. <code>MatchedFilterParam</code>).</p>
<div class="sourceCode" id="cb141"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xchr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">chr</span>, param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>sn <span class="op">=</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">xchr</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/peaks-fail-1.png" width="1152"></p>
<p>With the default parameters centWave clearly failed to identify the
two large peaks, defining only smaller fragments of them as potential
peaks. Especially the second peak with its peculiar tri-forked shape
seems to cause troubles. This would be even for a hydrophilic liquid
interaction chromatography (HILIC), known to potentially result in noisy
odd-shaped peaks, a rather unusual peak shape. In fact, the signal we
were analyzing here is not of chromatographic origin:</p>
<p><img src="xcms-preprocessing_files/figure-html/peaks-solution-1.png" width="1152"></p>
<p>Our example data represents a panorama picture featuring mountains
from the Dolomites, the <a href="https://en.wikipedia.org/wiki/Paternkofel" class="external-link"><em>Paternkofel</em></a>
(left peak, colored red) and the famous <a href="https://en.wikipedia.org/wiki/Tre_Cime_di_Lavaredo" class="external-link"><em>Drei
Zinnen</em></a> (right tri-forked peak colored green).</p>
</div>
</div>
<div class="section level2">
<h2 id="session-information">Session information<a class="anchor" aria-label="anchor" href="#session-information"></a>
</h2>
<div class="sourceCode" id="cb142"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## R version 4.3.1 (2023-06-16)</span></span>
<span><span class="co">## Platform: x86_64-pc-linux-gnu (64-bit)</span></span>
<span><span class="co">## Running under: Ubuntu 22.04.3 LTS</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Matrix products: default</span></span>
<span><span class="co">## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 </span></span>
<span><span class="co">## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## locale:</span></span>
<span><span class="co">##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              </span></span>
<span><span class="co">##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    </span></span>
<span><span class="co">##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   </span></span>
<span><span class="co">##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 </span></span>
<span><span class="co">##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            </span></span>
<span><span class="co">## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## time zone: Etc/UTC</span></span>
<span><span class="co">## tzcode source: system (glibc)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## attached base packages:</span></span>
<span><span class="co">## [1] stats4    stats     graphics  grDevices utils     datasets  methods  </span></span>
<span><span class="co">## [8] base     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## other attached packages:</span></span>
<span><span class="co">##  [1] RColorBrewer_1.1-3          png_0.1-8                  </span></span>
<span><span class="co">##  [3] SummarizedExperiment_1.31.1 GenomicRanges_1.53.1       </span></span>
<span><span class="co">##  [5] GenomeInfoDb_1.37.4         IRanges_2.35.2             </span></span>
<span><span class="co">##  [7] MatrixGenerics_1.13.1       matrixStats_1.0.0          </span></span>
<span><span class="co">##  [9] MetaboCoreUtils_1.9.2       Spectra_1.11.11            </span></span>
<span><span class="co">## [11] MsExperiment_1.3.0          xcms_3.99.4                </span></span>
<span><span class="co">## [13] MSnbase_2.27.1              ProtGenerics_1.33.1        </span></span>
<span><span class="co">## [15] S4Vectors_0.39.2            mzR_2.35.1                 </span></span>
<span><span class="co">## [17] Rcpp_1.0.11                 Biobase_2.61.0             </span></span>
<span><span class="co">## [19] BiocGenerics_0.47.0         BiocParallel_1.35.4        </span></span>
<span><span class="co">## [21] rmarkdown_2.25              knitr_1.44                 </span></span>
<span><span class="co">## [23] BiocStyle_2.29.2           </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## loaded via a namespace (and not attached):</span></span>
<span><span class="co">##  [1] bitops_1.0-7                rlang_1.1.1                </span></span>
<span><span class="co">##  [3] magrittr_2.0.3              clue_0.3-65                </span></span>
<span><span class="co">##  [5] MassSpecWavelet_1.67.0      compiler_4.3.1             </span></span>
<span><span class="co">##  [7] systemfonts_1.0.4           vctrs_0.6.3                </span></span>
<span><span class="co">##  [9] stringr_1.5.0               pkgconfig_2.0.3            </span></span>
<span><span class="co">## [11] crayon_1.5.2                fastmap_1.1.1              </span></span>
<span><span class="co">## [13] XVector_0.41.1              utf8_1.2.3                 </span></span>
<span><span class="co">## [15] preprocessCore_1.63.1       ragg_1.2.5                 </span></span>
<span><span class="co">## [17] purrr_1.0.2                 MultiAssayExperiment_1.27.5</span></span>
<span><span class="co">## [19] xfun_0.40                   zlibbioc_1.47.0            </span></span>
<span><span class="co">## [21] cachem_1.0.8                jsonlite_1.8.7             </span></span>
<span><span class="co">## [23] progress_1.2.2              DelayedArray_0.27.10       </span></span>
<span><span class="co">## [25] prettyunits_1.2.0           parallel_4.3.1             </span></span>
<span><span class="co">## [27] cluster_2.1.4               R6_2.5.1                   </span></span>
<span><span class="co">## [29] bslib_0.5.1                 stringi_1.7.12             </span></span>
<span><span class="co">## [31] limma_3.57.8                jquerylib_0.1.4            </span></span>
<span><span class="co">## [33] bookdown_0.35               iterators_1.0.14           </span></span>
<span><span class="co">## [35] igraph_1.5.1                splines_4.3.1              </span></span>
<span><span class="co">## [37] Matrix_1.6-1.1              tidyselect_1.2.0           </span></span>
<span><span class="co">## [39] abind_1.4-5                 yaml_2.3.7                 </span></span>
<span><span class="co">## [41] doParallel_1.0.17           codetools_0.2-19           </span></span>
<span><span class="co">## [43] affy_1.79.3                 lattice_0.21-8             </span></span>
<span><span class="co">## [45] tibble_3.2.1                plyr_1.8.8                 </span></span>
<span><span class="co">## [47] evaluate_0.22               survival_3.5-7             </span></span>
<span><span class="co">## [49] desc_1.4.2                  pillar_1.9.0               </span></span>
<span><span class="co">## [51] affyio_1.71.0               BiocManager_1.30.22        </span></span>
<span><span class="co">## [53] foreach_1.5.2               MALDIquant_1.22.1          </span></span>
<span><span class="co">## [55] ncdf4_1.21                  generics_0.1.3             </span></span>
<span><span class="co">## [57] rprojroot_2.0.3             RCurl_1.98-1.12            </span></span>
<span><span class="co">## [59] hms_1.1.3                   ggplot2_3.4.3              </span></span>
<span><span class="co">## [61] munsell_0.5.0               scales_1.2.1               </span></span>
<span><span class="co">## [63] glue_1.6.2                  lazyeval_0.2.2             </span></span>
<span><span class="co">## [65] MsFeatures_1.9.0            tools_4.3.1                </span></span>
<span><span class="co">## [67] mzID_1.39.0                 robustbase_0.99-0          </span></span>
<span><span class="co">## [69] QFeatures_1.11.2            vsn_3.69.0                 </span></span>
<span><span class="co">## [71] RANN_2.6.1                  fs_1.6.3                   </span></span>
<span><span class="co">## [73] XML_3.99-0.14               grid_4.3.1                 </span></span>
<span><span class="co">## [75] impute_1.75.1               MsCoreUtils_1.13.1         </span></span>
<span><span class="co">## [77] colorspace_2.1-0            GenomeInfoDbData_1.2.10    </span></span>
<span><span class="co">## [79] cli_3.6.1                   textshaping_0.3.6          </span></span>
<span><span class="co">## [81] fansi_1.0.4                 S4Arrays_1.1.6             </span></span>
<span><span class="co">## [83] dplyr_1.1.3                 AnnotationFilter_1.25.0    </span></span>
<span><span class="co">## [85] pcaMethods_1.93.0           gtable_0.3.4               </span></span>
<span><span class="co">## [87] DEoptimR_1.1-2              sass_0.4.7                 </span></span>
<span><span class="co">## [89] digest_0.6.33               SparseArray_1.1.12         </span></span>
<span><span class="co">## [91] multtest_2.57.0             memoise_2.0.1              </span></span>
<span><span class="co">## [93] htmltools_0.5.6             pkgdown_2.0.7              </span></span>
<span><span class="co">## [95] lifecycle_1.0.3             statmod_1.5.0              </span></span>
<span><span class="co">## [97] MASS_7.3-60</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="acknowledgments">Acknowledgments<a class="anchor" aria-label="anchor" href="#acknowledgments"></a>
</h2>
<p>Thank you to <a href="https://github.com/philouail" class="external-link">Philippine
Louail</a> for fixing typos and suggesting improvements.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Conley:2014ha" class="csl-entry">
Conley, Christopher J, Rob Smith, Ralf J O Torgrip, Ryan M Taylor, Ralf
Tautenhahn, and John T Prince. 2014. <span>“<span class="nocase">Massifquant: open-source Kalman filter-based XC-MS
isotope trace feature detection.</span>”</span> <em>Bioinformatics</em>
30 (18): 2636–43.
</div>
<div id="ref-Katajamaa:2006jh" class="csl-entry">
Katajamaa, Mikko, Jarkko Miettinen, and Matej Oresic. 2006. <span>“<span class="nocase">MZmine: toolbox for processing and visualization of mass
spectrometry based molecular profile data.</span>”</span>
<em>Bioinformatics</em> 22 (5): 634–36.
</div>
<div id="ref-Prince:2006jj" class="csl-entry">
Prince, John T, and Edward M Marcotte. 2006. <span>“<span class="nocase">Chromatographic alignment of ESI-LC-MS proteomics data
sets by ordered bijective interpolated warping.</span>”</span>
<em>Analytical Chemistry</em> 78 (17): 6140–52.
</div>
<div id="ref-Smith:2006ic" class="csl-entry">
Smith, Colin A, Elizabeth J Want, Grace O’Maille, Ruben Abagyan, and
Gary Siuzdak. 2006. <span>“<span class="nocase">XCMS: processing mass
spectrometry data for metabolite profiling using nonlinear peak
alignment, matching, and identification.</span>”</span> <em>Analytical
Chemistry</em> 78 (3): 779–87.
</div>
<div id="ref-Smith:2014di" class="csl-entry">
Smith, Rob, Andrew D Mathis, Dan Ventura, and John T Prince. 2014.
<span>“<span class="nocase">Proteomics, lipidomics, metabolomics: a mass
spectrometry tutorial from a computer scientist’s point of
view.</span>”</span> <em>BMC Bioinformatics</em> 15 Suppl 7 (Suppl 7):
S9.
</div>
<div id="ref-Tautenhahn:2008fx" class="csl-entry">
Tautenhahn, Ralf, Christoph Böttcher, and Steffen Neumann. 2008.
<span>“<span class="nocase">Highly sensitive feature detection for high
resolution LC/MS.</span>”</span> <em>BMC Bioinformatics</em> 9 (1): 504.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Johannes Rainer.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
