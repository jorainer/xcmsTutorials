<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Exploring and Analyzing LC-MS Data with Spectra and xcms • xcmsTutorials</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Exploring and Analyzing LC-MS Data with Spectra and xcms">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">xcmsTutorials</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.2</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/xcms-preprocessing.html">Exploring and Analyzing LC-MS Data with Spectra and xcms</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/jorainer/xcmsTutorials/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Exploring and Analyzing LC-MS Data with Spectra and xcms</h1>
                        <h4 data-toc-skip class="author">Philippine
Louail, Johannes Rainer</h4>
            <address class="author_afil">
      Eurac Research, Bolzano, Italy; <a href="mailto:johannes.rainer@eurac.edu" class="email">johannes.rainer@eurac.edu</a> github:
jorainer<br><h4 data-toc-skip class="date">February 2024</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jorainer/xcmsTutorials/blob/main/vignettes/xcms-preprocessing.Rmd" class="external-link"><code>vignettes/xcms-preprocessing.Rmd</code></a></small>
      <div class="d-none name"><code>xcms-preprocessing.Rmd</code></div>
    </address>
</div>

    
    
<div class="section level2">
<h2 id="abstract">Abstract<a class="anchor" aria-label="anchor" href="#abstract"></a>
</h2>
<p>In this document we discuss liquid chromatography (LC) mass
spectrometry (MS) data handling and exploration using the <em><a href="https://bioconductor.org/packages/3.19/MsExperiment" class="external-link">MsExperiment</a></em>
and <em><a href="https://bioconductor.org/packages/3.19/Spectra" class="external-link">Spectra</a></em>
Bioconductor packages and perform the preprocessing of a small LC-MS
data set using the <em><a href="https://bioconductor.org/packages/3.19/xcms" class="external-link">xcms</a></em>
package. Functionality from the <em><a href="https://bioconductor.org/packages/3.19/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
and <em><a href="https://bioconductor.org/packages/3.19/MsCoreUtils" class="external-link">MsCoreUtils</a></em>
packages are used for general tasks frequently performed during
metabolomics data analysis. Ultimately, the functionality from these
packages can be combined to build custom, data set-specific (and
reproducible) analysis workflows.</p>
<p>In the present workshop, we first focus on data import, access and
visualization which is followed by the description of a simple data
centroiding approach and finally we present an <em>xcms</em>-based LC-MS
data preprocessing that comprises chromatographic peak detection,
alignment and correspondence. Data normalization procedures, compound
identification and differential abundance analysis are not covered here.
Particular emphasis is given on deriving and defining data set-dependent
values for the most critical <em>xcms</em> preprocessing parameters.</p>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Preprocessing is the first step in the analysis of
<em>untargeted</em> LC-MS or gas chromatography (GC)-MS data. The aim of
the preprocessing is the quantification of signals from ions measured in
a sample, adjusting for any potential retention time drifts between
samples followed by the matching of the quantified signal across samples
within an experiment. The resulting two-dimensional matrix with
abundances of the so called <em>LC-MS features</em> in all samples can
then be further processed, e.g. by normalizing the data to remove
differences due to sample processing, batch effects or injection
order-dependent signal drifts. LC-MS features are usually only
characterized by their mass-to-charge ratio (<em>m/z</em>) and retention
time and hence need to be annotated to the actual ions and metabolites
they represent. Data normalization and annotation are not covered by
this tutorial but links to related tutorials and workshops are provided
at the end of the document.</p>
<div class="section level3">
<h3 id="mass-spectrometry">Mass spectrometry<a class="anchor" aria-label="anchor" href="#mass-spectrometry"></a>
</h3>
<p>Mass spectrometry allows to measure abundances of charged molecules
(ions) in a sample. Abundances are determined as ion counts for a
specific mass-to-charge ratio <em>m/z</em>. The measured signal is
represented as a spectrum: intensities along <em>m/z</em>.</p>
<p><img src="images/MS.png"></p>
<p>Many ions will result, when measured with MS alone, in a very similar
<em>m/z</em>. Thus, making it difficult or impossible to discriminate
them. MS is therefore frequently coupled with a second technology to
separate ions prior quantification based on properties other than their
mass (e.g. based on their polarity). Common choices are gas
chromatography (GC) or liquid chromatography (LC). In a typical LC-MS
setup a sample gets injected into the system, the molecules in the
sample are separated in the LC column, get ionized and then measured (at
discrete time points) by the MS instrument (see Figure below for a
simple visualization). Molecules get thus separated on two different
dimensions, the retention time dimension (from the LC) and the
mass-to-charge dimension (from the MS) making it easier to measure and
identify molecules in more complex samples.</p>
<p><img src="images/LC-MS-drawing.gif"></p>
<p>In such GC/LC-MS based untargeted metabolomics experiments, the data
is analyzed along the retention time dimension and
<em>chromatographic</em> peaks (which are supposed to represent the
signal from ions of a certain type of molecule) are quantified.</p>
</div>
<div class="section level3">
<h3 id="goals-of-this-workshop">Goals of this workshop<a class="anchor" aria-label="anchor" href="#goals-of-this-workshop"></a>
</h3>
<ul>
<li><p>Learn how R/<em>xcms</em> and the packages from the <a href="https://rformassspectrometry.org" class="external-link">RforMassSpectrometry
initiative</a> can be used to inspect, evaluate and analyze LC-MS
data.</p></li>
<li><p>Learn the basis to build reproducible analysis workflows,
tailored and customized for individual data sets.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="definitions-and-common-naming-convention">Definitions and common naming convention<a class="anchor" aria-label="anchor" href="#definitions-and-common-naming-convention"></a>
</h3>
<p>Naming conventions and terms used in this document are:</p>
<ul>
<li>
<em>chromatographic peak</em>: peak containing the signal from an
ion in retention time dimension (different from a <em>mass</em> peak
that represents the signal along the <em>m/z</em> dimension within a
spectrum).</li>
<li>
<em>chromatographic peak detection</em>: process in which
chromatographic peaks are identified within a sample (file).</li>
<li>
<em>alignment</em>: process that adjusts for retention time
differences (i.e. possible signal drifts from the LC) between
measurements/samples.</li>
<li>
<em>correspondence</em>: grouping of chromatographic peaks
(presumably from the same ion) across samples/files into <em>LC-MS
features</em>.</li>
<li>
<em>feature</em> (or <em>LC-MS features</em>): entity representing
signal from the same type of ion/molecule, characterized by its specific
retention time and <em>m/z</em>. In <em>xcms</em>, features represent
identified chromatographic peaks grouped across samples/files.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="data-import-and-exploration">Data import and exploration<a class="anchor" aria-label="anchor" href="#data-import-and-exploration"></a>
</h2>
<p>The example data set of this workflow consists of two files in mzML
format with signals from pooled human serum samples measured with a
ultra high performance liquid chromatography (UHPLC) system (Agilent
1290) coupled with a Q-TOF MS (TripleTOF 5600+ AB Sciex) instrument.
Chromatographic separation was based on hydrophilic interaction liquid
chromatography (HILIC) separating metabolites depending on their
polarity. The input files contain all signals measured by the MS
instrument (so called <em>profile mode</em> data). To reduce file sizes,
the data set was restricted to an <em>m/z</em> range from 105 to 134 and
retention times from 0 to 260 seconds. Both QC pool samples were taken
from a larger experiment and were injected in the same measurement run
at different time points (injected in position 1 and 19 of the
measurement run).</p>
<p>In the code block below we first load all required libraries and
define the location of the mzML files, which are distributed through the
<em>msdata</em> R package. We also define a <code>data.frame</code> with
the names of the mzML files, an arbitrary sample name, the index in
which the respective sample was measured within the LC-MS run and the
sample <em>group</em> of the samples. It is generally suggested to
provide all experiment-relevant phenotypic and technical information
through such a data frame. Also, the data frame could be defined in an
xls sheet that could then be imported with the <code>read_xlsx</code>
function from the <em>readxl</em> R package. This data frame is then
passed, along with the file names, to the
<code><a href="https://rdrr.io/pkg/MsExperiment/man/readMsExperiment.html" class="external-link">readMsExperiment()</a></code> call to import the data.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Load required libraries</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/sneumann/xcms" class="external-link">xcms</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/MsExperiment" class="external-link">MsExperiment</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/Spectra" class="external-link">Spectra</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Define the file names.</span></span>
<span><span class="va">fls</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.files.html" class="external-link">dir</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"sciex"</span>, package <span class="op">=</span> <span class="st">"msdata"</span><span class="op">)</span>, full.names <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Define a data.frame with additional information on these files.</span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="va">fls</span><span class="op">)</span>,</span>
<span>                 sample <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"POOL_1"</span>, <span class="st">"POOL_2"</span><span class="op">)</span>,</span>
<span>                 injection_index <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">19</span><span class="op">)</span>,</span>
<span>                 group <span class="op">=</span> <span class="st">"POOL"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Import the data of the experiment</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/readMsExperiment.html" class="external-link">readMsExperiment</a></span><span class="op">(</span><span class="va">fls</span>, sampleData <span class="op">=</span> <span class="va">pd</span><span class="op">)</span></span>
<span><span class="va">mse</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class MsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span></code></pre>
<p>The MS data of the experiment is now <em>represented</em> by an
<code>MsExperiment</code> object.</p>
<div class="section level3">
<h3 id="basic-data-access">Basic data access<a class="anchor" aria-label="anchor" href="#basic-data-access"></a>
</h3>
<p>The <code>MsExperiment</code> object manages the <em>linkage</em>
between samples and spectra. The <code><a href="https://rdrr.io/r/base/length.html" class="external-link">length()</a></code> of an
<code>MsExperiment</code> is defined by the number of samples (files)
within the object.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Number of samples</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 2</span></span></code></pre>
<p>Subset the <code>MsExperiment</code> will restrict (all) data within
the object to the selected sample(s). To restrict to data from the
second sample we use:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Subset the data</span></span>
<span><span class="va">mse_2</span> <span class="op">&lt;-</span> <span class="va">mse</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">mse_2</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class MsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (931) </span></span>
<span><span class="co">##  Experiment data: 1 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 1 sample(s) to 931 element(s).</span></span></code></pre>
<p>This did subset the full data, including sample information and
spectra data to those of the second file. Phenotype information can be
retrieved with the <code><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData()</a></code> function from an
<code>MsExperiment</code> object.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract sample information</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">mse_2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 1 row and 5 columns</span></span>
<span><span class="co">##            file      sample injection_index       group spectraOrigin</span></span>
<span><span class="co">##     &lt;character&gt; &lt;character&gt;       &lt;numeric&gt; &lt;character&gt;   &lt;character&gt;</span></span>
<span><span class="co">## 1 20171016_P...      POOL_2              19        POOL /usr/local...</span></span></code></pre>
<p>The MS data is stored as a <code>Spectra</code> object within the
<code>MsExperiment</code> and can be accessed using the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra()</a></code> function.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Access the MS data</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##        msLevel     rtime scanIndex</span></span>
<span><span class="co">##      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1            1     0.280         1</span></span>
<span><span class="co">## 2            1     0.559         2</span></span>
<span><span class="co">## 3            1     0.838         3</span></span>
<span><span class="co">## 4            1     1.117         4</span></span>
<span><span class="co">## 5            1     1.396         5</span></span>
<span><span class="co">## ...        ...       ...       ...</span></span>
<span><span class="co">## 1858         1   258.636       927</span></span>
<span><span class="co">## 1859         1   258.915       928</span></span>
<span><span class="co">## 1860         1   259.194       929</span></span>
<span><span class="co">## 1861         1   259.473       930</span></span>
<span><span class="co">## 1862         1   259.752       931</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span></code></pre>
<p>From version 4 on, <em>xcms</em> supports the more modern and
flexible infrastructure for MS data analysis provided by the <em><a href="https://bioconductor.org/packages/3.19/Spectra" class="external-link">Spectra</a></em>
package. While it is still possible to use <em>xcms</em> together with
the <em><a href="https://bioconductor.org/packages/3.19/MSnbase" class="external-link">MSnbase</a></em>
package, users are advised to switch to the newer infrastructure as it
provides more flexibility and a higher performance. Also, through
additional packages such as the <em><a href="https://bioconductor.org/packages/3.19/MsBackendRawFileReader" class="external-link">MsBackendRawFileReader</a></em>,
the new infrastructure would allow to import MS data also from other
files than mzML, mzXML or CDF files.</p>
<p>In the next few examples we briefly explain the <code>Spectra</code>
object and illustrate the use of such objects using some simple
examples. More information on <code>Spectra</code> objects can be found
in the package’s <a href="https://RforMassSpectrometry.github.io/Spectra" class="external-link">documentation</a>
or the <a href="https://jorainer.github.io/SpectraTutorials" class="external-link">SpectraTutorials</a>.</p>
<p>The <code>Spectra</code> object contains the full MS data of the
experiment. It’s length is thus equal to the total number of spectra
within the experiment. Below we determine this number for our example
data set. To avoid nested function calls and hence improve the
readability of the code, we use the R pipe operator <code>|&gt;</code>
that allows to concatenate consecutive calls in a more readable
fashion.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the total number of spectra</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1862</span></span></code></pre>
<p>The <code>Spectra</code> object itself is agnostic of any sample
information, it simply contains all spectra from the experiment, first
all spectra from the first file, followed by the spectra from the
second. The mapping of spectra to samples is defined in the
<code>MsExperiment</code> object. To access spectra from a specific
sample we either subset the <code>MsExperiment</code> to that particular
sample (as done in the example above) or we use the
<code><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">spectraSampleIndex()</a></code> function that returns for each
spectrum the index of the file within the <code>MsExperiment</code> to
which it belongs. Below we use <code><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">spectraSampleIndex()</a></code> to
determine the total number of spectra per sample.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the number of spectra per file.</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">spectraSampleIndex</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## 931 931</span></span></code></pre>
<p>Such basic data summaries can be helpful for a first initial quality
assessment to identify potentially problematic data files with e.g. a
unexpected low number of spectra.</p>
<p>Besides the peak data (<em>m/z</em> and intensity values) also
additional spectra variables (metadata) are available in a
<code>Spectra</code> object. These can be listed using the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectraVariables()</a></code> function that we call on our example MS
data below.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' List available spectra variables</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectraVariables</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] "msLevel"                  "rtime"                   </span></span>
<span><span class="co">##  [3] "acquisitionNum"           "scanIndex"               </span></span>
<span><span class="co">##  [5] "dataStorage"              "dataOrigin"              </span></span>
<span><span class="co">##  [7] "centroided"               "smoothed"                </span></span>
<span><span class="co">##  [9] "polarity"                 "precScanNum"             </span></span>
<span><span class="co">## [11] "precursorMz"              "precursorIntensity"      </span></span>
<span><span class="co">## [13] "precursorCharge"          "collisionEnergy"         </span></span>
<span><span class="co">## [15] "isolationWindowLowerMz"   "isolationWindowTargetMz" </span></span>
<span><span class="co">## [17] "isolationWindowUpperMz"   "peaksCount"              </span></span>
<span><span class="co">## [19] "totIonCurrent"            "basePeakMZ"              </span></span>
<span><span class="co">## [21] "basePeakIntensity"        "ionisationEnergy"        </span></span>
<span><span class="co">## [23] "lowMZ"                    "highMZ"                  </span></span>
<span><span class="co">## [25] "mergedScan"               "mergedResultScanNum"     </span></span>
<span><span class="co">## [27] "mergedResultStartScanNum" "mergedResultEndScanNum"  </span></span>
<span><span class="co">## [29] "injectionTime"            "filterString"            </span></span>
<span><span class="co">## [31] "spectrumId"               "ionMobilityDriftTime"    </span></span>
<span><span class="co">## [33] "scanWindowLowerLimit"     "scanWindowUpperLimit"</span></span></code></pre>
<p>Thus, for all spectra we have general information such as the MS
level (<code>"msLevel"</code>) or the retention time
(<code>"rtime"</code>) available. For most of these spectra variables
dedicated accessor functions are available (such as
<code>msLevel</code>, <code>rtime</code>). In addition it is possible to
access any variable using <code>$</code> and the name of the variable
(similar to accessing the columns of a <code>data.frame</code>). As an
example we extract below the <code>msLevel</code> spectra variable and
use the <code><a href="https://rdrr.io/pkg/BiocGenerics/man/table.html" class="external-link">table()</a></code> function on the result to get an overview
of the number of spectra from different MS levels available in the
object.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' List number of spectra per MS level</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">msLevel</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##    1 </span></span>
<span><span class="co">## 1862</span></span></code></pre>
<p>The present data set contains thus 1,862 spectra, all from MS level
1.</p>
<p>We could also check the number of peaks per spectrum in the different
data files. The number of peaks per spectrum can be extracted with the
<code><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths()</a></code> function. Below we extract these values, split
them by file and then calculate the quartiles of the peak counts using
the <code><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile()</a></code> function.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the distribution of peak counts per file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/S4Vectors/man/splitAsList.html" class="external-link">split</a></span><span class="op">(</span><span class="fu">fromFile</span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">quantile</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $`1`</span></span>
<span><span class="co">##     0%    25%    50%    75%   100% </span></span>
<span><span class="co">##  456.0 1122.5 1536.0 2089.0 3995.0 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $`2`</span></span>
<span><span class="co">##     0%    25%    50%    75%   100% </span></span>
<span><span class="co">##  481.0 1101.5 1557.0 2153.5 4088.0</span></span></code></pre>
<p>Thus, for the present data set, the number of spectra and also the
average number of peaks per spectra are comparable.</p>
<p>Individual MS spectra can be accessed by subsetting the
<code>Spectra</code> object returned by <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra()</a></code>. As an
example we below subset the data to the second sample, extract the
spectra from that sample and subset to the spectrum number 123.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract one spectrum from the second file</span></span>
<span><span class="va">sp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">[</span><span class="fl">123</span><span class="op">]</span></span>
<span><span class="va">sp</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 1 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1    34.314       123</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span></code></pre>
<p><em>m/z</em> and intensity values can be extracted from a
<code>Spectra</code> using the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz()</a></code> and
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity()</a></code> functions that (always) return a list of
<code>numeric</code> vectors with the respective values:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract m/z values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## NumericList of length 1</span></span>
<span><span class="co">## [[1]] 105.95354942709 105.955001209814 ... 133.105299625013 133.106926815539</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract intensity values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## NumericList of length 1</span></span>
<span><span class="co">## [[1]] 0 282 0 141 0 0 141 0 141 0 141 0 ... 563 563 422 0 0 282 282 0 282 141 0</span></span></code></pre>
<p>As an alternative, the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/peaksData.html" class="external-link">peaksData()</a></code> function could be
used to extract both the <em>m/z</em> and intensity values (as
two-column numeric matrix) with a single function call.</p>
<p>The total ion signal of a spectrum could be calculated by simply
summing the intensities of all peaks in the spectrum. Below we perform
that operation on the spectrum extracted above.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate total ion signal for the extracted spectrum</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">sp</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 604912</span></span></code></pre>
<p>The same operation can also be applied to the full data set. As an
example we calculate below the total ion signal for each spectrum in the
first file and determine the distribution of these using the
<code><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile()</a></code> function.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the distribution of total ion signal of the first file</span></span>
<span><span class="va">mse</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        0%       25%       50%       75%      100% </span></span>
<span><span class="co">##   69074.0  445575.5  697201.0  897149.5 1562795.0</span></span></code></pre>
<p>We repeat the operation for the second file.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Repeat for the second file</span></span>
<span><span class="va">mse</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##        0%       25%       50%       75%      100% </span></span>
<span><span class="co">##   70414.0  404923.5  674512.0  878191.0 1679901.0</span></span></code></pre>
<p>The total ion signals of the two data files is (as expected) similar.
Through the <code>Spectra</code> object we have thus the possibility to
inspect and explore the (raw) MS data of an experiment and use its
functionality to create own quality assessment functions. Alternatively,
also the <em><a href="https://bioconductor.org/packages/3.19/MsQuality" class="external-link">MsQuality</a></em>
package <span class="citation">(Naake, Rainer, and Huber 2023)</span>
could be used to calculate core MS quality metrics on a full experiment
(<code>MsExperiment</code>) or individual data files
(<code>Spectra</code>).</p>
</div>
<div class="section level3">
<h3 id="data-visualization">Data visualization<a class="anchor" aria-label="anchor" href="#data-visualization"></a>
</h3>
<div class="section level4">
<h4 id="general-data-overview">General data overview<a class="anchor" aria-label="anchor" href="#general-data-overview"></a>
</h4>
<p>Visualization is crucial for quality assessment of MS data. For LC-MS
data visualizing a base peak chromatogram (BPC) or total ion
chromatogram (TIC) would for example allow to evaluate the performance
of the liquid chromatography of the various samples in an experiment. To
create such a plot we below extract the BPC from our data. The BPC
extracts the maximum peak signal from each spectrum in a data file and
allows thus to plot this information (on the y-axis) against the
retention time for that spectrum. While we could also extract these
values similarly to the total ion intensity in the previous section, we
use below the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> function that allows
extraction of chromatographic data from MS data (e.g. from an
<code>MsExperiment</code> object). With parameter
<code>aggregationFun = "max"</code> we define to report the maximum
signal per spectrum (setting <code>aggregationFun = "sum"</code> would
in contrast sum up all intensities of a spectrum and hence return a
TIC).</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract and plot a BPC</span></span>
<span><span class="va">bpc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-13-1.png" width="960"></p>
<p>This plot shows the BPC for each of the two data files (each line
representing one sample) and provides the information at what retention
times signal was measured (thus at what retention times compounds eluted
from the LC column). We can clearly spot regions along the retention
time in which more signal/compounds eluted. Also, the BPC of the two
data files look similar, which is expected since both represent the same
sample.</p>
<p>In addition to a visual inspection it is, especially for larger data
sets, important to also <em>quantitatively</em> compare the data and
derive quality metrics of a data set. For our base peak signals,
however, retention times will be slightly different between the samples
preventing thus a direct comparison and evaluation of this data. An easy
solution to this is to <em>bin</em> the data along the retention time
axis into equal sized bins and aggregate the measured intensities within
each bin (per sample). Below we bin the data with a bin size of 1 second
reporting the maximal signal per bin.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Bin the BPC</span></span>
<span><span class="va">bpc_bin</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">bin</a></span><span class="op">(</span><span class="va">bpc</span>, binSize <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>After binning, the two chromatograms have the same retention times
(and number of intensities) and we can thus <em>bind</em> their
intensity vectors as columns of a new numeric matrix using
<code><a href="https://rdrr.io/pkg/BiocGenerics/man/cbind.html" class="external-link">cbind()</a></code>:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create an intensity matrix</span></span>
<span><span class="va">bpc_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call</a></span><span class="op">(</span><span class="va">cbind</span>, <span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">lapply</a></span><span class="op">(</span><span class="va">bpc_bin</span>, <span class="va">intensity</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We could now for example calculate the correlation between the
intensities of the two samples, which can be used as a measure for the
<em>similarity</em> of the LC-MS runs.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Assess similarity between the numerical vectors using a simple</span></span>
<span><span class="co">#' Pearson correlation.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">bpc_mat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, <span class="va">bpc_mat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.9605883</span></span></code></pre>
<p>We could also create a correlation matrix with the pairwise
correlation coefficients of all samples against all samples. This would
be particularly helpful for data sets with more than two samples.</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create a pairwise correlation matrix</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">bpc_mat</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           [,1]      [,2]</span></span>
<span><span class="co">## [1,] 1.0000000 0.9605883</span></span>
<span><span class="co">## [2,] 0.9605883 1.0000000</span></span></code></pre>
<p>Such a correlation matrix could also be easily visualized as a
<em>heatmap</em> - with the additional possibility to cluster samples
with similar BPC. While for the present, two-sample data set, this is
not very informative, for larger data sets it can help to evaluate
differences between batches or to spot outlier samples (or rather
outlier LC-MS measurement runs).</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create a heatmap of the correlation matrix</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">pheatmap</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="va">bpc_mat</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/pheatmap/man/pheatmap.html" class="external-link">pheatmap</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-18-1.png" alt="Heatmap for similarity of the BPC of the two data files" width="960"><p class="caption">
Heatmap for similarity of the BPC of the two data files
</p>
</div>
<p>This also exemplifies the power of an R-based analysis workflow that
allows us to combine LC-MS specific analysis methods provided by
e.g. the <em>xcms</em> package with build-in R functions or
(statistical) data analysis methods provided by any other R package.</p>
<p>The BPC collapsed the 3-dimensional LC-MS data (<em>m/z</em> by
retention time by intensity) into 2 dimensions (retention time by
intensity). An orthogonal visualization to this would be a <em>base peak
spectrum</em> (BPS) that collapses the data in retention time dimension.
Such a visualization could provide information on the most abundant
masses (or rather mass-to-charge values) in the data set (regardless of
the retention time in which they were measured). In contrast to the BPC
it is however not straight forward to create such a visualization: mass
peaks, even if representing signal from the same ion, will never be
identical between consecutive spectra, but will slightly differ based on
the measurement error/resolution of the instrument.</p>
<p>Below we plot the spectra for 2 consecutive scans.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot two consecutive spectra</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span><span class="fl">123</span><span class="op">:</span><span class="fl">124</span><span class="op">]</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">105</span>, <span class="fl">130</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-19-1.png" alt="Spectra from two consecutive scan of the first file" width="960"><p class="caption">
Spectra from two consecutive scan of the first file
</p>
</div>
<p>These two spectra could now be merged by reporting for each
<em>m/z</em> (or rather for peaks with very similar <em>m/z</em> in
consecutive spectra) the maximal signal observed. In <em>Spectra</em>,
the <code><a href="https://lgatto.github.io/MSnbase/reference/combineSpectra.html" class="external-link">combineSpectra()</a></code> function allows to aggregate/combine
sets of spectra into a single spectrum. By default, this function will
combine sets of spectra (that can be defined with parameter
<code>f</code>) creating an union of the peaks present in spectra of a
set. For mass peaks with a similar <em>m/z</em> value (depending on
parameter <code>ppm</code>) the peaks’ intensities are aggregated using
the function defined with parameter <code>intensityFun</code> to result
in a single value per (aggregated) peak. With the setting below we
combine all spectra from one file (by using
<code>f = fromFile(mse)</code>) into a single spectrum containing mass
peaks present in any of the spectra of that file. Mass peaks with a
difference in their <em>m/z</em> that is smaller than <code>ppm</code>
(parts-per-million of the <em>m/z</em> value) are combined into one peak
for which the maximal intensity of the grouped peaks is reported. Note
that it is suggested to use a small value for <code>ppm</code> to
combine MS1 spectra with <code><a href="https://lgatto.github.io/MSnbase/reference/combineSpectra.html" class="external-link">combineSpectra()</a></code>.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Combine all spectra of one file into a single spectrum</span></span>
<span><span class="va">bps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/Spectra.html" class="external-link">combineSpectra</a></span><span class="op">(</span>f <span class="op">=</span> <span class="fu">fromFile</span><span class="op">(</span><span class="va">mse</span><span class="op">)</span>, ppm <span class="op">=</span> <span class="fl">5</span>, intensityFun <span class="op">=</span> <span class="va">max</span><span class="op">)</span></span>
<span><span class="va">bps</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 2 spectra in a MsBackendMemory backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1     0.280         1</span></span>
<span><span class="co">## 2         1     0.275         1</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Switch backend from MsBackendMzR to MsBackendMemory [Wed Aug  7 11:31:37 2024]</span></span>
<span><span class="co">##  Switch backend from MsBackendMzR to MsBackendMemory [Wed Aug  7 11:31:39 2024]</span></span>
<span><span class="co">##  Merge 2 Spectra into one [Wed Aug  7 11:31:40 2024]</span></span></code></pre>
<p><code>bps</code> is thus a <code>Spectra</code> with two spectra
representing the BPS of the two data files. Below we plot these.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the BPS</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">bps</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-21-1.png" alt="Base peak spectrum for each of the two samples." width="960"><p class="caption">
Base peak spectrum for each of the two samples.
</p>
</div>
<p>These BPS thus show the most common ions present in each of the two
samples. Apparently there seems to be quite some overlap in ion content
between the two files. Also here, we can calculate similarities between
these spectra. As before, we could either bin the spectra and calculate
a correlation matrix between their intensities:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Bin the spectra and calculate similarity between their intensities</span></span>
<span><span class="va">bps_bin</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">bin</a></span><span class="op">(</span><span class="va">bps</span>, binSize <span class="op">=</span> <span class="fl">0.01</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call</a></span><span class="op">(</span><span class="va">cbind</span>, <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">bps_bin</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           [,1]      [,2]</span></span>
<span><span class="co">## [1,] 1.0000000 0.9898653</span></span>
<span><span class="co">## [2,] 0.9898653 1.0000000</span></span></code></pre>
<p>Alternatively, we can also directly calculate the similarity between
the base peak spectra using the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">compareSpectra()</a></code> function
and one of the available peak similarity measures. Below we use the
normalized dot product to calculate the similarity between the two
spectra matching peaks using an <em>m/z</em> tolerance of 10 ppm.</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate normalized dot product similarity between the spectra</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">compareSpectra</a></span><span class="op">(</span><span class="va">bps</span>, ppm <span class="op">=</span> <span class="fl">10</span>, FUN <span class="op">=</span> <span class="fu">MsCoreUtils</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/MsCoreUtils/man/distance.html" class="external-link">ndotproduct</a></span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           1         2</span></span>
<span><span class="co">## 1 1.0000000 0.9803889</span></span>
<span><span class="co">## 2 0.9803889 1.0000000</span></span></code></pre>
<p>These measures thus allow us to get some general information on a
data set and evaluate similarities between the samples of an
experiment.</p>
</div>
<div class="section level4">
<h4 id="detailed-data-inspection">Detailed data inspection<a class="anchor" aria-label="anchor" href="#detailed-data-inspection"></a>
</h4>
<p>Apart from such general data overview it is also possible (and also
suggested) to explore the data in more detail. To this end we next focus
on a specific subset of the data were we expect signal for a compound
that should be present in serum samples (such as ions of the molecule
serine). With the particular LC-MS setup used for the present samples,
ions for this metabolite are expected to elute at about 180 seconds
(this retention time was determined by measuring a pure standard for
this compound on the same LC-MS setup). We thus filter below the spectra
data using the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt()</a></code> function extracting only spectra
measured between 180 and 181 seconds.</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract all spectra measured between 180 and 181 seconds</span></span>
<span><span class="va">sps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">180</span>, <span class="fl">181</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">sps</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 6 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1   180.240       646</span></span>
<span><span class="co">## 2         1   180.519       647</span></span>
<span><span class="co">## 3         1   180.798       648</span></span>
<span><span class="co">## 4         1   180.235       646</span></span>
<span><span class="co">## 5         1   180.514       647</span></span>
<span><span class="co">## 6         1   180.793       648</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Filter: select retention time [180..181] on MS level(s) 1 [Wed Aug  7 11:31:41 2024]</span></span></code></pre>
<p>For the present data set there are 6 spectra measured within this one
second in both samples. By extracting the data as a <code>Spectra</code>
object we have however lost now the direct (inherent) association
between spectra and samples of the experiment. We could extract the name
of the original data file from which the data was imported (see example
below) and use that to determine the originating sample, but that would
involve additional R code.</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' List the original data file for each spectrum</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">dataOrigin</a></span><span class="op">(</span><span class="va">sps</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "20171016_POOL_POS_1_105-134.mzML" "20171016_POOL_POS_1_105-134.mzML"</span></span>
<span><span class="co">## [3] "20171016_POOL_POS_1_105-134.mzML" "20171016_POOL_POS_3_105-134.mzML"</span></span>
<span><span class="co">## [5] "20171016_POOL_POS_3_105-134.mzML" "20171016_POOL_POS_3_105-134.mzML"</span></span></code></pre>
<p>Alternatively, we could use the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/filterSpectra.html" class="external-link">filterSpectra()</a></code> function
on the <code>MsExperiment</code> object passing the filter function (in
our case <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt()</a></code>) to that function. This filters the
<code>Spectra</code> object <em>within</em> the
<code>MsExperiment</code> retaining all associations (links) between
samples and subset spectra. While some of the most commonly used filter
functions, such as <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt()</a></code> or
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMsLevel()</a></code>, are also implemented for
<code>MsExperiment</code>, the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/filterSpectra.html" class="external-link">filterSpectra()</a></code> function
allows to apply any of the many filter functions available for
<code>Spectra</code> objects to the data.</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Subset the whole MsExperiment</span></span>
<span><span class="va">mse_sub</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/filterSpectra.html" class="external-link">filterSpectra</a></span><span class="op">(</span><span class="va">mse</span>, filter <span class="op">=</span> <span class="va">filterRt</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">180</span>, <span class="fl">181</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#' Extract spectra from the subset for the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse_sub</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## MSn data (Spectra) with 3 spectra in a MsBackendMzR backend:</span></span>
<span><span class="co">##     msLevel     rtime scanIndex</span></span>
<span><span class="co">##   &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## 1         1   180.240       646</span></span>
<span><span class="co">## 2         1   180.519       647</span></span>
<span><span class="co">## 3         1   180.798       648</span></span>
<span><span class="co">##  ... 33 more variables/columns.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## file(s):</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">## Processing:</span></span>
<span><span class="co">##  Filter: select retention time [180..181] on MS level(s) 1 [Wed Aug  7 11:31:41 2024]</span></span></code></pre>
<p>For the present purpose it is however not important to keep the
sample association intact and we thus proceed to plot the previously
extracted spectra.</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the spectra</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">sps</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-27-1.png" alt="MS1 spectra measured between 180 and 181 seconds" width="960"><p class="caption">
MS1 spectra measured between 180 and 181 seconds
</p>
</div>
<p>We can immediately spot several mass peaks in the spectrum, with the
largest one at an <em>m/z</em> of about 130 and the second largest at
about 106, which could represent signal for an ion of <a href="https://en.wikipedia.org/wiki/Serine" class="external-link">Serine</a>. Below we
calculate the exact (monoisotopic) mass for serine from its chemical
formula <em>C3H7NO3</em> using the <code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/calculateMass.html" class="external-link">calculateMass()</a></code> function
from the <em><a href="https://bioconductor.org/packages/3.19/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
package.</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the (monoisotopic) mass of serine</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/RforMassSpectrometry/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></span><span class="op">)</span></span>
<span><span class="va">mass_serine</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/calculateMass.html" class="external-link">calculateMass</a></span><span class="op">(</span><span class="st">"C3H7NO3"</span><span class="op">)</span></span>
<span><span class="va">mass_serine</span></span></code></pre></div>
<pre><code><span><span class="co">##  C3H7NO3 </span></span>
<span><span class="co">## 105.0426</span></span></code></pre>
<p>The <em>native</em> serine molecule is however uncharged and can thus
not be measured by mass spectrometry. In order to be detectable,
molecules need to be ionized before being injected in an MS instrument.
While different ions can (and will) be generated for a molecule, one of
the most commonly generated ions in positive polarity is the
<em>[M+H]+</em> ion (protonated ion). To calculate the <em>m/z</em>
values for specific ions/adducts of molecules, we can use the
<code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/mass2mz.html" class="external-link">mass2mz()</a></code> function, also from the <em>MetaboCoreUtils</em>
package. Below we calculate the <em>m/z</em> for the <em>[M+H]+</em> ion
of serine providing the monoisotopic mass of that molecule and
specifying the adduct we are interested in. Also other types of adducts
are supported. These could be listed with the <code>adductNames</code>
function (<code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/adductNames.html" class="external-link">adductNames()</a></code> for all positively charged and
<code>adductNames("negative")</code> for all negatively charge
ions).</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the m/z for the [M+H]+ ion of serine</span></span>
<span><span class="va">serine_mz</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/mass2mz.html" class="external-link">mass2mz</a></span><span class="op">(</span><span class="va">mass_serine</span>, <span class="st">"[M+H]+"</span><span class="op">)</span></span>
<span><span class="va">serine_mz</span></span></code></pre></div>
<pre><code><span><span class="co">##           [M+H]+</span></span>
<span><span class="co">## C3H7NO3 106.0499</span></span></code></pre>
<p>The <code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/mass2mz.html" class="external-link">mass2mz()</a></code> function <strong>always</strong> returns a
<code>matrix</code> with columns reporting the <em>m/z</em> for the
requested adduct(s) of the molecule(s) which are available in the rows.
Since we requested a single ion we reduce this <code>matrix</code> to a
single <code>numeric</code> value.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">serine_mz</span> <span class="op">&lt;-</span> <span class="va">serine_mz</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span></span></code></pre></div>
<p>We can now use this information to subset the MS data to the signal
recorded for all ions with that particular <em>m/z</em>. We use again
the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> function and provide the <em>m/z</em>
range of interest with the <code>mz</code> parameter of that function.
Note that alternatively we could also first filter the data set by
<em>m/z</em> using the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange()</a></code> function and then
extract the chromatogram.</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract a full RT chromatogram for ions with an m/z similar than serine</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-31-1.png" alt="Ion trace for an ion of serine" width="960"><p class="caption">
Ion trace for an ion of serine
</p>
</div>
<p>A strong signal is visible around a retention time of 180 seconds
which very likely represents signal for the <em>[M+H]+</em> ion of
serine. Note that, if the retention time of a molecule for a specific
LC-MS setup is not known beforehand, extracting such chromatograms for
the <em>m/z</em> of interest and the full retention time range can help
determining its likely retention time.</p>
<p>The object returned by the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> function
arranges the individual <code>MChromatogram</code> objects (each
representing the chromatographic data consisting of pairs of retention
time and intensity values of one sample) in a two-dimensional array,
columns being samples (files) and rows data slices (i.e., <em>m/z</em> -
rt ranges). Note that this type of data representation, defined in the
<em><a href="https://bioconductor.org/packages/3.19/MSnbase" class="external-link">MSnbase</a></em>
package, is likely to be replaced in future with a more efficient and
flexible data structure similar to <code>Spectra</code>.</p>
<p>Data from the individual chromatograms can be accessed using the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity()</a></code> and <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime()</a></code> functions (similar to
the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz()</a></code> and <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity()</a></code> functions for a
<code>Spectra</code> object).</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get intensity values for the chromatogram of the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">intensity</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1]  NA  NA 132  NA  NA  NA</span></span></code></pre>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the respective retention times of the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.280 0.559 0.838 1.117 1.396 1.675</span></span></code></pre>
<p>Note that an <code>NA</code> is reported if in the <em>m/z</em> range
from which the chromatographic data was extracted no intensity was
measured at the given retention time (i.e. in a spectrum).</p>
<p>At last we further focus on the tentative signal of serine extracting
the ion chromatogram restricting on the retention time range containing
its signal. While we could also pass the retention time and <em>m/z</em>
range with parameters <code>rt</code> and <code>mz</code> to the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> function we instead filter the whole
experiment by retention time and <em>m/z</em> before calling
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> on the such created data subset. With the
example code below we thus create an extracted ion chromatogram (EIC,
sometimes also referred to as XIC) for the <em>[M+H]+</em> ion of
serine.</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create an EIC for serine</span></span>
<span><span class="va">mse</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-32-1.png" alt="Extracted ion chromatogram for serine." width="960"><p class="caption">
Extracted ion chromatogram for serine.
</p>
</div>
<p>The area of such a chromatographic peak is supposed to be
proportional to the amount of the corresponding ion in the respective
sample and identification and quantification of such peaks is one of the
goals of the LC-MS data preprocessing.</p>
<p>While we inspected here the signal measured for ions of serine, this
workflow could (and should) also be repeated for other potentially
present ions (or internal standards) to evaluate the LC-MS data of an
experiment.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="centroiding-of-profile-ms-data">Centroiding of profile MS data<a class="anchor" aria-label="anchor" href="#centroiding-of-profile-ms-data"></a>
</h2>
<p>MS instruments allow to export data in profile or centroid mode.
Profile data contains the signal for all discrete <em>m/z</em> values
(and retention times) for which the instrument collected data <span class="citation">(R. Smith et al. 2014)</span>. MS instruments
continuously sample and record signals, therefore a mass peak for a
single ion in one spectrum will consist of multiple intensities at
discrete <em>m/z</em> values. The process to reduce this distribution of
signals to a single representative mass peak (the centroid) is called
centroiding. This process results in much smaller file sizes, with only
little information loss. <em>xcms</em>, specifically the
<em>centWave</em> chromatographic peak detection algorithm, was designed
for centroided data, thus, prior to data analysis, profile data, such as
the example data used here, has to be centroided.</p>
<p>Below we inspect the profile data for one of the spectra extracted
above and focus on the mass peak for serine.</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Visualize the profile-mode mass peak for [M+H]+ of serine</span></span>
<span><span class="va">sps</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span>lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="va">serine_mz</span>, col <span class="op">=</span> <span class="st">"#ff000080"</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-33-1.png" alt="Profile-mode mass peak for the [M+H]+ ion of serine. The theoretical *m/z* of that ion is indicated with a dotted red line." width="960"><p class="caption">
Profile-mode mass peak for the [M+H]+ ion of serine. The theoretical
<em>m/z</em> of that ion is indicated with a dotted red line.
</p>
</div>
<p>Instead of a single peak, several mass peaks were recorded by the MS
instrument with an <em>m/z</em> very close to the theoretical
<em>m/z</em> for the <em>[M+H]+</em> ion of serine (indicated with a red
dotted line).</p>
<p>We can also visualize this information differently: the
<code><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot()</a></code> function for <code>MsExperiment</code> generates a
two-dimensional visualization of the three-dimensional LC-MS data: peaks
are drawn at their respective location in the two-dimensional
<em>m/z</em> <em>vs</em> retention time plane with their intensity being
color coded. Below we subset the data to the <em>m/z</em> - retention
time region containing signal for serine and visualize the full MS data
measured for that region in both data files.</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Visualize the full MS data for a small m/z - rt area</span></span>
<span><span class="va">mse</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/serine-profile-mode-data-1.png" alt="Profile data for Serine." width="960"><p class="caption">
Profile data for Serine.
</p>
</div>
<p>The lower panel of the plot shows all mass peaks measured by the
instrument: each point represents one mass peak with its intensity being
color coded (blue representing low, yellow high intensity). Each column
of data points represents data from the same spectrum. The upper panel
of the plot shows a chromatographic visualization of the data from the
lower panel, i.e., for each retention time (spectrum) the sum of
intensities within the <em>m/z</em> range is shown.</p>
<p>Note that, while it would be possible to create such a plot for the
full MS data of an experiment, this type of visualization works best for
small <em>m/z</em> - retention time regions.</p>
<p>Next, we <em>smooth</em> the data in each spectrum using a
Savitzky-Golay filter, which usually improves data quality by reducing
noise. Subsequently we perform the centroiding of the data based on a
simple peak-picking strategy that reports the maximum signal for each
mass peak in each spectrum. Finally, we replace the spectra in the data
(<code>MsExperiment</code>) object with the centroided spectra and
visualize the result repeating the visualization from above.</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Smooth and centroid the spectra data</span></span>
<span><span class="va">sps_cent</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">smooth</a></span><span class="op">(</span>method <span class="op">=</span> <span class="st">"SavitzkyGolay"</span>, halfWindowSize <span class="op">=</span> <span class="fl">6L</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">pickPeaks</a></span><span class="op">(</span>halfWindowSize <span class="op">=</span> <span class="fl">2L</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Replace spectra in the original data object</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">sps_cent</span></span>
<span></span>
<span><span class="co">#' Plot the centroided data for Serine</span></span>
<span><span class="va">mse</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">189</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.02</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/centroiding-1.png" alt="Centroided data for Serine." width="960"><p class="caption">
Centroided data for Serine.
</p>
</div>
<p>The impact of the centroiding is clearly visible: each signal for an
ion in a spectrum was reduced to a single data point. For more advanced
centroiding options, that can also fine-tune the <em>m/z</em> value of
the reported centroid, see the documentation of the
<code><a href="https://lgatto.github.io/MSnbase/reference/pickPeaks-method.html" class="external-link">pickPeaks()</a></code> function or the centroiding vignette of the
<em><a href="https://bioconductor.org/packages/3.19/MSnbase" class="external-link">MSnbase</a></em>
package.</p>
<p>While we could now simply proceed with the data analysis, we below
save the centroided MS data to mzML files to also illustrate how the
<em>Spectra</em> package can be used to export MS data.</p>
<p>We use the <code><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">export()</a></code> function for data export of the
centroided <code>Spectra</code> object. Parameter <code>backend</code>
allows to specify the MS data backend that should be used for the
export, and that will also define the data format (use
<code>backend = MsBackendMzR()</code> to export data in mzML format).
Parameter <code>file</code> defines, for each spectrum, the name of the
file to which its data should be exported.</p>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Export the centroided data to new mzML files.</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/hidden_aliases.html" class="external-link">export</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span>, backend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/MsBackend.html" class="external-link">MsBackendMzR</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>       file <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">dataOrigin</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We can then import the centroided data again from the newly generated
mzML files and proceed with the analysis.</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Re-import the centroided data.</span></span>
<span><span class="va">fls</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/basename.html" class="external-link">basename</a></span><span class="op">(</span><span class="va">fls</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Read the centroided data.</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/readMsExperiment.html" class="external-link">readMsExperiment</a></span><span class="op">(</span><span class="va">fls</span>, sampleData <span class="op">=</span> <span class="va">pd</span><span class="op">)</span></span></code></pre></div>
<p>Thus, with few lines of R code we performed MS data centroiding in R
which gives us possibly more, and better, control over the process and
enable also (parallel) batch processing.</p>
</div>
<div class="section level2">
<h2 id="preprocessing-of-lc-ms-data">Preprocessing of LC-MS data<a class="anchor" aria-label="anchor" href="#preprocessing-of-lc-ms-data"></a>
</h2>
<p>Preprocessing of (untargeted) LC-MS data aims at detecting and
quantifying the signal from ions generated from all molecules present in
a sample. It consists of the following 3 steps: chromatographic peak
detection, retention time alignment and correspondence (also called peak
grouping). The resulting matrix of feature abundances can then be used
as an input in downstream analyses including data normalization,
identification of features of interest and annotation of features to
metabolites. In the following sections we perform such preprocessing of
our test data set, adapting the settings for the preprocessing
algorithms to our data.</p>
<div class="section level3">
<h3 id="chromatographic-peak-detection">Chromatographic peak detection<a class="anchor" aria-label="anchor" href="#chromatographic-peak-detection"></a>
</h3>
<p>Chromatographic peak detection aims to identify peaks along the
retention time axis that represent the signal from individual compounds’
ions. This involves identifying and quantifying such signals as shown in
the sketch below.</p>
<div class="float">
<img src="images/LCMS-data-peaks.png" alt="Chromatographic peak detection"><div class="figcaption">Chromatographic peak detection</div>
</div>
<p>Such peak detection can be performed with the <em><a href="https://bioconductor.org/packages/3.19/xcms" class="external-link">xcms</a></em> package
using its <code><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks()</a></code> function. Several peak detection
algorithms are available that can be selected and configured with their
respective parameter objects:</p>
<ul>
<li>
<code>MatchedFilterParam</code> to perform peak detection as
described in the original <em>xcms</em> article <span class="citation">(C. A. Smith et al. 2006)</span>,</li>
<li>
<code>CentWaveParam</code> to perform a continuous wavelet
transformation (CWT)-based peak detection <span class="citation">(Tautenhahn, Böttcher, and Neumann 2008)</span>
and</li>
<li>
<code>MassifquantParam</code> to perform a Kalman filter-based peak
detection <span class="citation">(Conley et al. 2014)</span>.</li>
</ul>
<p>Additional peak detection algorithms for direct injection data are
also available in <em>xcms</em>, but not discussed here.</p>
<p>In our example we use the <em>centWave</em> algorithm that performs
peak detection in two steps: first it identifies <em>regions of
interest</em> in the <em>m/z</em> - retention time space and
subsequently detects peaks in these regions using a continuous wavelet
transform (see the original publication <span class="citation">(Tautenhahn, Böttcher, and Neumann 2008)</span> for
more details). The algorithm can be configured with several parameters
(see <code><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">?CentWaveParam</a></code>), with the most important being
<code>peakwidth</code> and <code>ppm</code>. <code>peakwidth</code>
defines the minimal and maximal expected width of the peak in retention
time dimension and depends thus on the setup of the employed LC-MS
system making this parameter highly data set dependent. <code>ppm</code>
on the other hand depends on the precision of the MS instrument. In this
section we describe how settings for these parameters can be empirically
determined for a data set.</p>
<p>Generally, it is strongly discouraged to blindly use the default
parameters for any of the peak detection algorithms. To illustrate this
we below extract the EIC for serine and run a <em>centWave</em>-based
peak detection on that data using <em>centWave</em>’s default
settings.</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the EIC for serine in all files</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">164</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>                           mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span>,</span>
<span>                           aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Get default centWave parameters</span></span>
<span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' "dry-run" peak detection on the EIC.</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      rt rtmin rtmax into intb maxo sn row column</span></span></code></pre>
<p>The peak matrix returned by <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks()</a></code> is empty, thus,
with the default settings <em>centWave</em> failed to identify any
chromatographic peak in the EIC for serine. The default values for the
parameters are shown below:</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Default centWave parameters</span></span>
<span><span class="va">cwp</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class:  CentWaveParam </span></span>
<span><span class="co">##  Parameters:</span></span>
<span><span class="co">##  - ppm: [1] 25</span></span>
<span><span class="co">##  - peakwidth: [1] 20 50</span></span>
<span><span class="co">##  - snthresh: [1] 10</span></span>
<span><span class="co">##  - prefilter: [1]   3 100</span></span>
<span><span class="co">##  - mzCenterFun: [1] "wMean"</span></span>
<span><span class="co">##  - integrate: [1] 1</span></span>
<span><span class="co">##  - mzdiff: [1] -0.001</span></span>
<span><span class="co">##  - fitgauss: [1] FALSE</span></span>
<span><span class="co">##  - noise: [1] 0</span></span>
<span><span class="co">##  - verboseColumns: [1] FALSE</span></span>
<span><span class="co">##  - roiList: list()</span></span>
<span><span class="co">##  - firstBaselineCheck: [1] TRUE</span></span>
<span><span class="co">##  - roiScales: numeric(0)</span></span>
<span><span class="co">##  - extendLengthMSW: [1] FALSE</span></span>
<span><span class="co">##  - verboseBetaColumns: [1] FALSE</span></span></code></pre>
<p>Particularly the setting for <code>peakwidth</code> does not fit our
data. The default for this parameter expects chromatographic peaks
between 20 and 50 seconds wide. When we plot the extracted ion
chromatogram (EIC) for serine we can however see that these values are
way too large for our UHPLC-based data set (see below).</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the EIC</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-35-1.png" alt="Extracted ion chromatogram for serine." width="960"><p class="caption">
Extracted ion chromatogram for serine.
</p>
</div>
<p>For serine, the chromatographic peak is about 5 seconds wide. We thus
adapt the <code>peakwidth</code> for the present data set and repeat the
peak detection using these settings. In general, the lower and upper
peak width should be set to include most of the expected chromatographic
peak widths. A good rule of thumb is to set it to about half to about
twice the average expected peak width. For the present data set we thus
set <code>peakwidth = c(2, 10)</code>. In addition, by setting
<code>integrate = 2</code>, we select a different peak boundary
estimation algorithm. This works particularly well for non-gaussian peak
shapes and ensures that also signal from the peak’s tail is integrated
(eventually re-run the code with the default <code>integrate = 1</code>
to compare the two approaches).</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Adapt centWave parameters</span></span>
<span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>peakwidth <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">10</span><span class="op">)</span>, integrate <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Run peak detection on the EIC</span></span>
<span><span class="va">serine_chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the data and higlight identified peak area</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/centWave-adapted-1.png" alt="EIC for Serine with detected chromatographic peak" width="960"><p class="caption">
EIC for Serine with detected chromatographic peak
</p>
</div>
<p>Acceptable values for parameter <code>peakwidth</code> can thus be
derived through visual inspection of EICs for ions known to be present
in the sample (e.g. of internal standards). Ideally, this should be done
for several compounds/ions. <em>Tip</em>: ensure that the EIC contains
also enough signal left and right of the actual chromatographic peak to
allow <em>centWave</em> to properly estimate the background noise.
Alternatively, or in addition, reduce the value for the
<code>snthresh</code> parameter for peak detection performed on
EICs.</p>
<p>With our data set-specific <code>peakwidth</code> we were able to
detect the peak for serine (highlighted in grey in the plot above). We
can now use the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks()</a></code> function to extract the
information on identified chromatographic peaks from our object.</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract identified chromatographic peaks from the EIC</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           rt   rtmin  rtmax     into     intb     maxo  sn row column</span></span>
<span><span class="co">## [1,] 181.072 178.282 187.21 70373.61 70042.87 38517.76 609   1      2</span></span></code></pre>
<p>The result is returned as a <code>matrix</code> with each row
representing one identified chromatographic peak. The retention time
ranges of the peaks are provided in columns <code>"rtmin"</code> and
<code>"rtmax"</code>, the integrated peak area (i.e., the
<em>abundance</em> of the ion) in column <code>"into"</code>, the
maximal signal of the peak in column <code>"maxo"</code> and the signal
to noise ratio in column<code>"sn"</code>. With our adapted settings we
were thus able to identify a chromatographic peak for the serine ion in
each of the two samples.</p>
<p>The second important parameter for <em>centWave</em> is
<code>ppm</code> which is used in the initial definition of the
<em>regions of interest</em> (ROI) in which the actual peak detection is
then performed. To define these ROI, the algorithm evaluates for each
mass peak in a spectrum whether a mass peak with a similar <em>m/z</em>
(and a reasonably high intensity) is also found in the subsequent
spectrum. For this, only mass peaks with a difference in their
<em>m/z</em> smaller than <code>ppm</code> in consecutive scans are
considered. To illustrate this, we plot again the full MS data for the
data subset containing signal for serine.</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Restrict to data containing signal from serine</span></span>
<span><span class="va">srn</span> <span class="op">&lt;-</span> <span class="va">mse</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterRt</a></span><span class="op">(</span>rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">179</span>, <span class="fl">186</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span>mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.04</span>, <span class="fl">106.07</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the data</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">srn</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/Serine-mz-scattering-plot-1.png" width="960"></p>
<p>We can observe some scattering of the data points around an
<em>m/z</em> of 105.05 in the lower panel of the above plot. This
scattering also decreases with increasing signal intensity (as for many
MS instruments the precision of the signal increases with the
intensity). To quantify the observed differences in <em>m/z</em> values
for the signal of serine we restrict the data to a <em>bona fide</em>
region with signal for the serine ion. Below we first subset the data to
the first file and then restrict the <em>m/z</em> range to values
between 106.045 and 106.055.</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Reduce the data set to signal of the [M+H]+ ion of serine</span></span>
<span><span class="va">srn_1</span> <span class="op">&lt;-</span> <span class="va">srn</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">filterMzRange</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.045</span>, <span class="fl">106.055</span><span class="op">)</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">spectra</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>This restricted the MS data to spectra with a single mass peak per
spectrum (presumably representing signal from the serine ion).</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="va">srn_1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span></code></pre>
<p>We next extract the <em>m/z</em> values of the peaks from the
consecutive scans and calculate the absolute difference between
them.</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Calculate the difference in m/z values between scans</span></span>
<span><span class="va">mz_diff</span> <span class="op">&lt;-</span> <span class="va">srn_1</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">mz_diff</span></span></code></pre></div>
<pre><code><span><span class="co">##                                     mz           mz           mz           mz </span></span>
<span><span class="co">## 2.904861e-03 4.357321e-03 2.904891e-03 1.179878e-04 1.452442e-03 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 1.684509e-05 0.000000e+00 0.000000e+00 7.233670e-05 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 7.624200e-07 1.452441e-03 1.452441e-03 1.358206e-03 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 1.425717e-03 0.000000e+00 1.452441e-03 1.480143e-03 0.000000e+00 0.000000e+00 </span></span>
<span><span class="co">##           mz </span></span>
<span><span class="co">## 1.493783e-03</span></span></code></pre>
<p>We can also express these differences in ppm (parts per million) of
the average <em>m/z</em> of the peaks.</p>
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Differences in m/z values expressed as ppm</span></span>
<span><span class="va">mz_diff</span> <span class="op">*</span> <span class="fl">1e6</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/unlist.html" class="external-link">unlist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">srn_1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                                     mz           mz           mz           mz </span></span>
<span><span class="co">## 27.391410160 41.087396603 27.391691523  1.112566483 13.695817196  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">##  0.158840954  0.000000000  0.000000000  0.682099561  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">##  0.007189246 13.695808133 13.695808133 12.807212147  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz           mz           mz           mz           mz           mz </span></span>
<span><span class="co">## 13.443812242  0.000000000 13.695807986 13.957023433  0.000000000  0.000000000 </span></span>
<span><span class="co">##           mz </span></span>
<span><span class="co">## 14.085643094</span></span></code></pre>
<p>The difference in <em>m/z</em> values for the serine data is thus
between 0 and 27 ppm. The maximum value could then be used for
centWave’s <code>ppm</code> parameter. Ideally, this should be evaluated
for several ions and could be set to a value that allows to capture the
full chromatographic peaks for most of the tested ions. Also, the value
for this parameter is generally much higher then the instrument
precision (for the present instrument that would have been 5 ppm). The
value should thus be set to a value that allows/accepts some
variance.</p>
<p>We can next perform the peak detection on the full data set using our
settings for the <code>ppm</code> and <code>peakwidth</code>
parameters.</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform peak detection on the full data set</span></span>
<span><span class="va">cwp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>peakwidth <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">10</span><span class="op">)</span>, ppm <span class="op">=</span> <span class="fl">30</span>, integrate <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, param <span class="op">=</span> <span class="va">cwp</span><span class="op">)</span></span></code></pre></div>
<p>The results form the chromatographic peak detection were added by the
<code><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks()</a></code> to our <code>mse</code> variable which now
is an <code>XcmsExperiment</code> object that, by extending the
<code>MsExperiment</code> class inherits all of its functionality and
properties, but in addition contains also all <em>xcms</em>
preprocessing results.</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mse</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class XcmsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span>
<span><span class="co">##  xcms results:</span></span>
<span><span class="co">##   - chromatographic peaks: 644 in MS level(s): 1</span></span></code></pre>
<p>We can extract the results from the peak detection step (as above)
with the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks()</a></code> function. The optional parameters
<code>rt</code> and <code>mz</code> would allow to extract peak
detection results for a specified <em>m/z</em> - retention time region.
In our example we extract all chromatographic peaks between an
<em>m/z</em> range from 106 to 108 and a retention time from 150 to
190.</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Access the peak detection results from a specific m/z - rt area</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106</span>, <span class="fl">108</span><span class="op">)</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">150</span>, <span class="fl">190</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##             mz    mzmin    mzmax      rt   rtmin   rtmax       into       intb</span></span>
<span><span class="co">## CP133 106.0625 106.0606 106.0636 173.264 171.869 174.380   516.3588   509.4463</span></span>
<span><span class="co">## CP146 107.0653 107.0652 107.0653 173.543 171.032 179.682 11318.2801 11309.9091</span></span>
<span><span class="co">## CP157 107.0532 107.0522 107.0537 181.356 179.682 183.309  2905.1158  2901.7678</span></span>
<span><span class="co">## CP167 106.0506 106.0505 106.0506 181.356 178.845 187.773 74181.7823 73905.2115</span></span>
<span><span class="co">## CP469 106.0633 106.0609 106.0652 172.701 170.748 174.654   559.5491   553.7921</span></span>
<span><span class="co">## CP477 107.0656 107.0655 107.0657 172.980 169.632 178.003 11372.6845 11166.3372</span></span>
<span><span class="co">## CP492 107.0538 107.0510 107.0540 181.072 178.840 183.304  3155.0100  3149.2053</span></span>
<span><span class="co">## CP512 106.0496 106.0494 106.0508 181.072 178.282 187.210 70373.6099 70109.3562</span></span>
<span><span class="co">##             maxo   sn sample</span></span>
<span><span class="co">## CP133   426.6084   35      1</span></span>
<span><span class="co">## CP146  4936.6783 4936      1</span></span>
<span><span class="co">## CP157  1628.9510  186      1</span></span>
<span><span class="co">## CP167 37664.9371  685      1</span></span>
<span><span class="co">## CP469   381.6084   54      2</span></span>
<span><span class="co">## CP477  4569.1399   79      2</span></span>
<span><span class="co">## CP492  2297.7972  230      2</span></span>
<span><span class="co">## CP512 38517.7622  830      2</span></span></code></pre>
<p>Again, each row in this matrix contains one identified
chromatographic peak with columns <code>"mz"</code>,
<code>"mzmin"</code>, <code>"mzmax"</code>, <code>"rt"</code>,
<code>"rtmin"</code> and <code>"rtmax"</code> defining it’s
<em>position</em> (and size) in the <em>m/z</em> - rt plane and
<code>"into"</code> and <code>"maxo"</code> its (integrated and maximum)
intensity. Column <code>"sample"</code> indicates in which of our
samples (data files) the peak was identified.</p>
<p>The chromatographic peak table above contains pairs of peaks with
similar retention times and a difference in <em>m/z</em> values of about
one. Together with the observed differences in intensities, this could
indicate that one of the peaks represents the carbon 13 isotope and one
the monoisotopic compound. This is frequently observed in untargeted
metabolomics.</p>
<p>As a general overview of the peak detection results it can also be
helpful to determine (and eventually) plot the number of identified
chromatographic peaks per sample. Below we count the number of peaks per
sample.</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Count peaks per file</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span>, <span class="st">"sample"</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## 323 321</span></span></code></pre>
<p>About the same number of peaks was identified, which is to be
expected since both files contain measurements from the same sample (the
QC pool).</p>
<p>As an additional visual quality assessment, we can also plot the
location of the identified chromatographic peaks in the <em>m/z</em> -
retention time space for each data file using the
<code><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks()</a></code> function.</p>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the location of peaks in the m/z - rt plane</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/plotChromPeaks-1.png" alt="Location of the identified chromatographic peaks in the *m/z* - rt space." width="960"><p class="caption">
Location of the identified chromatographic peaks in the <em>m/z</em> -
rt space.
</p>
</div>
<p>Again, similar pattern are expected to be present for the two data
files.</p>
<p>After chromatographic peak detection it is generally a good idea to
visually inspect individual chromatographic peaks and evaluate the
performance of the peak detection step. This could be done by plotting
EICs of known compounds/ions in the data or by randomly selecting
chromatographic peaks. <em>m/z</em> - retention time regions for random
peaks could be defined using the example code below.</p>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Select 4 random peaks</span></span>
<span><span class="va">npeaks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="va">npeaks</span><span class="op">)</span>, <span class="fl">4</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract m/z-rt regions for 4 random peaks</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span><span class="va">idx</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"rtmin"</span>, <span class="st">"rtmax"</span>, <span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' Expand the rt range by 10 seconds on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">10</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">10</span></span>
<span><span class="co">#' Expand the m/z range by 0.005 on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">0.005</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"mzmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">0.005</span></span>
<span></span>
<span><span class="co">#' Display the randomly selected regions</span></span>
<span><span class="va">mz_rt</span></span></code></pre></div>
<pre><code><span><span class="co">##         rtmin   rtmax    mzmin    mzmax</span></span>
<span><span class="co">## CP110 141.781 167.919 118.0812 118.0915</span></span>
<span><span class="co">## CP158 170.798 193.309 108.0477 108.0606</span></span>
<span><span class="co">## CP064  64.217  88.960 117.0796 117.0912</span></span>
<span><span class="co">## CP483 167.444 191.072 129.6296 129.6445</span></span></code></pre>
<p>For our example we however manually define <em>m/z</em> - retention
time regions (similarly as it could be done for known compounds). Below
we extract the EICs for these regions with the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> function and subsequently plot them.
Identified chromatographic peaks within the plotted regions will by
default be highlighted in a semitransparent grey color.</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define m/z - retention time regions for EICs</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">106.045</span>, <span class="fl">106.055</span>, <span class="fl">165</span>, <span class="fl">195</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">132.096</span>, <span class="fl">132.107</span>, <span class="fl">135</span>, <span class="fl">160</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125.981</span>, <span class="fl">125.991</span>, <span class="fl">195</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">105.468</span>, <span class="fl">105.478</span>, <span class="fl">190</span>, <span class="fl">215</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract the EICs</span></span>
<span><span class="va">eics</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span>, <span class="op">)</span></span>
<span><span class="co">#' Plot the EICs</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">eics</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-44-1.png" width="960"></p>
<p>While the peak detection worked nicely for the signals in the upper
row, it failed to define chromatographic peaks containing the full
signal in the lower row. In both cases, the signal was split into
separate chromatographic peaks within the same sample. This is a common
problem with <em>centWave</em> on such noisy and broad signals. We could
either try to adapt the <em>centWave</em> settings and repeat the
chromatographic peak detection or use the
<code><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks()</a></code> function that allows to post-process
peak detection results and fix such problems (see also the documentation
of the <code><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks()</a></code> function for all possible
refinement options).</p>
<p>To fuse the wrongly split peaks in the second row, we use the
<code>MergeNeighboringPeaksParam</code> algorithm that merges
chromatographic peaks that are overlapping on the <em>m/z</em> and
retention time dimension for which the signal between them is higher
than a certain value. We specify <code>expandRt = 4</code> to expand the
retention time width of each peak by 4 seconds on each side and set
<code>minProp = 0.75</code>. All chromatographic peaks with a distance
tail-to-head in retention time dimension that is less than
<code>2 * expandRt</code> and for which the intensity between them is
higher than 75% of the lower (apex) intensity of the two peaks are thus
merged. We below apply these settings on the EICs and evaluate the
result of this post-processing.</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define the setting for the peak refinement</span></span>
<span><span class="va">mpp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">MergeNeighboringPeaksParam</a></span><span class="op">(</span>expandRt <span class="op">=</span> <span class="fl">4</span>, minProp <span class="op">=</span> <span class="fl">0.75</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Perform the peak refinement on the EICs</span></span>
<span><span class="va">eics</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks</a></span><span class="op">(</span><span class="va">eics</span>, param <span class="op">=</span> <span class="va">mpp</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the result</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">eics</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-45-1.png" width="960"></p>
<p>The peak post-processing was able to merge the signal for the
neighboring peaks in the lower panel, while keeping the peaks for the
different isomers present in the top right plot separate. We next apply
this same peak refinement on the full data set.</p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform peak refinement on the full data set</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, param <span class="op">=</span> <span class="va">mpp</span><span class="op">)</span></span></code></pre></div>
<p>The number of peaks per sample after peak refinement is shown
below.</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span>, <span class="st">"sample"</span><span class="op">]</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## 297 292</span></span></code></pre>
<p>Also, <code><a href="https://rdrr.io/pkg/xcms/man/refineChromPeaks.html" class="external-link">refineChromPeaks()</a></code> adds information on the peak
refinement to the object’s <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeakData()</a></code> data frame which
provides additional metadata information for each chromatographic
peak:</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeakData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 589 rows and 3 columns</span></span>
<span><span class="co">##        ms_level is_filled    merged</span></span>
<span><span class="co">##       &lt;integer&gt; &lt;logical&gt; &lt;logical&gt;</span></span>
<span><span class="co">## CP001         1     FALSE     FALSE</span></span>
<span><span class="co">## CP002         1     FALSE     FALSE</span></span>
<span><span class="co">## CP003         1     FALSE     FALSE</span></span>
<span><span class="co">## CP004         1     FALSE     FALSE</span></span>
<span><span class="co">## CP005         1     FALSE     FALSE</span></span>
<span><span class="co">## ...         ...       ...       ...</span></span>
<span><span class="co">## CP669         1     FALSE      TRUE</span></span>
<span><span class="co">## CP670         1     FALSE      TRUE</span></span>
<span><span class="co">## CP671         1     FALSE      TRUE</span></span>
<span><span class="co">## CP672         1     FALSE      TRUE</span></span>
<span><span class="co">## CP673         1     FALSE      TRUE</span></span></code></pre>
<p>And the number of merged peaks is thus:</p>
<div class="sourceCode" id="cb105"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeakData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">merged</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 29</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="retention-time-alignment">Retention time alignment<a class="anchor" aria-label="anchor" href="#retention-time-alignment"></a>
</h3>
<p>While chromatography helps to better discriminate between analytes it
is also affected by variances that lead to shifts in retention times
between measurement runs. Such differences can usually already be seen
in a base peak chromatogram or total ion chromatogram. We thus extract
and plot below the BPC for our data set. In the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> call, we set the optional parameter
<code>chromPeaks = "none"</code> to avoid the additional extraction of
all identified chromatographic peaks.</p>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract base peak chromatograms</span></span>
<span><span class="va">bpc_raw</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span>, chromPeaks <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc_raw</span>, peakType <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/alignment-bpc-raw-1.png" alt="BPC of all files." width="960"><p class="caption">
BPC of all files.
</p>
</div>
<p>Both samples were measured with the same setup in the same
measurement run, but still small drifts of the signal are visible. These
were also already visible in the EIC for serine, that we plot again
below.</p>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot EIC of serine</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span>, xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">175</span>, <span class="fl">190</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-50-1.png" width="960"></p>
<p>For the serine signal, there seems to be a retention time shift of
about 1 second between the two samples. The alignment step aims to
minimize these retention time differences between all samples within an
experiment (see below for an illustration).</p>
<div class="float">
<img src="images/alignment.png" alt="Alignment"><div class="figcaption">Alignment</div>
</div>
<p>In <em>xcms</em>, the alignment can be performed with the
<code><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtime()</a></code> function and one of the available alignment
algorithms, that can be selected, and configured, with the respective
parameter objects:</p>
<ul>
<li><p><code>PeakGroupsParam</code>: the <em>peakGroups</em> <span class="citation">(C. A. Smith et al. 2006)</span> method aligns samples
based on the retention times of a set of so called <em>anchor peaks</em>
(or housekeeping peaks) in the different samples of an experiment. These
peaks are supposed to represent signal from ions expected to be present
in most of the samples of an experiment and the method aligns these
samples by minimizing the between-sample retention time differences
observed for these peaks.</p></li>
<li><p><code>ObiwarpParam</code>: <em>obiwarp</em> <span class="citation">(Prince and Marcotte 2006)</span> performs retention
time adjustment based on the full <em>m/z</em> - retention time data.
See the documentation for <code>ObiwarpParam</code> or the <em>xcms</em>
<a href="https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html" class="external-link">vignette</a>
for more information.</p></li>
</ul>
<p>While, by default, retention time shifts are estimated on the full
data set, it would also be possible to estimate them on a subset of
samples, such as repeatedly measured QC samples (e.g. sample pools) and
adjust the full experiment based on these. See the alignment section in
the <em>xcms</em> <a href="https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html" class="external-link">vignette</a>
for more information on this subset-based alignment. Note that such a
subset-based alignment requires the samples to be organized in the order
in which they were measured. Also, recently, functionality was added to
<em>xcms</em> to perform the alignment on pre-selected signals
(e.g. retention times of internal standards) or to align a data set
against an external reference.</p>
<p>For our example we use the <em>peakGroups</em> method that, as
mentioned above, aligns samples based on the retention times of
<em>anchor peaks</em>. To define these, we need to first run an initial
correspondence analysis and group chromatographic peaks across samples.
Below we use the <em>peakDensity</em> method for correspondence (details
about this method and explanations on the choices of its parameters are
provided in the next section). In brief, parameter
<code>sampleGroups</code> defines to which sample group of the
experiment individual samples belong to, and parameter
<code>minFraction</code> specifies the proportion of samples (of one of
the sample groups defined in <code>sampleGroups</code>) in which a
chromatographic peak needs to be detected to group them into an LC-MS
feature. Chromatographic peaks will be grouped to features if their
difference in <em>m/z</em> and retention times is below the defined
thresholds and if in at least <code>minFraction * 100</code> percent of
samples of at least one sample group a chromatographic peak was
detected. For our example we use the sample group definition in the
<code>sampleData</code> of our <code>mse</code> variable and set
<code>minFraction = 1</code> requiring thus a chromatographic peak to be
identified in all (100%) of available samples to define a feature.
Generally, if correspondence is performed on more heterogeneous samples,
<code>minFraction</code> values between 0.6 and 0.8 could be used
instead. Since the aim of this initial correspondence is to define some
(presumably well separated) groups of chromatographic peaks across the
samples, its settings does not need to be fully optimized.</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define the settings for the initial peak grouping - details for</span></span>
<span><span class="co">#' choices in the next section.</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span>,</span>
<span>                        minFraction <span class="op">=</span> <span class="fl">1</span>, binSize <span class="op">=</span> <span class="fl">0.01</span>, ppm <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">groupChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<p>This step now grouped chromatographic peaks across samples and
defined so called LC-MS features (or simply features). We can thus now
run the alignment using the <em>peakGroups</em> algorithm that aligns
the data by minimizing differences in retention times of <em>anchor
peaks</em> (i.e. selected features with chromatographic peaks detected
in most samples). The main parameter to define these anchor peaks is
<code>minFraction</code>. Similar to the definition above,
<code>minFraction</code> refers to the proportion of samples in which a
chromatographic peak needs to be present, only, here we don’t consider
the different sample groups, but the whole data set. By setting
<code>minFraction = 1</code> we base the alignment on features with
peaks identified in 100% of the samples in the data set. For alignments
that are based on repeatedly measured samples (e.g. also for
subset-based alignment on sample pools) values <code>&gt;= 0.9</code>
can be used. Otherwise, values between 0.7 and 0.9 might be more
advisable to ensure that a reasonable set of features are selected.</p>
<p>To evaluate anchor peaks that would be selected based on the defined
settings, we can also use the <code><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtimePeakGroups()</a></code>
method:</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get the anchor peaks that would be selected</span></span>
<span><span class="va">pgm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtimePeakGroups</a></span><span class="op">(</span><span class="va">mse</span>, <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">PeakGroupsParam</a></span><span class="op">(</span>minFraction <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pgm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## FT136                           22.601                           24.270</span></span>
<span><span class="co">## FT163                           25.391                           25.665</span></span>
<span><span class="co">## FT030                           25.670                           25.665</span></span>
<span><span class="co">## FT212                           26.507                           26.502</span></span>
<span><span class="co">## FT056                           26.786                           27.060</span></span>
<span><span class="co">## FT162                           28.739                           28.734</span></span></code></pre>
<p>Ideally, if possible, the anchor peaks should span most of the
retention time range to allow alignment of the full LC runs. Below
evaluate the distribution of retention times of the anchor peaks in the
first sample.</p>
<div class="sourceCode" id="cb112"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Evaluate distribution of anchor peaks' rt in the first sample</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="va">pgm</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      0%     25%     50%     75%    100% </span></span>
<span><span class="co">##  22.601 155.408 180.240 194.190 259.478</span></span></code></pre>
<p>Anchor peaks cover thus most of the retention time range.</p>
<p>After having identified the features that should be used as anchor
peaks (based on the <code>minFraction</code> parameter) the algorithm
minimizes the observed between-sample retention time differences for
these. Parameter <code>span</code> defines the degree of smoothing of
the loess function that is used to allow different regions along the
retention time axis to be adjusted by a different factor. A value close
to 0 will most likely cause overfitting, while a value of 1 would cause
all retention times of a sample to be shifted by a constant value.
Values between 0.4 and 0.6 seem to be reasonable for most
experiments.</p>
<div class="sourceCode" id="cb114"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define settings for the alignment</span></span>
<span><span class="va">pgp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">PeakGroupsParam</a></span><span class="op">(</span>minFraction <span class="op">=</span> <span class="fl">1</span>, span <span class="op">=</span> <span class="fl">0.6</span><span class="op">)</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtime</a></span><span class="op">(</span><span class="va">mse</span>, param <span class="op">=</span> <span class="va">pgp</span><span class="op">)</span></span></code></pre></div>
<p>After an alignment it is suggested to evaluate its results using the
<code><a href="https://rdrr.io/pkg/xcms/man/plotAdjustedRtime.html" class="external-link">plotAdjustedRtime()</a></code> function. This function plots the
differences between adjusted and raw retention times for each sample on
the y-axis along the adjusted retention times on the x-axis (each line
hence representing the retention time adjustment of one sample/file).
Points indicate the position of individual hook peaks along the
retention time axis, with a dotted line connecting the peaks belonging
to the same feature (for which the algorithm minimized the difference in
retention times).</p>
<div class="sourceCode" id="cb115"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the difference between raw and adjusted retention times</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotAdjustedRtime.html" class="external-link">plotAdjustedRtime</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/alignment-result-1.png" alt="Alignment results: differences between raw and adjusted retention times for each sample." width="960"><p class="caption">
Alignment results: differences between raw and adjusted retention times
for each sample.
</p>
</div>
<p>As a rule of thumb, the differences between raw and adjusted
retention times in the plot above should be reasonable. Also, if
possible, anchor peaks (indicated with black points in the plot above)
should be present along a wide span of the retention time range, to
avoid the need for extrapolation (which usually results in a too strong
adjustment). For our example, the largest adjustments are between 1 and
2 seconds, which is reasonable given that the two samples were measured
during the same measurement run. Also, features used for the alignment
(i.e. anchor peaks) are spread across the full retention time range.</p>
<p>To evaluate the impact of the alignment we next also plot the BPC
before and after alignment. In a similar way as before, we set
<code>chromPeaks = "none"</code> in the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> call
to tell the function to <strong>not</strong> include any identified
chromatographic peaks in the returned chromatographic data.</p>
<div class="sourceCode" id="cb116"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the raw base peak chromatogram</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">bpc_raw</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the BPC after alignment</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span>, chromPeaks <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/bpc-raw-adjusted-1.png" alt="BPC before (top) and after (bottom) alignment." width="960"><p class="caption">
BPC before (top) and after (bottom) alignment.
</p>
</div>
<p>The base peak chromatograms are nicely aligned after retention time
adjustment. In addition to this general assessment, the alignment result
should also be evaluated for selected compounds (or internal standards).
We thus below plot the EIC for the <em>[M+H]+</em> ion for serine before
and after alignment.</p>
<div class="sourceCode" id="cb117"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">4.5</span>, <span class="fl">1</span>, <span class="fl">0.5</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' EIC before alignment</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#' EIC after alignment</span></span>
<span><span class="va">serine_chr_adj</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">164</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>                               mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.01</span>, <span class="fl">0.01</span><span class="op">)</span>,</span>
<span>                               aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_chr_adj</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/serine-xic-adjusted-1.png" alt="EIC for Serine before (left) and after (right) alignment" width="960"><p class="caption">
EIC for Serine before (left) and after (right) alignment
</p>
</div>
<p>The serine peaks are also nicely aligned after retention time
adjustment. Again, it is advisable to evaluate the impact of the
alignment on several EICs, ideally also spread along the retention time
range.</p>
<p>Note that <code><a href="https://rdrr.io/pkg/xcms/man/adjustRtime.html" class="external-link">adjustRtime()</a></code>, in addition to the retention
times of the individual (MS1) spectra of all files, adjusted also the
retention times of the identified chromatographic peaks, as well as
retention times of possibly present MS2 spectra. The adjusted retention
times are stored as a new spectra variable <code>"rtime_adjusted"</code>
in the result object’s <code>Spectra</code>. The <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime()</a></code>
function on the result object will by default return these (adjusted)
values.</p>
</div>
<div class="section level3">
<h3 id="correspondence">Correspondence<a class="anchor" aria-label="anchor" href="#correspondence"></a>
</h3>
<p>The final step of the LC-MS preprocessing with <em>xcms</em> is the
correspondence analysis, in which chromatographic peaks from the same
types of ions (compounds) are grouped across samples to form the so
called <em>LC-MS features</em>.</p>
<div class="float">
<img src="images/correspondence2_03.png" alt="Correspondence"><div class="figcaption">Correspondence</div>
</div>
<p>In <em>xcms</em>, correspondence is performed using the
<code><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">groupChromPeaks()</a></code> function. The correspondence algorithm
can be selected and configured with the respective parameter
objects:</p>
<ul>
<li><p><code>NearestPeaksParam</code>: performs peak grouping based on
the proximity of chromatographic peaks from different samples in the
<em>m/z</em> - retention time space, similar to the original
correspondence method of <em>mzMine</em> <span class="citation">(Katajamaa, Miettinen, and Oresic
2006)</span>.</p></li>
<li><p><code>PeakDensityParam</code>: performs a simple and fast
correspondence analysis based on the density of chromatographic peaks
(from different samples) along the retention time axis within slices of
small <em>m/z</em> ranges <span class="citation">(C. A. Smith et al.
2006)</span>.</p></li>
</ul>
<p>Both methods group chromatographic peaks from different samples with
similar <em>m/z</em> and retention times into features. For our example
we use the <em>peak density</em> method. This algorithm iterates through
small slices along the <em>m/z</em> dimension and groups, within each
slice, chromatographic peaks with similar retention times. The grouping
depends on the distribution (density) of chromatographic peaks from all
samples along the retention time axis. Peaks with similar retention time
will result in a higher peak density at a certain retention time and are
thus grouped together. The grouping depends on the <em>smoothness</em>
of the density curve and can be configured with parameter
<code>bw</code>.</p>
<p>An illustration showing how chromatographic peaks within a small
<em>m/z</em> range are grouped by the <em>peakDensity</em> method is
shown in the sketch below.</p>
<div class="float">
<img src="images/correspondence2_density.png" alt="peak density"><div class="figcaption">peak density</div>
</div>
<p>Settings for this algorithm can be best tested and optimized using
the <code><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity()</a></code> function on extracted
chromatograms. We below extract a chromatogram for a <em>m/z</em> slice
containing signal for a <em>[M+H]+</em> ion of serine and evaluate the
result from a <em>peakDensity</em> correspondence analysis using that
function. We use the default settings (<code>bw = 30</code>) and use
again the sample group assignment defined in
<code><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData()</a></code>.</p>
<div class="sourceCode" id="cb118"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract a chromatogram for a m/z range containing serine</span></span>
<span><span class="va">chr_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">serine_mz</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Default parameters for peak density; bw = 30</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">30</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Test these settings on the extracted slice</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_1</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/unnamed-chunk-54-1.png" width="960"></p>
<p>The upper panel in the plot shows the chromatographic data for the
selected <em>m/z</em> slice with the identified peaks highlighted in
grey. The lower panel plots the retention time of identified
chromatographic peaks on the x-axis against the index of the sample in
which the peak was identified. Each chromatographic peak is thus
represented with a point in that plot (x-axis value being its retention
time and the y-axis value the sample in which it was identified). In our
example there was one chromatographic peak identified in each sample at
a retention time of about 180 seconds and these two peaks are thus
shown. The black solid line represents the density estimation
(i.e. distribution or retention times) of the identified chromatographic
peaks along the retention time axis. The smoothness of this curve (which
is created with the base R <code><a href="https://rdrr.io/r/stats/density.html" class="external-link">density()</a></code> function) is
configured with the parameter <code>bw</code>. The <em>peakDensity</em>
algorithm assigns all chromatographic peaks within the same
<em>peak</em> of this density estimation curve to the same feature.
Chromatographic peaks assigned to the same feature are indicated with a
grey rectangle in the lower panel of the plot. In the present example,
because retention times of the two chromatographic peaks are very
similar, this rectangle is very narrow and looks thus more like a
vertical line. Based on this result, the default settings
(<code>bw = 30</code>) seemed to correctly define features. It is
however advisable to evaluate settings on multiple slices, ideally with
signal from more than one compound being present. Such slices could be
identified in e.g. a plot created with the <code><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks()</a></code>
function (see example in the chromatographic peak detection
section).</p>
<p>In our example we extract a chromatogram for an <em>m/z</em> slice
containing signal for known isomers betaine and valine ([M+H]+
<em>m/z</em> 118.08625).</p>
<div class="sourceCode" id="cb119"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the chromatogram for an m/z slice containing betaine and valine</span></span>
<span><span class="va">mzr</span> <span class="op">&lt;-</span> <span class="fl">118.08625</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span></span>
<span><span class="va">chr_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">mzr</span>, aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Correspondence in that slice using default settings</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-bw-1.png" alt="Correspondence analysis with default settings on an *m/z* slice containing signal from multiple ions." width="960"><p class="caption">
Correspondence analysis with default settings on an <em>m/z</em> slice
containing signal from multiple ions.
</p>
</div>
<p>This slice contains signal from several ions resulting in multiple
chromatographic peaks along the retention time axis. With the default
settings, in particular with <code>bw = 30</code>, all these peaks were
however assigned to the same feature (indicated with the grey
rectangle). Signal from different ions would thus be treated as a single
entity. We repeat the analysis below with a strongly reduced value for
parameter <code>bw</code>.</p>
<div class="sourceCode" id="cb120"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Reducing the bandwidth</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-bw-fix-1.png" alt="Correspondence analysis with reduced bw setting on a *m/z* slice containing signal from multiple ions." width="960"><p class="caption">
Correspondence analysis with reduced bw setting on a <em>m/z</em> slice
containing signal from multiple ions.
</p>
</div>
<p>Setting <code>bw = 1.8</code> strongly reduced the smoothness of the
density curve resulting in a higher number of density <em>peaks</em> and
hence a nice grouping of (aligned) chromatographic peaks into separate
features. Note that the height of the peaks of the density curve are not
relevant for the grouping.</p>
<p>By having defined a <code>bw</code> appropriate for our data set, we
proceed and perform the correspondence analysis on the full data set.
Other parameters of <em>peakDensity</em> are <code>binSize</code> and
<code>minFraction</code>. The <code>minFraction</code> parameter
(already discussed above) defines the proportion of samples within at
least one sample group in which chromatographic peaks need to be
identified in order to define a feature.</p>
<p><code>binSize</code> defines the <em>m/z</em> widths of the slices
along the <em>m/z</em> dimension the algorithm will iterate through.
This parameter thus translates into the maximal acceptable difference in
<em>m/z</em> values for peaks to be considered representing signal from
the same ion. The value depends on the resolution (and noise) of the
instrument, and should not be set to a too small value, but also not too
large (to avoid peaks from different ions, with slightly different
<em>m/z</em> but similar retention times, to be grouped into the same
feature). Note that by default a <strong>constant</strong> <em>m/z</em>
width is used, which might however not reflect the
<em>m/z</em>-dependent measurement error of some instruments (such as
TOF instruments). To address this, the parameter <code>ppm</code> was
recently added that allows to generate <em>m/z</em>-dependent bin sizes:
the width of the <em>m/z</em> slices increases by <code>ppm</code> of
the bin’s <em>m/z</em> along the <em>m/z</em> axis.</p>
<p>For our correspondence analysis we set the maximal acceptable
difference of chrom peaks’ <em>m/z</em> values with
<code>binSize = 0.01</code> and <code>ppm = 10</code>, hence grouping
chromatographic peaks with similar retention time and with a difference
of their <em>m/z</em> values that is smaller than 0.01 + 10 ppm of their
<em>m/z</em> values. By setting <code>minFraction = 0.4</code> we in
addition require for a feature that a chromatographic peak was detected
in <code>&gt;=</code> 40% of samples of at least one sample group.</p>
<div class="sourceCode" id="cb121"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Set in addition parameter ppm to a value of 10</span></span>
<span><span class="va">pdp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">PeakDensityParam</a></span><span class="op">(</span>sampleGroups <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/MsExperiment/man/MsExperiment.html" class="external-link">sampleData</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">group</span>, bw <span class="op">=</span> <span class="fl">1.8</span>,</span>
<span>                        minFraction <span class="op">=</span> <span class="fl">0.4</span>, binSize <span class="op">=</span> <span class="fl">0.01</span>, ppm <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Perform the correspondence analysis on the full data</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/groupChromPeaks.html" class="external-link">groupChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, param <span class="op">=</span> <span class="va">pdp</span><span class="op">)</span></span>
<span><span class="va">mse</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class XcmsExperiment </span></span>
<span><span class="co">##  Spectra: MS1 (1862) </span></span>
<span><span class="co">##  Experiment data: 2 sample(s)</span></span>
<span><span class="co">##  Sample data links:</span></span>
<span><span class="co">##   - spectra: 2 sample(s) to 1862 element(s).</span></span>
<span><span class="co">##  xcms results:</span></span>
<span><span class="co">##   - chromatographic peaks: 589 in MS level(s): 1 </span></span>
<span><span class="co">##   - adjusted retention times: mean absolute difference 0.345 seconds</span></span>
<span><span class="co">##   - correspondence results: 357 features in MS level(s): 1</span></span></code></pre>
<p>The present data set is restricted to a quite narrow <em>m/z</em>
range, thus, the parameter <code>ppm</code> does not have a strong
impact. For <em>real</em> data sets, this parameter results in an
<em>m/z</em>-dependent <em>m/z</em> width of detected features. For
<code>binSize = 0.01</code> and <code>ppm = 10</code> and a data set
with an <em>m/z</em> range from 0 to 1000, the width of the <em>m/z</em>
bins would linearly increase, along the <em>m/z</em> axis, from an
initial size of 0.01 up to a value of 0.02 (the static size of 0.01 plus
10 ppm of the maximal <em>m/z</em> of 1000 which results in the maximal
bin size of 0.02). See also <a href="https://github.com/sneumann/xcms/issues/711#issuecomment-1893389759" class="external-link"><em>this
github issue</em></a> for an example and discussion.</p>
<p>Over 300 features were identified in our example data set. Again, it
is suggested to evaluate the results on selected compounds/ions. We
therefore extract below the chromatogram for the <em>m/z</em> range
containing signals for betaine and valine. After a correspondence
analysis also feature definitions are extracted by the
<code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram()</a></code> call and we can show the results from the
actual correspondence analysis (based also on the settings that were
used) by setting <code>simulate = FALSE</code> in the
<code><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity()</a></code> call.</p>
<div class="sourceCode" id="cb123"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chromatogram including signal for betaine and valine</span></span>
<span><span class="va">chr_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="fl">118.08625</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span>,</span>
<span>                      aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="co">#' Setting simulate = FALSE to show the actual correspondence results</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_2</span>, simulate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-evaluate-1.png" alt="Result of correspondence on an *m/z* slice containing the isomers valine and betaine." width="960"><p class="caption">
Result of correspondence on an <em>m/z</em> slice containing the isomers
valine and betaine.
</p>
</div>
<p>We evaluate the results also on a different slice containing signal
for ions from isomers leucine and isoleucine ([M+H]+ <em>m/z</em>
132.10191).</p>
<div class="sourceCode" id="cb124"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chromatogram with signal for isomers leucine and isoleucine</span></span>
<span><span class="va">chr_3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="fl">132.10191</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.005</span>, <span class="fl">0.005</span><span class="op">)</span>,</span>
<span>                      aggregationFun <span class="op">=</span> <span class="st">"max"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeakDensity.html" class="external-link">plotChromPeakDensity</a></span><span class="op">(</span><span class="va">chr_3</span>, simulate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/correspondence-evaluate-2-1.png" alt="Result of correspondence on an *m/z* slice containing the isomers leucine and isoleucine." width="960"><p class="caption">
Result of correspondence on an <em>m/z</em> slice containing the isomers
leucine and isoleucine.
</p>
</div>
<p>Despite being very close, chromatographic peaks of the two isomers
were successfully grouped into separate features. Even the partially
overlapping signal from a third ion eluting at about the same time and
hence partially overlapping with the peak at a retention time of 152
seconds was grouped into its own, separate, feature. It is at the
discretion of the data analysts to define how fine or coarse the feature
grouping should be. Especially for larger experiments, with more samples
and also larger variation in retention time it might not always be
possible to completely separate all closely eluting ions from each other
and sometimes it might be acceptable to group them into a single feature
(keeping in mind that this feature would then however potentially
represent signal from multiple different ions/compounds).</p>
<p>Similar to the peak detection and alignment results, also the results
from the correspondence analysis were added to the
<code>XcmsExperiment</code> object. These can be extracted with the
<code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions()</a></code> function, that extracts the
<em>definition</em> of the LC-MS features and the
<code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues()</a></code> function that extracts the numerical matrix
with the feature abundances (in all samples). Below we extract the
definition of the features and display the first 6 rows.</p>
<div class="sourceCode" id="cb125"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Definition of the features</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mzmed    mzmin    mzmax     rtmed     rtmin     rtmax npeaks POOL</span></span>
<span><span class="co">## FT001 105.0418 105.0417 105.0418 167.68958 167.50191 167.87725      2    2</span></span>
<span><span class="co">## FT002 105.0415 105.0415 105.0415 157.72336 157.72336 157.72336      1    1</span></span>
<span><span class="co">## FT003 105.0697 105.0691 105.0703  31.80810  31.67412  31.94208      2    2</span></span>
<span><span class="co">## FT004 105.1103 105.1100 105.1105  63.75036  63.45657  64.04414      2    2</span></span>
<span><span class="co">## FT005 105.4734 105.4732 105.4736 201.57632 201.37059 201.78204      2    2</span></span>
<span><span class="co">## FT006 105.7166 105.7160 105.7172 181.21537 181.08482 181.34592      2    2</span></span>
<span><span class="co">##        peakidx ms_level</span></span>
<span><span class="co">## FT001 115, 393        1</span></span>
<span><span class="co">## FT002      114        1</span></span>
<span><span class="co">## FT003  21, 317        1</span></span>
<span><span class="co">## FT004  49, 348        1</span></span>
<span><span class="co">## FT005 261, 573        1</span></span>
<span><span class="co">## FT006 138, 440        1</span></span></code></pre>
<p>Each row defines one feature and provides information on it’s
<em>m/z</em> (column <code>"mzmed"</code>) and retention time (column
<code>"rtmed"</code>). The <em>-min</em> and <em>-max</em> columns list
the minimum and maximum rt or <em>m/z</em> value of the chromatographic
peaks assigned to the feature. Additional columns list the number of
chromatographic peaks that were assigned to the feature and the MS
level. Column <code>"peakidx"</code> provides the indices of the
chromatographic peaks in the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks()</a></code> matrix that were
assigned to the feature - but generally users will not need or extract
that information.</p>
<p>The feature abundance matrix, which is the final result of the
<em>xcms</em> preprocessing, can be extracted with the
<code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues()</a></code> function. By default, with parameter
<code>method = "maxint"</code>, it returns for each feature the
integrated peak signal of the chromatographic peak with the highest
signal per sample. Note that this has only an effect for features with
more than one chromatographic peak per sample (i.e., if multiple
chromatographic peaks in the <strong>same</strong> sample were grouped
into the feature because of their closeness in retention time and
<em>m/z</em> value). Setting <code>method = "sum"</code> would in
contrast sum the abundances of such chromatographic peaks. Note that
<code>method = "sum"</code> is only suggested if, like in our example,
neighboring and overlapping peaks per sample were merged to avoid an
overestimation of the feature abundance. Below we extract the feature
abundances and show the first 6 rows.</p>
<div class="sourceCode" id="cb127"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get abundances for the first 6 features</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span>, method <span class="op">=</span> <span class="st">"sum"</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## FT001                        3202.7445                        2285.2830</span></span>
<span><span class="co">## FT002                        3605.3915                               NA</span></span>
<span><span class="co">## FT003                         744.8752                        1057.4312</span></span>
<span><span class="co">## FT004                       18126.4603                       19369.4039</span></span>
<span><span class="co">## FT005                       23243.6129                       31960.3709</span></span>
<span><span class="co">## FT006                         671.5842                         617.7545</span></span></code></pre>
<p>We could now use this feature matrix for any downstream analysis.
Such feature matrix might however, as can also be seen in the second row
above (feature <em>FT002</em>), contain missing values. These represent
features for which no chromatographic peak was identified in one (or
more) sample(s). While a number of imputation methods exist to deal with
missing values, it might be more advisable to instead <em>rescue</em>
signal. <em>xcms</em> provides such <em>gap filling</em> which is
explained in the next section.</p>
</div>
<div class="section level3">
<h3 id="gap-filling">Gap filling<a class="anchor" aria-label="anchor" href="#gap-filling"></a>
</h3>
<p>Missing values in feature matrices from an <em>xcms</em>-based
preprocessing represent cases in which, in a particular sample, no
chromatographic peak was identified in the <em>m/z</em> - retention time
region of the feature. This could either represent a truly missing value
(because the ion/compound was not present in that sample) or a failure
of the peak detection algorithm to identify a peak (either because the
measured signal was too noisy, or too low, or a combination of
both).</p>
<p>To illustrate this we below define <em>m/z</em> - retention time
regions containing signal of features with missing values, extract their
EICs and plot them (using a different color for each sample). Note:
these regions were identified by first visually inspecting EICs for all
features with at least one missing value.</p>
<div class="sourceCode" id="cb129"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define m/z - rt regions for selected examples with missing peaks</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">109.661</span>, <span class="fl">109.664</span>, <span class="fl">192</span>, <span class="fl">200</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">109.993</span>, <span class="fl">109.998</span>, <span class="fl">200</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125.586</span>, <span class="fl">125.591</span>, <span class="fl">195</span>, <span class="fl">215</span><span class="op">)</span>,</span>
<span>               <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">130.959</span>, <span class="fl">130.961</span>, <span class="fl">197</span>, <span class="fl">201</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract their EICs and plot them</span></span>
<span><span class="va">chrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/features-missing-values-1.png" alt="Examples of features for which a peak was only identified in one sample." width="960"><p class="caption">
Examples of features for which a peak was only identified in one sample.
</p>
</div>
<p>Indeed, for all these feature, chromatographic peak detection failed
to identify a peak in one of the two samples (detected chromatographic
peaks are indicated with a grey background color in the plot above). For
the features in the upper panel, the signal was most likely too low,
while for the bottom left feature the signal was likely too noisy, and
for the bottom right too sparse (i.e. to few data points to properly
detect a peak). In all cases, however, signal from (presumably) the same
ion was measured in both samples. Thus, reporting a missing value would
not be correct for these.</p>
<p>The aim of the <em>gap filling</em> is now to <em>rescue</em> signal
for such features by integrating the intensities measured within the
feature’s <em>m/z</em> - retention time area in the sample(s) in which
no chromatographic peak was detected. In <em>xcms</em> this can be done
with the <code><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">fillChromPeaks()</a></code> function and the
<code>ChromPeakAreaParam</code> parameter to configure the gap filling.
Below we perform gap filling showing also the number of missing values
before and after running <code><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">fillChromPeaks()</a></code>.</p>
<div class="sourceCode" id="cb130"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Number of missing values</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 133</span></span></code></pre>
<div class="sourceCode" id="cb132"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Perform gap filling</span></span>
<span><span class="va">mse</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">fillChromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">ChromPeakAreaParam</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Number of missing values after gap filling</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 25</span></span></code></pre>
<p>With <code><a href="https://rdrr.io/pkg/xcms/man/fillChromPeaks.html" class="external-link">fillChromPeaks()</a></code> we could thus <em>rescue</em>
signal for all but 26 features. Also for the 4 example features from
above a signal was filled-in. Below we visualize the gap-filled
chromatographic peaks for these.</p>
<div class="sourceCode" id="cb134"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract their EICs and plot them</span></span>
<span><span class="va">chrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fl">3</span><span class="op">:</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/features-missing-values-filled-1.png" alt="Features with filled-in signal." width="960"><p class="caption">
Features with filled-in signal.
</p>
</div>
<p>In contrast, we identify and plot the EICs for features for which no
signal could be filled-in (i.e. which still have missing values in one
of the two samples).</p>
<div class="sourceCode" id="cb135"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Identify rows (features) with at least one missing value across samples</span></span>
<span><span class="va">any_na</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#' Get the feature IDs for these</span></span>
<span><span class="va">fts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="va">any_na</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' Extract the m/z - rt regions for these features</span></span>
<span><span class="va">mz_rt</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XcmsExperiment.html" class="external-link">featureArea</a></span><span class="op">(</span><span class="va">mse</span>, features <span class="op">=</span> <span class="va">fts</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Expand the retention time by 1 second on both sides</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmin"</span><span class="op">]</span> <span class="op">-</span> <span class="fl">1</span></span>
<span><span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="st">"rtmax"</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span></span>
<span></span>
<span><span class="va">chrs_na</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                        rt <span class="op">=</span> <span class="va">mz_rt</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"rtmin"</span>, <span class="st">"rtmax"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chrs_na</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"red"</span>, <span class="st">"blue"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/gap-filling-missing-1.png" alt="Features with missing values even after gap-filling." width="1152"><p class="caption">
Features with missing values even after gap-filling.
</p>
</div>
<p>For these features indeed signal was measured only in one of the two
samples.</p>
<p>An alternative way to confirm if gap-filling was able to correctly
rescue signals is to plot, for features with at least one missing value,
the average detected against the average filled-in signal. Ideally, this
should be done on QC samples or other repeatedly measured samples were
no difference in feature abundances between samples is expected.</p>
<p>The code below extracts first only the detected feature values (by
setting <code>filled = FALSE</code> in the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues()</a></code>
call), then the detected <strong>and</strong> filled-in signal. For the
latter, the detected signal is subsequently replaced with
<code>NA</code> to create a data matrix with only filled-in values.
Finally, after calculating the row averages for both matrices (excluding
missing values), these values are plotted against each other.</p>
<div class="sourceCode" id="cb136"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get only detected signal</span></span>
<span><span class="va">vals_detect</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span>, filled <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Get detected and filled-in signal</span></span>
<span><span class="va">vals_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Replace detected signal with NA</span></span>
<span><span class="va">vals_filled</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">vals_detect</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="cn">NA</span></span>
<span></span>
<span><span class="co">#' Identify features with at least one filled peak</span></span>
<span><span class="va">has_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">vals_detect</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Calculate row averages</span></span>
<span><span class="va">avg_detect</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="va">vals_detect</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">avg_filled</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="va">vals_filled</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Restrict to features with at least one filled peak</span></span>
<span><span class="va">avg_detect</span> <span class="op">&lt;-</span> <span class="va">avg_detect</span><span class="op">[</span><span class="va">has_filled</span><span class="op">]</span></span>
<span><span class="va">avg_filled</span> <span class="op">&lt;-</span> <span class="va">avg_filled</span><span class="op">[</span><span class="va">has_filled</span><span class="op">]</span></span>
<span></span>
<span><span class="co">#' plot the values against each other (in log2 scale)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_detect</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_filled</span><span class="op">)</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">avg_detect</span>, <span class="va">avg_filled</span><span class="op">)</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>     ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">avg_detect</span>, <span class="va">avg_filled</span><span class="op">)</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>     pch <span class="op">=</span> <span class="fl">21</span>, bg <span class="op">=</span> <span class="st">"#00000080"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/grid.html" class="external-link">grid</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/comparison-detected-filled-1.png" alt="Detected (x-axis) against filled (y-axis) signal. The black solid line represents the identity line." width="960"><p class="caption">
Detected (x-axis) against filled (y-axis) signal. The black solid line
represents the identity line.
</p>
</div>
<p>As expected, detected signal is generally higher than filled-in
signal. For the biggest part (in particular for higher intensities),
filled-in and detected feature values are similar suggesting that the
gap filling step indeed rescued signal.</p>
<p>We could also calculate statistics on these values. Below we fit a
linear regression line to the data and summarize its result.</p>
<div class="sourceCode" id="cb137"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' fit a linear regression line to the data</span></span>
<span><span class="va">l</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_filled</span><span class="op">)</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log2</a></span><span class="op">(</span><span class="va">avg_detect</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">l</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## lm(formula = log2(avg_filled) ~ log2(avg_detect))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residuals:</span></span>
<span><span class="co">##     Min      1Q  Median      3Q     Max </span></span>
<span><span class="co">## -4.4598 -0.3337  0.2518  0.7176  1.6402 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Coefficients:</span></span>
<span><span class="co">##                  Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept)      -1.34738    0.48180  -2.797  0.00613 ** </span></span>
<span><span class="co">## log2(avg_detect)  1.01347    0.04751  21.333  &lt; 2e-16 ***</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Residual standard error: 1.114 on 106 degrees of freedom</span></span>
<span><span class="co">##   (25 observations deleted due to missingness)</span></span>
<span><span class="co">## Multiple R-squared:  0.8111, Adjusted R-squared:  0.8093 </span></span>
<span><span class="co">## F-statistic: 455.1 on 1 and 106 DF,  p-value: &lt; 2.2e-16</span></span></code></pre>
<p>With a value of 1.007, the slope of the line is thus very close to
the slope of the identity line and the two sets of values are also
highly correlated (R squared of 0.81).</p>
</div>
<div class="section level3">
<h3 id="preprocessing-result">Preprocessing result<a class="anchor" aria-label="anchor" href="#preprocessing-result"></a>
</h3>
<p>The <em>xcms</em> preprocessing results are all stored within an
<code>XcmsExperiment</code> object. This includes the identified
chromatographic peaks, the alignment results as well as the
correspondence results. In addition, to guarantee reproducibility, this
result object keeps track of all performed processing steps and contains
also the individual parameter objects used in the various preprocessing
steps. These can be extracted with the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">processHistory()</a></code>
function:</p>
<div class="sourceCode" id="cb139"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Process history</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">processHistory</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak detection </span></span>
<span><span class="co">##  date: Wed Aug  7 11:31:52 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: CentWaveParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak refinement </span></span>
<span><span class="co">##  date: Wed Aug  7 11:31:54 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: MergeNeighboringPeaksParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[3]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak grouping </span></span>
<span><span class="co">##  date: Wed Aug  7 11:31:56 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakDensityParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[4]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Retention time correction </span></span>
<span><span class="co">##  date: Wed Aug  7 11:31:57 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakGroupsParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[5]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Peak grouping </span></span>
<span><span class="co">##  date: Wed Aug  7 11:32:00 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: PeakDensityParam </span></span>
<span><span class="co">##  MS level(s) 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[6]]</span></span>
<span><span class="co">## Object of class "XProcessHistory"</span></span>
<span><span class="co">##  type: Missing peak filling </span></span>
<span><span class="co">##  date: Wed Aug  7 11:32:03 2024 </span></span>
<span><span class="co">##  info:  </span></span>
<span><span class="co">##  fileIndex: 1,2 </span></span>
<span><span class="co">##  Parameter class: ChromPeakAreaParam </span></span>
<span><span class="co">##  MS level(s) 1</span></span></code></pre>
<p>An individual parameter object can be extracted as follows:</p>
<div class="sourceCode" id="cb141"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Peak detection parameters</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">processHistory</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">@</span><span class="va">param</span></span></code></pre></div>
<pre><code><span><span class="co">## Object of class:  CentWaveParam </span></span>
<span><span class="co">##  Parameters:</span></span>
<span><span class="co">##  - ppm: [1] 30</span></span>
<span><span class="co">##  - peakwidth: [1]  2 10</span></span>
<span><span class="co">##  - snthresh: [1] 10</span></span>
<span><span class="co">##  - prefilter: [1]   3 100</span></span>
<span><span class="co">##  - mzCenterFun: [1] "wMean"</span></span>
<span><span class="co">##  - integrate: [1] 2</span></span>
<span><span class="co">##  - mzdiff: [1] -0.001</span></span>
<span><span class="co">##  - fitgauss: [1] FALSE</span></span>
<span><span class="co">##  - noise: [1] 0</span></span>
<span><span class="co">##  - verboseColumns: [1] FALSE</span></span>
<span><span class="co">##  - roiList: list()</span></span>
<span><span class="co">##  - firstBaselineCheck: [1] TRUE</span></span>
<span><span class="co">##  - roiScales: numeric(0)</span></span>
<span><span class="co">##  - extendLengthMSW: [1] FALSE</span></span>
<span><span class="co">##  - verboseBetaColumns: [1] FALSE</span></span></code></pre>
<p>Thus, the used preprocessing algorithms along with all their settings
are reported along with the preprocessing results.</p>
<p>As described above, values for the individual features can be
extracted from the result object with the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues()</a></code>
function and the definition of the features (which could be used for an
initial annotation of the features based on their <em>m/z</em> and/or
retention times) using the <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions()</a></code> function.
In addition, the <code>XcmsExperiment</code> result object, through the
internal <code>Spectra</code> object, keeps a <em>link</em> to the full
MS data used for the analysis. For downstream analyses, that don’t need
access to this MS data anymore, the preprocessing results could be
represented equally well using a <code>SummarizedExperiment</code>
object, which is Bioconductor’s standard container for large-scale omics
data. <em>xcms</em> provides with the <code><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">quantify()</a></code> function a
convenience function to extract all results from an
<code>XcmsExperiment</code> result object and return it as a
<code>SummarizedExperiment</code>. This function takes the same
parameters than <code><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues()</a></code>, which is also internally
used to extract the feature value matrix.</p>
<div class="sourceCode" id="cb143"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract results as a SummarizedExperiment</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://bioconductor.org/packages/SummarizedExperiment" class="external-link">SummarizedExperiment</a></span><span class="op">)</span></span>
<span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">quantify</a></span><span class="op">(</span><span class="va">mse</span>, method <span class="op">=</span> <span class="st">"sum"</span><span class="op">)</span></span></code></pre></div>
<p>The sample annotations can now be accessed with the
<code><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">colData()</a></code> function and the feature definitions
(i.e. annotation for individual rows/features) with the
<code><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">rowData()</a></code> function:</p>
<div class="sourceCode" id="cb144"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get sample annotations</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">colData</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 2 rows and 5 columns</span></span>
<span><span class="co">##                                           file      sample injection_index</span></span>
<span><span class="co">##                                    &lt;character&gt; &lt;character&gt;       &lt;numeric&gt;</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML 20171016_P...      POOL_1               1</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML 20171016_P...      POOL_2              19</span></span>
<span><span class="co">##                                        group spectraOrigin</span></span>
<span><span class="co">##                                  &lt;character&gt;   &lt;character&gt;</span></span>
<span><span class="co">## 20171016_POOL_POS_1_105-134.mzML        POOL /__w/xcmsT...</span></span>
<span><span class="co">## 20171016_POOL_POS_3_105-134.mzML        POOL /__w/xcmsT...</span></span></code></pre>
<div class="sourceCode" id="cb146"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get feature annotations</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">rowData</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## DataFrame with 357 rows and 9 columns</span></span>
<span><span class="co">##           mzmed     mzmin     mzmax     rtmed     rtmin     rtmax    npeaks</span></span>
<span><span class="co">##       &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;</span></span>
<span><span class="co">## FT001   105.042   105.042   105.042  167.6896  167.5019  167.8773         2</span></span>
<span><span class="co">## FT002   105.042   105.042   105.042  157.7234  157.7234  157.7234         1</span></span>
<span><span class="co">## FT003   105.070   105.069   105.070   31.8081   31.6741   31.9421         2</span></span>
<span><span class="co">## FT004   105.110   105.110   105.111   63.7504   63.4566   64.0441         2</span></span>
<span><span class="co">## FT005   105.473   105.473   105.474  201.5763  201.3706  201.7820         2</span></span>
<span><span class="co">## ...         ...       ...       ...       ...       ...       ...       ...</span></span>
<span><span class="co">## FT353   133.929   133.929   133.929  193.3516   193.322  193.3808         2</span></span>
<span><span class="co">## FT354   133.956   133.956   133.956  199.0666   198.990  199.1432         2</span></span>
<span><span class="co">## FT355   133.960   133.960   133.961   30.8309    30.821   30.8409         2</span></span>
<span><span class="co">## FT356   133.973   133.973   133.973  206.8718   206.405  207.3387         2</span></span>
<span><span class="co">## FT357   133.973   133.973   133.973  200.2561   200.256  200.2561         1</span></span>
<span><span class="co">##            POOL  ms_level</span></span>
<span><span class="co">##       &lt;numeric&gt; &lt;integer&gt;</span></span>
<span><span class="co">## FT001         2         1</span></span>
<span><span class="co">## FT002         1         1</span></span>
<span><span class="co">## FT003         2         1</span></span>
<span><span class="co">## FT004         2         1</span></span>
<span><span class="co">## FT005         2         1</span></span>
<span><span class="co">## ...         ...       ...</span></span>
<span><span class="co">## FT353         2         1</span></span>
<span><span class="co">## FT354         2         1</span></span>
<span><span class="co">## FT355         2         1</span></span>
<span><span class="co">## FT356         2         1</span></span>
<span><span class="co">## FT357         1         1</span></span></code></pre>
<p>The feature values are stored as an <em>assay</em> within the object.
To access that we simply use the <code><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">assay()</a></code> function.</p>
<div class="sourceCode" id="cb148"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Get feature values</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">assay</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##       20171016_POOL_POS_1_105-134.mzML 20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## FT001                        3202.7445                        2285.2830</span></span>
<span><span class="co">## FT002                        3605.3915                        3191.7385</span></span>
<span><span class="co">## FT003                         744.8752                        1057.4312</span></span>
<span><span class="co">## FT004                       18126.4603                       19369.4039</span></span>
<span><span class="co">## FT005                       23243.6129                       31960.3709</span></span>
<span><span class="co">## FT006                         671.5842                         617.7545</span></span></code></pre>
<p><code>SummarizedExperiment</code> objects allow also to have multiple
<em>assay</em>-matrices. We could for example, in addition to the full
feature value matrix, also add a second assay with only the signals from
detected chromatographic peaks (i.e. without the gap-filled data).</p>
<div class="sourceCode" id="cb150"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Assign a new assay to the SummarizedExperiment result object</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/SummarizedExperiment/man/SummarizedExperiment-class.html" class="external-link">assay</a></span><span class="op">(</span><span class="va">res</span>, <span class="st">"raw_detected"</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span>, method <span class="op">=</span> <span class="st">"sum"</span>,</span>
<span>                                            filled <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<p>The <code>SummarizedExperiment</code> can be subset by rows and/or
columns. Such subset operations will correctly subset row- and column
data as well as all present assay matrices keeping the structure of the
data sub set intact.</p>
<div class="sourceCode" id="cb151"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Subset to the first 10 features</span></span>
<span><span class="va">res</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">## class: SummarizedExperiment </span></span>
<span><span class="co">## dim: 10 2 </span></span>
<span><span class="co">## metadata(6): '' '' ... '' ''</span></span>
<span><span class="co">## assays(2): raw raw_detected</span></span>
<span><span class="co">## rownames(10): FT001 FT002 ... FT009 FT010</span></span>
<span><span class="co">## rowData names(9): mzmed mzmin ... POOL ms_level</span></span>
<span><span class="co">## colnames(2): 20171016_POOL_POS_1_105-134.mzML</span></span>
<span><span class="co">##   20171016_POOL_POS_3_105-134.mzML</span></span>
<span><span class="co">## colData names(5): file sample injection_index group spectraOrigin</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="what-next">What next?<a class="anchor" aria-label="anchor" href="#what-next"></a>
</h3>
<p>After preprocessing, the data could be normalized or scaled to remove
any technical variances from the data. While a simple e.g. median
scaling could be done with a few lines of R code also more advanced (but
not always needed) normalization algorithms are available in
e.g. Bioconductor’s <em><a href="https://bioconductor.org/packages/3.19/preprocessCore" class="external-link">preprocessCore</a></em>
package.</p>
<p>Differential abundance analysis could be performed using the <em><a href="https://bioconductor.org/packages/3.19/limma" class="external-link">limma</a></em>
package or with any of the other packages or methods available in R.</p>
<p>As mentioned above, many chromatographic peaks (and subsequently also
features) in untargeted metabolomics data sets will represent isotopes
or also different ions/adducts of the same compound. The <em><a href="https://bioconductor.org/packages/3.19/CAMERA" class="external-link">CAMERA</a></em>
package aimed to identify and group such features in a data set. A
similar feature grouping (compounding) can also be done for
preprocessing results from newer versions of <em>xcms</em> using the
<em><a href="https://bioconductor.org/packages/3.19/MsFeatures" class="external-link">MsFeatures</a></em>
package. This package enables grouping of features through a variety of
different methods. See also the <a href="https://sneumann.github.io/xcms/articles/LC-MS-feature-grouping.html" class="external-link">feature
grouping vignette</a> in <em>xcms</em> for more details.</p>
<p>Finally, the <em><a href="https://bioconductor.org/packages/3.19/MetaboAnnotation" class="external-link">MetaboAnnotation</a></em>
package provides functions to assist in the annotation of features from
LC-MS as well as LC-MS/MS experiments. These allow to either perform an
initial annotation based on <em>m/z</em> values or through a combination
of <em>m/z</em> and retention time values. In addition, also annotations
based on fragment spectra (if available) are supported (with or without
considering in addition the features’ retention times. More information
is provided in the <a href="https://rformassspectrometry.github.io/MetaboAnnotation/articles/MetaboAnnotation.html" class="external-link">MetaboAnnotation
vignette</a> or <a href="https://jorainer.github.io/MetaboAnnotationTutorials/articles/annotation-use-cases.html" class="external-link">MetaboAnnotation
tutorial</a>.</p>
<p>For more information on general MS data analysis in R or spectra
similarity calculations can be found in the <a href="https://rformassspectrometry.github.io/book/" class="external-link">RforMassSpectrometry
book</a> or in the various workshops/tutorials at <a href="https://jorainer.github.io/SpectraTutorials" class="external-link">SpectraTutorials</a>.</p>
</div>
</div>
<div class="section level2">
<h2 id="final-words">Final words<a class="anchor" aria-label="anchor" href="#final-words"></a>
</h2>
<ul>
<li>
<code>xcms</code> is not a single, monolithic software, but part of
a package ecosystem.</li>
<li>Use the infrastructure provided by the RforMassSpectrometry package
ecosystem to inspect, explore and summarize the data.</li>
<li>Unleash the power of R!
<ul>
<li>Create own visualization/summarization functions if needed.</li>
<li>Combine functionalities from different packages.</li>
<li>Create customized (and reproducible) analysis workflows.</li>
</ul>
</li>
<li>Don’t use default settings for <em>xcms</em> preprocessing
algorithms.</li>
</ul>
</div>
<div class="section level2">
<h2 id="appendix">Appendix<a class="anchor" aria-label="anchor" href="#appendix"></a>
</h2>
<div class="section level3">
<h3 id="additional-analyses-performed-on-chromatographic-or-spectra-data-of-preprocessing-results">Additional analyses performed on chromatographic or spectra data of
preprocessing results<a class="anchor" aria-label="anchor" href="#additional-analyses-performed-on-chromatographic-or-spectra-data-of-preprocessing-results"></a>
</h3>
<p>While we used the basic functionality from <em>xcms</em> to perform
the preprocessing of an LC-MS experiment, more functionality and
visualization options would be available in the infrastructure provided
through the <em>xcms</em>, <em>Spectra</em>, <em>MsCoreUtils</em>,
<em>MetaboCoreUtils</em> and other related Bioconductor packages. It
would for example be easily possible to extract specific information for
selected chromatographic peaks or LC-MS features from an <em>xcms</em>
result object and perform some additional visualizations or analyses on
them. AS an example we below first identify chromatographic peaks that
would match the <em>m/z</em> of serine.</p>
<div class="sourceCode" id="cb153"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chromatographic peaks matching the m/z of the [M+H]+ of serine</span></span>
<span><span class="va">serine_pks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse</span>, mz <span class="op">=</span> <span class="va">serine_mz</span>, ppm <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">serine_pks</span></span></code></pre></div>
<pre><code><span><span class="co">##             mz    mzmin    mzmax       rt    rtmin    rtmax     into     intb</span></span>
<span><span class="co">## CP167 106.0506 106.0505 106.0506 181.0848 178.5814 187.4950 74181.78 73905.21</span></span>
<span><span class="co">## CP512 106.0496 106.0494 106.0508 181.3459 178.5474 187.4925 70373.61 70109.36</span></span>
<span><span class="co">##           maxo  sn sample</span></span>
<span><span class="co">## CP167 37664.94 685      1</span></span>
<span><span class="co">## CP512 38517.76 830      2</span></span></code></pre>
<p>The <code><a href="https://rdrr.io/pkg/xcms/man/chromPeakChromatograms.html" class="external-link">chromPeakChromatograms()</a></code> function can then be used
to extract the EIC of a specific chromatographic peak in a sample.</p>
<div class="sourceCode" id="cb155"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract EIC for the signal in the second sample</span></span>
<span><span class="va">serine_eic_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/chromPeakChromatograms.html" class="external-link">chromPeakChromatograms</a></span><span class="op">(</span><span class="va">mse</span>, peaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">serine_pks</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>We can also extract the full MS1 scan (spectrum) at the apex position
of that chromatographic peak using the <code><a href="https://rdrr.io/pkg/xcms/man/chromPeakSpectra.html" class="external-link">chromPeakSpectra()</a></code>
function with parameters <code>msLevel = 1</code> and
<code>method = "closest_rt"</code>.</p>
<div class="sourceCode" id="cb156"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract the full MS1 scan for the chrom peak at apex position</span></span>
<span><span class="va">serine_ms1_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/chromPeakSpectra.html" class="external-link">chromPeakSpectra</a></span><span class="op">(</span><span class="va">mse</span>, msLevel <span class="op">=</span> <span class="fl">1</span>, method <span class="op">=</span> <span class="st">"closest_rt"</span>,</span>
<span>                                 peaks <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">serine_pks</span><span class="op">)</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>For LC-MS/MS data, this function would also allow to extract all MS2
spectra from the data set with their precursor m/z (and retention time)
within the chromatographic peak’s <em>m/z</em> and retention time width
by using parameters <code>msLevel = 2</code> and
<code>method = "all"</code>.</p>
<p>Below we plot the EIC and the MS1 scan for the selected
chromatographic peak.</p>
<div class="sourceCode" id="cb157"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Plot the EIC</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">serine_eic_2</span><span class="op">)</span></span>
<span><span class="co">#' Indicate the retention time of the full scan MS1 spectrum</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">rtime</a></span><span class="op">(</span><span class="va">serine_ms1_2</span><span class="op">)</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#' Plot the full scan MS1 spectrum</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">serine_ms1_2</span><span class="op">)</span></span>
<span><span class="co">#' Indicate the theoretical m/z of the</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">serine_mz</span>, y <span class="op">=</span> <span class="op">-</span><span class="fl">300</span>, pch <span class="op">=</span> <span class="fl">2</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-67-1.png" alt="EIC for the [M+H]+ ion of serine in one sample and full scan MS1 spectrum at the EIC's apex position." width="960"><p class="caption">
EIC for the [M+H]+ ion of serine in one sample and full scan MS1
spectrum at the EIC’s apex position.
</p>
</div>
<p>Similar information can also be extracted for LC-MS features using
the <code><a href="https://rdrr.io/pkg/xcms/man/featureChromatograms.html" class="external-link">featureChromatograms()</a></code> and
<code><a href="https://rdrr.io/pkg/xcms/man/featureSpectra.html" class="external-link">featureSpectra()</a></code> functions but these functions will return
chromatograms and spectra for <strong>all</strong> samples in the
experiment (not just for a single sample). Also, importantly, while the
<code>chromPeakChromatogram()</code> extracts the EIC specific for the
selected sample, i.e. using the exact <em>m/z</em> and retention time
ranges of the chromatographic peak in that sample,
<code>featureChrommatograms()</code> will instead integrate the signal
from the <em>m/z</em> and retention time area of the
<strong>feature</strong>, i.e. will use a single area and integrate the
signal from that same area in each sample. This <em>m/z</em> - retention
time area might however be larger than the respective ranges for a
single chromatographic peak in one sample. This <em>m/z</em> - retention
time area for features can also be extracted (and evaluated) using the
<code><a href="https://rdrr.io/pkg/xcms/man/XcmsExperiment.html" class="external-link">featureArea()</a></code> function:</p>
<div class="sourceCode" id="cb158"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract the m/z - retention time area for features</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XcmsExperiment.html" class="external-link">featureArea</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mzmin    mzmax     rtmin     rtmax</span></span>
<span><span class="co">## FT001 105.0389 105.0448 162.48680 173.03646</span></span>
<span><span class="co">## FT002 105.0403 105.0434 154.65033 161.36642</span></span>
<span><span class="co">## FT003 105.0680 105.0727  30.56318  34.46556</span></span>
<span><span class="co">## FT004 105.1098 105.1114  61.19807  72.20464</span></span>
<span><span class="co">## FT005 105.4717 105.4747 198.86525 211.48482</span></span>
<span><span class="co">## FT006 105.7141 105.7183 179.69288 182.74128</span></span></code></pre>
<p>Additional analyses could now be performed on the full scan MS1
spectrum containing a mass peak for the [M+H]+ ion of serine. One
possibility would be to identify potential isotope peaks of the
monoisotopic mass peak of serine. The <code>isotopologues</code>
function from the <em><a href="https://bioconductor.org/packages/3.19/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
allows for example to identify and group potential isotope peaks in MS1
spectrum data without any assumptions on the chemical formula of the
compound of interest.</p>
<div class="sourceCode" id="cb160"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract the mass peak data from the MS1 spectrum containing</span></span>
<span><span class="co">#' the signal from an ion of serine</span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/peaksData.html" class="external-link">peaksData</a></span><span class="op">(</span><span class="va">serine_ms1_2</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##            mz intensity</span></span>
<span><span class="co">## [1,] 105.0338  97.01923</span></span>
<span><span class="co">## [2,] 105.7157 574.78322</span></span>
<span><span class="co">## [3,] 105.7288 137.45455</span></span>
<span><span class="co">## [4,] 105.8477 208.91608</span></span>
<span><span class="co">## [5,] 105.9348 239.67133</span></span>
<span><span class="co">## [6,] 105.9537 196.95804</span></span></code></pre>
<div class="sourceCode" id="cb162"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Identify mass peaks that could represent isotopes of the mass peak</span></span>
<span><span class="co">#' of the [M+H]+ ion of serine</span></span>
<span><span class="va">iso_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues</a></span><span class="op">(</span><span class="va">pd</span>, seedMz <span class="op">=</span> <span class="va">serine_mz</span><span class="op">)</span></span>
<span><span class="va">iso_idx</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## [1]  8 14</span></span></code></pre>
<p>The function thus identified two peaks that, based on their
<em>m/z</em> values and differences in intensity, could represent
isotopologues. We below highlight these mass peaks in the full MS1
spectrum.</p>
<div class="sourceCode" id="cb164"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Set the color for each mass peak to a transparent black color</span></span>
<span><span class="va">cols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"#00000040"</span>, <span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="va">serine_ms1_2</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#' Use a red color for the identified isotopologues</span></span>
<span><span class="va">cols</span><span class="op">[</span><span class="va">iso_idx</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="st">"#ff0000ff"</span></span>
<span><span class="co">#' Plot the data</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">serine_ms1_2</span>, col <span class="op">=</span> <span class="va">cols</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-70-1.png" alt="Full scan spectrum at apex position of the signal for the [M+H]+ ion for serine. Isotopologues are indicated in red." width="960"><p class="caption">
Full scan spectrum at apex position of the signal for the [M+H]+ ion for
serine. Isotopologues are indicated in red.
</p>
</div>
<p>While in the example above we were specifically looking for potential
isotopes of a single, selected, mass peak (by setting
<code>seedMz</code> to the <em>m/z</em> value of that peak), we could
also use <code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues()</a></code> without specifying
<code>seedMz</code> to identify all potential isotope groups in a
spectrum.</p>
<div class="sourceCode" id="cb165"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Identify all potential isotope peaks in the MS1 spectrum</span></span>
<span><span class="va">iso_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span>
<span><span class="va">iso_idx</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">## [1]  3 17</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">## [1]  8 14</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[3]]</span></span>
<span><span class="co">## [1] 34 40 43</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[4]]</span></span>
<span><span class="co">## [1] 42 50</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[5]]</span></span>
<span><span class="co">## [1] 66 74</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[6]]</span></span>
<span><span class="co">## [1] 78 85 88</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[7]]</span></span>
<span><span class="co">## [1] 100 104</span></span></code></pre>
<p>We can also highlight these in the spectrum plot.</p>
<div class="sourceCode" id="cb167"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define a color for all mass peaks and set it to transparent black</span></span>
<span><span class="va">cols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"#00000040"</span>, <span class="fu"><a href="https://rdrr.io/r/base/lengths.html" class="external-link">lengths</a></span><span class="op">(</span><span class="va">serine_ms1_2</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#' Use a different color for each isotope group</span></span>
<span><span class="va">iso_cols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/palettes.html" class="external-link">rainbow</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">iso_idx</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">iso_idx</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="va">cols</span><span class="op">[</span><span class="va">iso_idx</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">iso_cols</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Spectra/man/spectra-plotting.html" class="external-link">plotSpectra</a></span><span class="op">(</span><span class="va">serine_ms1_2</span>, col <span class="op">=</span> <span class="va">cols</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-72-1.png" alt="MS1 spectrum with potential isotope groups highlighted in different colors." width="960"><p class="caption">
MS1 spectrum with potential isotope groups highlighted in different
colors.
</p>
</div>
<p>Note that such isotopologue identification is not limited to data
from a MS1 spectrum. We could also identify features representing signal
from potential isotopes. For this we below create a <code>matrix</code>
with the features’ <em>m/z</em> values and the maximum intensity of the
feature in one of the samples and apply the <code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues()</a></code>
function on it.</p>
<div class="sourceCode" id="cb168"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Define a matrix with the m/z and intensity values for each feature.</span></span>
<span><span class="co">#' As intensity we use the highest measured intensity in the first</span></span>
<span><span class="co">#' sample</span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span></span>
<span>    mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">$</span><span class="va">mzmed</span>,</span>
<span>    intensity <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-peak-grouping-results.html" class="external-link">featureValues</a></span><span class="op">(</span><span class="va">mse</span>, value <span class="op">=</span> <span class="st">"maxo"</span><span class="op">)</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#' Ensure the matrix to be sorted by m/z value</span></span>
<span><span class="va">pd</span> <span class="op">&lt;-</span> <span class="va">pd</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">pd</span><span class="op">[</span>, <span class="st">"mz"</span><span class="op">]</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="co">#' Identify potential isotope groups</span></span>
<span><span class="va">iso_idx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues</a></span><span class="op">(</span><span class="va">pd</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">iso_idx</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">##       FT015 </span></span>
<span><span class="co">##     9    15 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">##       FT012 </span></span>
<span><span class="co">##    10    12 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[3]]</span></span>
<span><span class="co">##       FT023 FT046 </span></span>
<span><span class="co">##    13    23    46 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[4]]</span></span>
<span><span class="co">##       FT035 </span></span>
<span><span class="co">##    24    35 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[5]]</span></span>
<span><span class="co">##       FT040 FT060 FT069 </span></span>
<span><span class="co">##    29    40    60    69 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[6]]</span></span>
<span><span class="co">##       FT061 FT087 </span></span>
<span><span class="co">##    31    61    87</span></span></code></pre>
<p>We thus identified potential isotopologues, but, because we ignored
the retention times of the features in this simple approach, the list
will contain also many false positives. The features of the isotope
group below for example all have different retention times and can thus
not represent signal from isotopes of the same compound.</p>
<div class="sourceCode" id="cb170"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Show a false positive finding</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span><span class="va">iso_idx</span><span class="op">[[</span><span class="fl">3</span><span class="op">]</span><span class="op">]</span>, <span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##          mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks POOL</span></span>
<span><span class="co">## FT013 107.0654 107.0653 107.0656 173.2621 173.2108 173.3134      2    2</span></span>
<span><span class="co">## FT023 109.0634 109.0632 109.0636 161.6905 161.6466 161.7343      2    2</span></span>
<span><span class="co">## FT046 111.0601 111.0601 111.0601 181.0848 181.0848 181.0848      1    1</span></span>
<span><span class="co">##        peakidx ms_level</span></span>
<span><span class="co">## FT013 132, 429        1</span></span>
<span><span class="co">## FT023  76, 374        1</span></span>
<span><span class="co">## FT046      140        1</span></span></code></pre>
<p>Others however could be real isotopes:</p>
<div class="sourceCode" id="cb172"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">featureDefinitions</a></span><span class="op">(</span><span class="va">mse</span><span class="op">)</span><span class="op">[</span><span class="va">iso_idx</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span>, <span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##          mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks POOL</span></span>
<span><span class="co">## FT010 106.0501 106.0496 106.0506 181.2154 181.0848 181.3459      2    2</span></span>
<span><span class="co">## FT012 107.0535 107.0532 107.0538 181.2154 181.0848 181.3459      2    2</span></span>
<span><span class="co">##        peakidx ms_level</span></span>
<span><span class="co">## FT010 153, 461        1</span></span>
<span><span class="co">## FT012 143, 444        1</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="additional-visualizations">Additional visualizations<a class="anchor" aria-label="anchor" href="#additional-visualizations"></a>
</h3>
<p>Visualization is key to understand the signal measured by an MS
instrument and also to evaluate the performance (and quality) of the
preprocessing. However, LC-MS data is particularly difficult to
visualize because of its 3-dimensional nature. Focusing on specific
<em>m/z</em> - retention time ranges (EICs) can help, but provides only
information on small subsets of the whole data. In this section we
present an alternative approach to visualize the whole chromatographic
peak space from an LC-MS experiment.</p>
<p>We below subset the data to the first sample and visualize the
identified chromatographic peaks in the <em>m/z</em> - retention time
plane using the <code><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks()</a></code> function that we used
already before.</p>
<div class="sourceCode" id="cb174"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot identified chromatographic peaks in the first sample</span></span>
<span><span class="va">mse_1</span> <span class="op">&lt;-</span> <span class="va">mse</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">mse_1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-76-1.png" alt="Position of identified chromatographic peaks in the first sample." width="960"><p class="caption">
Position of identified chromatographic peaks in the first sample.
</p>
</div>
<p>While this plot provides information on the region in which peaks
were identified and on the retention time widths of the peaks, it does
not allow to investigate peak shapes or intensities. Such information
would be provided (for a single ion) by an extracted ion chromatogram.
We thus below extract ion chromatograms for every identified
chromatographic peak in the first sample. With parameter
<code>expandRt = 4</code> we increase for each chromatographic peak the
region from which the data will be extracted by 4 seconds on either
side.</p>
<div class="sourceCode" id="cb175"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract EICs for each identified chromatographic peak</span></span>
<span><span class="va">chrs_all</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/chromPeakChromatograms.html" class="external-link">chromPeakChromatograms</a></span><span class="op">(</span><span class="va">mse_1</span>, expandRt <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<p>While we could now simply proceed and plot each of the 356 EICs
separately, we instead use below the
<code><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay()</a></code> function that allows to plot
multiple EICs into the same plot hence providing an overview of the full
set of identified chromatographic peaks. By setting parameter
<code>stacked</code> to a value different then <code>0</code> it is
possible to <em>stack</em> the chromatograms along the y-axis hence
providing a simple 3-dimensional impression of the data. For easier
visualization we in addition increase the transparency of the colors for
the individual lines (parameter <code>col</code>), and the identified
chromatographic peaks (parameter <code>peakCol</code> and
<code>peakBg</code> for the foreground and background color,
respectively).</p>
<div class="sourceCode" id="cb176"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Create a stacked EIC plot</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay</a></span><span class="op">(</span><span class="va">chrs_all</span>, stacked <span class="op">=</span> <span class="fl">1</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>                         col <span class="op">=</span> <span class="st">"#00000020"</span>, peakCol <span class="op">=</span> <span class="st">"#00000020"</span>,</span>
<span>                         peakBg <span class="op">=</span> <span class="st">"#00000020"</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-78-1.png" alt="All identified chromatographic peaks in one sample shown as a pseudo 3-dimensional plot." width="960"><p class="caption">
All identified chromatographic peaks in one sample shown as a pseudo
3-dimensional plot.
</p>
</div>
<p>This plot thus provides a general overview of the detected signal
(chromatographic peaks) of a data file. We can immediately spot some
very high intensity peaks, regions with higher number of ions and also
signal from potential contaminants.</p>
<p>Instead of the full data range we can also zoom into a region and
extract EICs from that for a closer inspection of the data. Below we
define an area from a <em>m/z</em> value from 113 to 119 and a retention
time from 125 to 145 seconds.</p>
<div class="sourceCode" id="cb177"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot location of all peaks and highlight region of interest</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromPeaks.html" class="external-link">plotChromPeaks</a></span><span class="op">(</span><span class="va">mse_1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/rect.html" class="external-link">rect</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fl">113</span>, <span class="fl">145</span>, <span class="fl">119</span>, lty <span class="op">=</span> <span class="fl">3</span>, border <span class="op">=</span> <span class="st">"#ff000080"</span>, lwd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-79-1.png" alt="Selected region from which EICs should be extracted and plotted." width="960"><p class="caption">
Selected region from which EICs should be extracted and plotted.
</p>
</div>
<p>With the <em>m/z</em> ranges from the chromatographic peaks in that
region defined, we can next extract ion chromatograms for the data
slices defined by these <em>m/z</em> ranges and the selected (fixed)
retention time range.</p>
<div class="sourceCode" id="cb178"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Extract chrom peaks from that region</span></span>
<span><span class="va">pks</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/XCMSnExp-class.html" class="external-link">chromPeaks</a></span><span class="op">(</span><span class="va">mse_1</span>, mz <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">113</span>, <span class="fl">119</span><span class="op">)</span>, rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fl">145</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Extract EICs for the m/z slices of the chromatographic peaks</span></span>
<span><span class="co">#' and the full retention time window of the area</span></span>
<span><span class="va">chrs_sub</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">chromatogram</a></span><span class="op">(</span><span class="va">mse_1</span>, mz <span class="op">=</span> <span class="va">pks</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mzmin"</span>, <span class="st">"mzmax"</span><span class="op">)</span><span class="op">]</span>,</span>
<span>                         rt <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">125</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pks</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                                    <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">145</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pks</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We can now plot the EICs from that region again using the
<code><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay()</a></code> function. Next to plotting the
data, this function also silently returns the y-positions of the
individual EICs in the plot. We assign that below to a variable
<code>y</code> and use this information to draw the <em>m/z</em> for the
EICs along the y-axis.</p>
<div class="sourceCode" id="cb179"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Plot the EICs of the selected area</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/plotChromatogramsOverlay.html" class="external-link">plotChromatogramsOverlay</a></span><span class="op">(</span><span class="va">chrs_sub</span>, stacked <span class="op">=</span> <span class="fl">1</span>, bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>                              col <span class="op">=</span> <span class="st">"#00000020"</span>, peakCol <span class="op">=</span> <span class="st">"#00000020"</span>,</span>
<span>                              peakBg <span class="op">=</span> <span class="st">"#00000020"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#' Draw horizonal lines</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>h <span class="op">=</span> <span class="va">y</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, col <span class="op">=</span> <span class="st">"#00000020"</span>, lty <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#' Add m/z values of the EICs to the plot</span></span>
<span><span class="va">mzs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/format.html" class="external-link">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/MatrixGenerics/man/rowMeans.html" class="external-link">rowMeans</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ProtGenerics/man/protgenerics.html" class="external-link">mz</a></span><span class="op">(</span><span class="va">chrs_sub</span><span class="op">)</span><span class="op">)</span>, digits <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/text.html" class="external-link">text</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">126</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">mzs</span><span class="op">)</span><span class="op">)</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>,</span>
<span>     labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"m/z = "</span>, <span class="va">mzs</span><span class="op">)</span>, pos <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="xcms-preprocessing_files/figure-html/unnamed-chunk-81-1.png" alt="EICs from a selected *m/z* - retention time region." width="960"><p class="caption">
EICs from a selected <em>m/z</em> - retention time region.
</p>
</div>
<p>Some of the EICs seem to represent signals from isotopes (e.g. the
EIC at 114.07 and 115.07). In fact, we can again use the
<code><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues()</a></code> function from the <em><a href="https://bioconductor.org/packages/3.19/MetaboCoreUtils" class="external-link">MetaboCoreUtils</a></em>
to check whether pairs of <em>m/z</em> and intensity values would match
signal expected for isotopes.</p>
<div class="sourceCode" id="cb180"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' Order the extracted chromatographic peaks by m/z</span></span>
<span><span class="va">pks</span> <span class="op">&lt;-</span> <span class="va">pks</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">pks</span><span class="op">[</span>, <span class="st">"mz"</span><span class="op">]</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="co">#' Test which signals could come from isotopes</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/MetaboCoreUtils/man/isotopologues.html" class="external-link">isotopologues</a></span><span class="op">(</span><span class="va">pks</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mz"</span>, <span class="st">"into"</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">##       CP053 </span></span>
<span><span class="co">##     2     3 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">##       CP054 </span></span>
<span><span class="co">##     4     5</span></span></code></pre>
<p>Pairs of chromatographic peaks have been identified as being
potential isotopologues.</p>
</div>
<div class="section level3">
<h3 id="bonus-material---peak-detection-fun">Bonus material - peak detection fun<a class="anchor" aria-label="anchor" href="#bonus-material---peak-detection-fun"></a>
</h3>
<p>In this section we apply the lessons learned from previous sections,
in particular how to adapt peak detection setting on a rather noisy
<em>chromatographic</em> data. Below we load the example data from a
text file.</p>
<div class="sourceCode" id="cb182"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cdata</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/read.table.html" class="external-link">read.table</a></span><span class="op">(</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"txt"</span>, <span class="st">"chromatogram.txt"</span>, package <span class="op">=</span> <span class="st">"xcmsTutorials"</span><span class="op">)</span>,</span>
<span>    sep <span class="op">=</span> <span class="st">"\t"</span>, header <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">cdata</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##    rt intensity</span></span>
<span><span class="co">## 1 100         0</span></span>
<span><span class="co">## 2 110         0</span></span>
<span><span class="co">## 3 120         1</span></span>
<span><span class="co">## 4 130         2</span></span>
<span><span class="co">## 5 140         4</span></span>
<span><span class="co">## 6 150         6</span></span></code></pre>
<p>Our data has two columns, one with <em>retention times</em> and one
with <em>intensities</em>. We can now create a <code>Chromatogram</code>
object from that and plot the data.</p>
<div class="sourceCode" id="cb184"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://lgatto.github.io/MSnbase" class="external-link">MSnbase</a></span><span class="op">)</span></span>
<span><span class="va">chr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://lgatto.github.io/MSnbase/reference/Chromatogram-class.html" class="external-link">Chromatogram</a></span><span class="op">(</span>rtime <span class="op">=</span> <span class="va">cdata</span><span class="op">$</span><span class="va">rt</span>, intensity <span class="op">=</span> <span class="va">cdata</span><span class="op">$</span><span class="va">intensity</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">chr</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/peaks-plot-1.png" width="1152"></p>
<p>There are two peaks present in the data, with the signal from the
latter being particularly noisy. The goal is now to perform the peak
detection and to identify the two peaks. A first try with the default
settings for <em>centWave</em> clearly shows that we have to tune the
parameters (note that the setting of <code>sn = 0</code> is required for
the present data set as there are not enough <em>background</em> data
points for the algorithm to estimate the noise level properly).</p>
<p>Which parameter would you now adapt to the data? What would be your
choices? Go ahead and try different settings or setting combination to
see if you can succeed in detecting the two peaks. Eventually you might
even try a different peak detection algorithm
(e.g. <code>MatchedFilterParam</code>).</p>
<div class="sourceCode" id="cb185"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">xchr</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks.html" class="external-link">findChromPeaks</a></span><span class="op">(</span><span class="va">chr</span>, param <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/xcms/man/findChromPeaks-centWave.html" class="external-link">CentWaveParam</a></span><span class="op">(</span>sn <span class="op">=</span> <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">xchr</span><span class="op">)</span></span></code></pre></div>
<p><img src="xcms-preprocessing_files/figure-html/peaks-fail-1.png" width="1152"></p>
<p>With the default parameters centWave clearly failed to identify the
two large peaks, defining only smaller fragments of them as potential
peaks. Especially the second peak with its peculiar tri-forked shape
seems to cause troubles. This would be even for a hydrophilic liquid
interaction chromatography (HILIC), known to potentially result in noisy
odd-shaped peaks, a rather unusual peak shape. In fact, the signal we
were analyzing here is not of chromatographic origin:</p>
<p><img src="xcms-preprocessing_files/figure-html/peaks-solution-1.png" width="1152"></p>
<p>Our example data represents a panorama picture featuring mountains
from the Dolomites, the <a href="https://en.wikipedia.org/wiki/Paternkofel" class="external-link"><em>Paternkofel</em></a>
(left peak, colored red) and the famous <a href="https://en.wikipedia.org/wiki/Tre_Cime_di_Lavaredo" class="external-link"><em>Drei
Zinnen</em></a> (right tri-forked peak colored green).</p>
</div>
</div>
<div class="section level2">
<h2 id="session-information">Session information<a class="anchor" aria-label="anchor" href="#session-information"></a>
</h2>
<div class="sourceCode" id="cb186"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/sessionInfo.html" class="external-link">sessionInfo</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## R version 4.4.1 (2024-06-14)</span></span>
<span><span class="co">## Platform: x86_64-pc-linux-gnu</span></span>
<span><span class="co">## Running under: Ubuntu 22.04.4 LTS</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Matrix products: default</span></span>
<span><span class="co">## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 </span></span>
<span><span class="co">## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## locale:</span></span>
<span><span class="co">##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              </span></span>
<span><span class="co">##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    </span></span>
<span><span class="co">##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   </span></span>
<span><span class="co">##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 </span></span>
<span><span class="co">##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            </span></span>
<span><span class="co">## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## time zone: Etc/UTC</span></span>
<span><span class="co">## tzcode source: system (glibc)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## attached base packages:</span></span>
<span><span class="co">## [1] stats4    stats     graphics  grDevices utils     datasets  methods  </span></span>
<span><span class="co">## [8] base     </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## other attached packages:</span></span>
<span><span class="co">##  [1] RColorBrewer_1.1-3          png_0.1-8                  </span></span>
<span><span class="co">##  [3] MSnbase_2.30.1              mzR_2.38.0                 </span></span>
<span><span class="co">##  [5] Rcpp_1.0.13                 SummarizedExperiment_1.34.0</span></span>
<span><span class="co">##  [7] Biobase_2.64.0              GenomicRanges_1.56.1       </span></span>
<span><span class="co">##  [9] GenomeInfoDb_1.40.1         IRanges_2.38.1             </span></span>
<span><span class="co">## [11] MatrixGenerics_1.16.0       matrixStats_1.3.0          </span></span>
<span><span class="co">## [13] MetaboCoreUtils_1.12.0      pheatmap_1.0.12            </span></span>
<span><span class="co">## [15] Spectra_1.14.1              S4Vectors_0.42.1           </span></span>
<span><span class="co">## [17] BiocGenerics_0.50.0         MsExperiment_1.6.0         </span></span>
<span><span class="co">## [19] ProtGenerics_1.36.0         xcms_4.2.2                 </span></span>
<span><span class="co">## [21] BiocParallel_1.38.0         rmarkdown_2.27             </span></span>
<span><span class="co">## [23] knitr_1.48                  BiocStyle_2.32.1           </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## loaded via a namespace (and not attached):</span></span>
<span><span class="co">##  [1] DBI_1.2.3                   rlang_1.1.4                </span></span>
<span><span class="co">##  [3] magrittr_2.0.3              clue_0.3-65                </span></span>
<span><span class="co">##  [5] MassSpecWavelet_1.70.0      compiler_4.4.1             </span></span>
<span><span class="co">##  [7] systemfonts_1.1.0           vctrs_0.6.5                </span></span>
<span><span class="co">##  [9] reshape2_1.4.4              stringr_1.5.1              </span></span>
<span><span class="co">## [11] pkgconfig_2.0.3             crayon_1.5.3               </span></span>
<span><span class="co">## [13] fastmap_1.2.0               XVector_0.44.0             </span></span>
<span><span class="co">## [15] utf8_1.2.4                  UCSC.utils_1.0.0           </span></span>
<span><span class="co">## [17] preprocessCore_1.66.0       ragg_1.3.2                 </span></span>
<span><span class="co">## [19] purrr_1.0.2                 xfun_0.46                  </span></span>
<span><span class="co">## [21] MultiAssayExperiment_1.30.3 zlibbioc_1.50.0            </span></span>
<span><span class="co">## [23] cachem_1.1.0                jsonlite_1.8.8             </span></span>
<span><span class="co">## [25] progress_1.2.3              highr_0.11                 </span></span>
<span><span class="co">## [27] DelayedArray_0.30.1         prettyunits_1.2.0          </span></span>
<span><span class="co">## [29] parallel_4.4.1              cluster_2.1.6              </span></span>
<span><span class="co">## [31] R6_2.5.1                    bslib_0.8.0                </span></span>
<span><span class="co">## [33] stringi_1.8.4               limma_3.60.4               </span></span>
<span><span class="co">## [35] jquerylib_0.1.4             iterators_1.0.14           </span></span>
<span><span class="co">## [37] bookdown_0.40               Matrix_1.7-0               </span></span>
<span><span class="co">## [39] igraph_2.0.3                tidyselect_1.2.1           </span></span>
<span><span class="co">## [41] abind_1.4-5                 yaml_2.3.10                </span></span>
<span><span class="co">## [43] doParallel_1.0.17           codetools_0.2-20           </span></span>
<span><span class="co">## [45] affy_1.82.0                 lattice_0.22-6             </span></span>
<span><span class="co">## [47] tibble_3.2.1                plyr_1.8.9                 </span></span>
<span><span class="co">## [49] evaluate_0.24.0             desc_1.4.3                 </span></span>
<span><span class="co">## [51] pillar_1.9.0                affyio_1.74.0              </span></span>
<span><span class="co">## [53] BiocManager_1.30.23         foreach_1.5.2              </span></span>
<span><span class="co">## [55] MALDIquant_1.22.2           ncdf4_1.22                 </span></span>
<span><span class="co">## [57] generics_0.1.3              hms_1.1.3                  </span></span>
<span><span class="co">## [59] ggplot2_3.5.1               munsell_0.5.1              </span></span>
<span><span class="co">## [61] scales_1.3.0                glue_1.7.0                 </span></span>
<span><span class="co">## [63] MsFeatures_1.12.0           lazyeval_0.2.2             </span></span>
<span><span class="co">## [65] tools_4.4.1                 mzID_1.42.0                </span></span>
<span><span class="co">## [67] QFeatures_1.14.2            vsn_3.72.0                 </span></span>
<span><span class="co">## [69] fs_1.6.4                    XML_3.99-0.17              </span></span>
<span><span class="co">## [71] grid_4.4.1                  impute_1.78.0              </span></span>
<span><span class="co">## [73] tidyr_1.3.1                 MsCoreUtils_1.16.1         </span></span>
<span><span class="co">## [75] colorspace_2.1-1            GenomeInfoDbData_1.2.12    </span></span>
<span><span class="co">## [77] PSMatch_1.8.0               cli_3.6.3                  </span></span>
<span><span class="co">## [79] textshaping_0.4.0           fansi_1.0.6                </span></span>
<span><span class="co">## [81] S4Arrays_1.4.1              dplyr_1.1.4                </span></span>
<span><span class="co">## [83] AnnotationFilter_1.28.0     pcaMethods_1.96.0          </span></span>
<span><span class="co">## [85] gtable_0.3.5                sass_0.4.9                 </span></span>
<span><span class="co">## [87] digest_0.6.36               SparseArray_1.4.8          </span></span>
<span><span class="co">## [89] htmlwidgets_1.6.4           htmltools_0.5.8.1          </span></span>
<span><span class="co">## [91] pkgdown_2.1.0               lifecycle_1.0.4            </span></span>
<span><span class="co">## [93] httr_1.4.7                  statmod_1.5.0              </span></span>
<span><span class="co">## [95] MASS_7.3-61</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="acknowledgments">Acknowledgments<a class="anchor" aria-label="anchor" href="#acknowledgments"></a>
</h2>
<p>Thank you to <a href="https://github.com/philouail" class="external-link">Philippine
Louail</a> for fixing typos and suggesting improvements.</p>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Conley:2014ha" class="csl-entry">
Conley, Christopher J, Rob Smith, Ralf J O Torgrip, Ryan M Taylor, Ralf
Tautenhahn, and John T Prince. 2014. <span>“<span class="nocase">Massifquant: open-source Kalman filter-based XC-MS
isotope trace feature detection.</span>”</span> <em>Bioinformatics</em>
30 (18): 2636–43.
</div>
<div id="ref-Katajamaa:2006jh" class="csl-entry">
Katajamaa, Mikko, Jarkko Miettinen, and Matej Oresic. 2006. <span>“<span class="nocase">MZmine: toolbox for processing and visualization of mass
spectrometry based molecular profile data.</span>”</span>
<em>Bioinformatics</em> 22 (5): 634–36.
</div>
<div id="ref-naake_msquality_2023" class="csl-entry">
Naake, Thomas, Johannes Rainer, and Wolfgang Huber. 2023.
<span>“<span>MsQuality</span> - an Interoperable Open-Source Package for
the Calculation of Standardized Quality Metrics of Mass Spectrometry
Data.”</span> <em>Bioinformatics (Oxford, England)</em>, October,
btad618. <a href="https://doi.org/10.1093/bioinformatics/btad618" class="external-link">https://doi.org/10.1093/bioinformatics/btad618</a>.
</div>
<div id="ref-Prince:2006jj" class="csl-entry">
Prince, John T, and Edward M Marcotte. 2006. <span>“<span class="nocase">Chromatographic alignment of ESI-LC-MS proteomics data
sets by ordered bijective interpolated warping.</span>”</span>
<em>Analytical Chemistry</em> 78 (17): 6140–52.
</div>
<div id="ref-Smith:2006ic" class="csl-entry">
Smith, Colin A, Elizabeth J Want, Grace O’Maille, Ruben Abagyan, and
Gary Siuzdak. 2006. <span>“<span class="nocase">XCMS: processing mass
spectrometry data for metabolite profiling using nonlinear peak
alignment, matching, and identification.</span>”</span> <em>Analytical
Chemistry</em> 78 (3): 779–87.
</div>
<div id="ref-Smith:2014di" class="csl-entry">
Smith, Rob, Andrew D Mathis, Dan Ventura, and John T Prince. 2014.
<span>“<span class="nocase">Proteomics, lipidomics, metabolomics: a mass
spectrometry tutorial from a computer scientist’s point of
view.</span>”</span> <em>BMC Bioinformatics</em> 15 Suppl 7 (Suppl 7):
S9.
</div>
<div id="ref-Tautenhahn:2008fx" class="csl-entry">
Tautenhahn, Ralf, Christoph Böttcher, and Steffen Neumann. 2008.
<span>“<span class="nocase">Highly sensitive feature detection for high
resolution LC/MS.</span>”</span> <em>BMC Bioinformatics</em> 9 (1): 504.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Johannes Rainer.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
